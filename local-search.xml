<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>水下机器人岸基客户端开发</title>
    <link href="/2024/05/09/%E6%B0%B4%E4%B8%8B%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%B2%B8%E5%9F%BA%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    <url>/2024/05/09/%E6%B0%B4%E4%B8%8B%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%B2%B8%E5%9F%BA%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h1 id="水下机器人岸基客户端"><a href="#水下机器人岸基客户端" class="headerlink" title="水下机器人岸基客户端"></a>水下机器人岸基客户端</h1><p>背景概述：2023.7–2024.5 任职青岛澎湃海洋科技有限公司，软件开发工程师，负责水下机器人岸基客户端的开发与维护。</p><h2 id="1、项目概述与角色"><a href="#1、项目概述与角色" class="headerlink" title="1、项目概述与角色"></a>1、项目概述与角色</h2><p>（1）项目的背景和目标：公司主要经营自主式水下机器人（潜航器）的研发与生产，对于水下机器人的控制与监测需要一套岸基操作系统，开发和设计岸基操作软件的客户端，实现对水下机器人的远程控制与数据传输。</p><p>（2）我所担任的角色（我在项目中承担的任务）：作为项目的主要开发者与维护者，负责设计和实现岸基界面，使用C++和Qt框架，在linux环境下基于MOOS框架开发。设计、实现、优化岸基界面及其与水下机器人的人机交互。</p><h2 id="2、技术栈与工具"><a href="#2、技术栈与工具" class="headerlink" title="2、技术栈与工具"></a>2、技术栈与工具</h2><p>所用技术与工具：C++、Qt、Mysql、网络编程、多线程、Linux、MOSS框架</p><p>C++用于实现项目的核心功能，包括数据处理、通信模块以及控制逻辑等。Qt作为界面开发的主要工具，能够支持创建直观、清晰快速响应的岸基界面，提供丰富的用户交互体验。另外，Qt的跨平台移植能力较强，适用于各种操作系统。</p><p>公司研发的水下潜航器是基于MOOS框架搭建的，MOOS为水下机器人系统提供了必要的通信和数据处理能力，其中MOOSDB提供了消息的订阅与转发机制，通过岸基界面与MOOSDB进行数据通信与交互，从而实现岸基客户端与水下机器人的数据交换和控制指令的发送。</p><h2 id="3、项目过程中遇到的挑战"><a href="#3、项目过程中遇到的挑战" class="headerlink" title="3、项目过程中遇到的挑战"></a>3、项目过程中遇到的挑战</h2><p>（持续优化，想到在写，结合实际情况具体阐述）</p><p>在项目开发过程中，我面临了多个挑战，其中一个主要挑战是处理实时数据和保证系统的稳定性。由于水下机器人的操作需要高度的准确性和实时性，我需要设计高效的数据处理算法，并优化系统的资源利用，以确保岸基客户端能够及时、准确地与水下机器人进行通信和控制。</p><p>另外，界面的设计和交互体验也是一个挑战，因为要考虑到操作人员在实际使用中的需求和习惯，我通过用户反馈和不断优化，逐步提升了岸基界面的易用性和效率。</p><p>地图功能的实现，地图选点、发送到地图等功能也可以结合HTML来描述。</p><h2 id="4、项目成果和贡献"><a href="#4、项目成果和贡献" class="headerlink" title="4、项目成果和贡献"></a>4、项目成果和贡献</h2><p>我的工作使得水下机器人岸基客户端功能更加完善和稳定，为水下机器人操作人员提供了便利和高效的使用环境。我设计和实现的岸基界面大大提升了操作员的操作体验，使得控制水下机器人变得更加直观和可靠。</p><p>另外，我还负责优化数据传输和处理流程，通过引入异步处理机制和内存管理技术，提高了系统的性能和稳定性，确保了水下机器人的实时响应和数据准确性。</p><p>5、团队协作与沟通</p><p>在实际开发过程中，需要与水下机器人团队密切合作，与硬件工程师、算法工程师和控制组成员以及其他开发者共同商讨需求和解决方案。我们使用Git进行版本控制和团队协作，保证代码的一致性和可维护性。通过定期的沟通会议和协作工具，我能够及时了解用户需求，并将其转化为具体的界面设计和功能开发。公司搭建了服务器，可以将代码和相关程序部署到服务器，以便成员使用和访问。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>算法刷题</title>
    <link href="/2024/05/09/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    <url>/2024/05/09/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="单调栈刷题总结"><a href="#单调栈刷题总结" class="headerlink" title="单调栈刷题总结"></a>单调栈刷题总结</h1><h2 id="1、力扣题目"><a href="#1、力扣题目" class="headerlink" title="1、力扣题目"></a>1、力扣题目</h2><p>（每日温度）<a href="https://leetcode.cn/problems/daily-temperatures/">https://leetcode.cn/problems/daily-temperatures/</a></p><p>（下一个更大元素|）<a href="https://leetcode.cn/problems/next-greater-element-i/">https://leetcode.cn/problems/next-greater-element-i/</a></p><p>（下一个更大元素||）<a href="https://leetcode.cn/problems/next-greater-element-ii/">https://leetcode.cn/problems/next-greater-element-ii/</a></p><p>（接雨水）<a href="https://leetcode.cn/problems/trapping-rain-water/">https://leetcode.cn/problems/trapping-rain-water/</a></p><p>（最大矩形面积）<a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">https://leetcode.cn/problems/largest-rectangle-in-histogram/</a></p><h2 id="2、学习笔记"><a href="#2、学习笔记" class="headerlink" title="2、学习笔记"></a>2、学习笔记</h2><p>（1）什么是单调栈：利用一维数组模拟栈，按照从大到小或者从小到大的顺序，去记录遍历过的元素或者元素下标，利用空间换取时间的一种方式。</p><p>（2）什么时候适用单调栈解题：当需要寻找一个元素的左边或者右边第一个比自己大或者小的元素的时候，可以考虑使用单调栈。</p><p>（3）在使用单调栈的时候首先要明确如下几点：</p><ol><li>单调栈里存放的元素是什么？</li></ol><p>单调栈里只需要存放元素的下标i就可以了，如果需要使用对应的元素，直接T[i]就可以获取。</p><ol><li>单调栈里元素是递增呢？ 还是递减呢？</li></ol><p><strong>注意以下讲解中，顺序的描述为 从栈头到栈底的顺序</strong>，因为单纯的说从左到右或者从前到后，不说栈头朝哪个方向的话，大家一定比较懵。</p><p>这里我们要使用递增循序（再强调一下是指从栈头到栈底的顺序），因为只有递增的时候，栈里要加入一个元素i的时候，才知道栈顶元素在数组中右面第一个比栈顶元素大的元素是i。</p><p>即：如果求一个元素右边第一个更大元素，单调栈就是递增的，如果求一个元素右边第一个更小元素，单调栈就是递减的。</p><p>（4）使用单调栈主要有三个判断条件：</p><ul><li>当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况</li><li>当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况</li><li>当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况</li></ul><h2 id="3、刷题总结"><a href="#3、刷题总结" class="headerlink" title="3、刷题总结"></a>3、刷题总结</h2><h3 id="（1）每日温度："><a href="#（1）每日温度：" class="headerlink" title="（1）每日温度："></a>（1）每日温度：</h3><p>理清楚单调栈在递增情况下，三个判断条件对应的处理逻辑，本题求的是下一个比自己高的元素距离自己的距离，所以在收集结果的时候统计的是下标之间的差值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; T)</span> </span>&#123;<br>        <span class="hljs-comment">// 递增栈</span><br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(T.size(), <span class="hljs-number">0</span>)</span></span>;<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; T.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (T[i] &lt; T[st.<span class="hljs-built_in">top</span>()]) &#123;                       <span class="hljs-comment">// 情况一</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (T[i] == T[st.<span class="hljs-built_in">top</span>()]) &#123;               <span class="hljs-comment">// 情况二</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; T[i] &gt; T[st.<span class="hljs-built_in">top</span>()]) &#123; <span class="hljs-comment">// 情况三 收集结果是两个元素之间的距离</span><br>                    result[st.<span class="hljs-built_in">top</span>()] = i - st.<span class="hljs-built_in">top</span>();<br>                    st.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="（2）下一个更大元素-："><a href="#（2）下一个更大元素-：" class="headerlink" title="（2）下一个更大元素|："></a>（2）下一个更大元素|：</h3><p>相较于上面一道题目，讨论一个外壳，其本质还是单调栈的思路。不同的是，需要在nums2中找nums1中的元素的下一个比它大的值，可以看出顺序还是从小到大的单调栈。但是需要map做映射，方便判断nums2[i]是否在nums1中出现过。C++中，当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的。</p><p>接下来就要分析如下三种情况：</p><ol><li>情况一：当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况</li></ol><p>此时满足递增栈（栈头到栈底的顺序），所以直接入栈。</p><ol><li>情况二：当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况</li></ol><p>如果相等的话，依然直接入栈，因为我们要求的是右边第一个比自己大的元素，而不是大于等于！</p><ol><li>情况三：当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况</li></ol><p>此时如果入栈就不满足递增栈了，这也是找到右边第一个比自己大的元素的时候。</p><p>判断栈顶元素是否在nums1里出现过，（注意栈里的元素是nums2的元素），如果出现过，开始记录结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(nums1.size(), <span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-keyword">if</span> (nums1.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result;<br><br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; umap; <span class="hljs-comment">// key:下标元素，value：下标</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums1.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            umap[nums1[i]] = i;<br>        &#125;<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums2.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums2[i] &lt; nums2[st.<span class="hljs-built_in">top</span>()]) &#123;           <span class="hljs-comment">// 情况一</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums2[i] == nums2[st.<span class="hljs-built_in">top</span>()]) &#123;   <span class="hljs-comment">// 情况二</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">else</span> &#123;                                    <span class="hljs-comment">// 情况三</span><br>                <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; nums2[i] &gt; nums2[st.<span class="hljs-built_in">top</span>()]) &#123;<br>                    <span class="hljs-keyword">if</span> (umap.<span class="hljs-built_in">count</span>(nums2[st.<span class="hljs-built_in">top</span>()]) &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 看map里是否存在这个元素</span><br>                        <span class="hljs-type">int</span> index = umap[nums2[st.<span class="hljs-built_in">top</span>()]]; <span class="hljs-comment">// 根据map找到nums2[st.top()] 在 nums1中的下标。记录结果这块逻辑有一点小绕，要清楚，此时栈顶元素在nums2数组中右面第一个大的元素是nums2[i]（即当前遍历元素</span><br>                        result[index] = nums2[i];<br>                    &#125;<br>                    st.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="（3）下一个更大元素"><a href="#（3）下一个更大元素" class="headerlink" title="（3）下一个更大元素||"></a>（3）下一个更大元素||</h3><p>对比上一题，数组变成环形了，需要模拟走了两边数组来解题，（1 2  1 1 2 1）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElements</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(nums.size(), <span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>() * <span class="hljs-number">2</span>; i++) &#123; <br>            <span class="hljs-comment">// 模拟遍历两边nums，注意一下都是用i % nums.size()来操作 防止遍历越界</span><br>            <span class="hljs-keyword">if</span> (nums[i % nums.<span class="hljs-built_in">size</span>()] &lt; nums[st.<span class="hljs-built_in">top</span>()]) st.<span class="hljs-built_in">push</span>(i % nums.<span class="hljs-built_in">size</span>());<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i % nums.<span class="hljs-built_in">size</span>()] == nums[st.<span class="hljs-built_in">top</span>()]) st.<span class="hljs-built_in">push</span>(i % nums.<span class="hljs-built_in">size</span>()); <br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i % nums.<span class="hljs-built_in">size</span>()] &gt; nums[st.<span class="hljs-built_in">top</span>()]) &#123;<br>                    result[st.<span class="hljs-built_in">top</span>()] = nums[i % nums.<span class="hljs-built_in">size</span>()];<br>                    st.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>                st.<span class="hljs-built_in">push</span>(i % nums.<span class="hljs-built_in">size</span>());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="（4）接雨水"><a href="#（4）接雨水" class="headerlink" title="（4）接雨水"></a>（4）接雨水</h3><img src="C:\Users\zhangdengsheng\AppData\Roaming\Typora\typora-user-images\image-20240509151300969.png" style="zoom:50%;" /><p>处理逻辑同单调栈的从小到大顺序相同，在收获结果的时候，要注意计算方式。</p><p>当当前元素大于栈顶元素了，取栈顶元素，将栈顶元素弹出，这个就是凹槽的底部，也就是中间位置，下标记为mid，对应的高度为height[mid]。</p><p>此时的栈顶元素st.top()，就是凹槽的左边位置，下标为st.top()，对应的高度为height[st.top()]。</p><p>当前遍历的元素i，就是凹槽右边的位置，下标为i，对应的高度为height[i]。</p><p>此时大家应该可以发现其实就是<strong>栈顶和栈顶的下一个元素以及要入栈的元素，三个元素来接水！</strong></p><p>那么雨水高度是 min(凹槽左边高度, 凹槽右边高度) - 凹槽底部高度，代码为：<code>int h = min(height[st.top()], height[i]) - height[mid];</code></p><p>雨水的宽度是 凹槽右边的下标 - 凹槽左边的下标 - 1（因为只求中间宽度），代码为：<code>int w = i - st.top() - 1 ;</code></p><p>当前凹槽雨水的体积就是：<code>h * w</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (height.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 可以不加</span><br>        stack&lt;<span class="hljs-type">int</span>&gt; st; <span class="hljs-comment">// 存着下标，计算的时候用下标对应的柱子高度</span><br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; height.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (height[i] &lt; height[st.<span class="hljs-built_in">top</span>()]) &#123;     <span class="hljs-comment">// 情况一</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">if</span> (height[i] == height[st.<span class="hljs-built_in">top</span>()]) &#123;  <span class="hljs-comment">// 情况二</span><br>                st.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 其实这一句可以不加，效果是一样的，但处理相同的情况的思路却变了。</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">else</span> &#123;                                <span class="hljs-comment">// 情况三</span><br>                <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; height[i] &gt; height[st.<span class="hljs-built_in">top</span>()]) &#123; <span class="hljs-comment">// 注意这里是while</span><br>                    <span class="hljs-type">int</span> mid = st.<span class="hljs-built_in">top</span>();<br>                    st.<span class="hljs-built_in">pop</span>();<br>                    <span class="hljs-keyword">if</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>                        <span class="hljs-type">int</span> h = <span class="hljs-built_in">min</span>(height[st.<span class="hljs-built_in">top</span>()], height[i]) - height[mid];<br>                        <span class="hljs-type">int</span> w = i - st.<span class="hljs-built_in">top</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意减一，只求中间宽度</span><br>                        sum += h * w;<br>                    &#125;<br>                &#125;<br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="（5）矩形柱子的最大面积"><a href="#（5）矩形柱子的最大面积" class="headerlink" title="（5）矩形柱子的最大面积"></a>（5）矩形柱子的最大面积</h3><p>本题将单调栈的顺序变成了从大到小，处理逻辑也要取反。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; heights)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        heights.<span class="hljs-built_in">insert</span>(heights.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">0</span>); <span class="hljs-comment">// 数组头部加入元素0</span><br>        heights.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 数组尾部加入元素0</span><br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">// 第一个元素已经入栈，从下标1开始</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; heights.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (heights[i] &gt; heights[st.<span class="hljs-built_in">top</span>()]) &#123; <span class="hljs-comment">// 情况一</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (heights[i] == heights[st.<span class="hljs-built_in">top</span>()]) &#123; <span class="hljs-comment">// 情况二</span><br>                st.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 这个可以加，可以不加，效果一样，思路不同</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 情况三</span><br>                <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; heights[i] &lt; heights[st.<span class="hljs-built_in">top</span>()]) &#123; <span class="hljs-comment">// 注意是while</span><br>                    <span class="hljs-type">int</span> mid = st.<span class="hljs-built_in">top</span>();<br>                    st.<span class="hljs-built_in">pop</span>();<br>                    <span class="hljs-keyword">if</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>                        <span class="hljs-type">int</span> left = st.<span class="hljs-built_in">top</span>();<br>                        <span class="hljs-type">int</span> right = i;<br>                        <span class="hljs-type">int</span> w = right - left - <span class="hljs-number">1</span>;<br>                        <span class="hljs-type">int</span> h = heights[mid];<br>                        result = <span class="hljs-built_in">max</span>(result, w * h);<br>                    &#125;<br>                &#125;<br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>demo</title>
    <link href="/2024/05/08/demo/"/>
    <url>/2024/05/08/demo/</url>
    
    <content type="html"><![CDATA[<p>1、熟悉git的相关命令<br>操作类似于Linux相关指令，通过git init 将创建好的文件夹变成git可以管理的仓库（版本库）<br>git add readme.txt 添加文件到暂存区<br>git commit 将文件提交到仓库（-m可以添加备注）<br>git status 查看文件提交状态<br>git diff rademe.txt 查看文件修改了什么内容<br>git log 查看历史记录<br>git reset -hard HEAD^ 版本回退<br>git reflog 获取所有记录的版本号<br>git reset -hard 版本号，恢复指定版本<br>git restore– readme.txt 撤销未提交的工作（– 很重要！）<br>git push origin master 本地代码推送到github上<br>git checkout -b dev 创建并切换到该分支&#x3D;&#x3D;git branh dev + git<br>checkout dev<br>git branch 查看分支<br>git branch -d dev 删除分支dev<br>2、github远程仓库搭建<br>ssh加密同步方式</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>张登胜的博客</title>
    <link href="/2024/05/08/%E5%BC%A0%E7%99%BB%E8%83%9C%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <url>/2024/05/08/%E5%BC%A0%E7%99%BB%E8%83%9C%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>这是我的个人博客，欢迎大家访问！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/05/08/hello-world/"/>
    <url>/2024/05/08/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>基于跳表的KV存储引擎项目</title>
    <link href="/2024/05/27/%E5%9F%BA%E4%BA%8E%E8%B7%B3%E8%A1%A8%E7%9A%84KV%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E9%A1%B9%E7%9B%AE/"/>
    <url>/2024/05/27/%E5%9F%BA%E4%BA%8E%E8%B7%B3%E8%A1%A8%E7%9A%84KV%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="基于跳表实现的K-V存储引擎"><a href="#基于跳表实现的K-V存储引擎" class="headerlink" title="基于跳表实现的K-V存储引擎"></a>基于跳表实现的K-V存储引擎</h1><h2 id="1、项目简介"><a href="#1、项目简介" class="headerlink" title="1、项目简介"></a>1、项目简介</h2><p>本项目是使用 C++ 开发、基于<strong>跳表</strong>实现的轻量级键值数据库。实现了<strong>插入</strong>数据、<strong>删除</strong>数据、<strong>查询</strong>数据、<strong>数据展示</strong>、生成<strong>持久化文件</strong>、<strong>恢复数据</strong>以及<strong>数据库大小显示</strong>等功能。</p><h2 id="2、什么是跳表？"><a href="#2、什么是跳表？" class="headerlink" title="2、什么是跳表？"></a>2、什么是跳表？</h2><p>为了深入理解本项目中采用的数据结构 — 跳表，我们必须从其基础出发：链表。链表是许多复杂数据结构的基石，在这其中也包括了跳表。</p><blockquote><p>跳表（Skip List）是由 William Pugh 发明的一种数据结构，他本人对跳表的评价是：“跳跃列表是在很多应用中有可能替代平衡树而作为实现方法的一种数据结构。跳跃列表的算法有同平衡树一样的渐进的预期时间边界，并且更简单、更快速和使用更少的空间。”</p></blockquote><p>设想我们的存储引擎是以有序链表作为基础构建的。在这样的设置下，存储引擎中的数据结构呈现如下特点：</p><p><img src="https://kstar-1253855093.cos.ap-nanjing.myqcloud.com/baguwen1.0/202403011042732.png" alt="img"></p><p>其中每个节点都存储着一对键值对。为了便于理解，假设其中键是数字，值是字符串，并且它们按键的顺序排列。</p><p>这便构成了一个基于<strong>有序链表</strong>的简易键值（K-V）存储引擎。</p><p>设想现在我们需要在存储引擎中查找特定键（比如 key &#x3D; 6）对应的值。由于单链表的线性结构，我们不得不从头节点开始，逐个遍历节点。</p><p>例如，在查找 key &#x3D; 6 的过程中，我们需要按顺序检查每个节点，即查找路径为 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6。这种方法的时间复杂度为 O(n)，在数据量庞大时效率低下。</p><p>因此，需要一种更高效的查找方法，而跳表正是这样的一种解决方案。</p><blockquote><p>首先需要明确，我们所有的优化操作都基于<strong>链表是有序</strong>的这一前提。</p></blockquote><p>那么，问题来了：我们该如何提升原有链表的查找速度呢？</p><p>如下图所示：</p><p><img src="https://kstar-1253855093.cos.ap-nanjing.myqcloud.com/baguwen1.0/202403011046845.png" alt="img"></p><p>为了提高查找效率，我们采取了一种独特的策略：<strong>从原链表中选取关键节点作为索引层。这些被选出的节点形成了一个新的，较原链表更为简短的链表</strong>。由于原链表本身是有序的，索引层中的节点也同样保持有序，利用这个有序性，我们能够加快查找速度。</p><p>以查找 key &#x3D; 6 的节点为例。在传统的单链表中，我们需要从头至尾逐个检查节点。例如，我们首先比较 key &#x3D; 1 的节点，发现它小于 6，然后继续比较 key &#x3D; 2 的节点，如此循环。</p><p>但在跳表中，情况就大不相同了。我们首先检查第一层索引，比较 key &#x3D; 1 的节点后，可以直接跳到 key &#x3D; 3 的节点，因为 6 大于 3，我们再跳到 key &#x3D; 5 的节点。在这个过程中，我们省略了与 key &#x3D; 2 和 key &#x3D; 4 的节点的比较，但实际上，通过与 key &#x3D; 3 和 key &#x3D; 5 的比较，我们已经间接地排除了它们。</p><p>如此一来，查找路径缩短为 1 -&gt; 3 -&gt; 5 -&gt; 6。与原始的单链表相比，效率有所提升。</p><p>那么，如果我们在第一层索引上再构建一层索引会怎样呢？</p><p><img src="https://kstar-1253855093.cos.ap-nanjing.myqcloud.com/baguwen1.0/202403011050633.png" alt="img"></p><p>当我们从第二层索引开始进行查找时，查找会变得更加高效。在比较了 key &#x3D; 1 的节点 和 key &#x3D; 6 的节点后，我们不再逐个检查 key &#x3D; 2、key &#x3D; 3 和 key &#x3D; 4 的节点，而是直接跳到 key &#x3D; 5 节点进行比较。如此一来，整个查找路径便缩短为 1 -&gt; 5 -&gt; 6。</p><p>在节点数量众多且索引层级充足的情况下，这种查找方法的效率极高。例如，如果在每层索引中，每两个节点就有一个被提升为上一层的索引，那么查找的时间复杂度可以降至 O(log n)，这与二分查找的效率相仿。</p><blockquote><p>这样的机制不仅显著提升了查找效率，还在保持链表灵活性的同时，为我们的存储引擎带来了接近二分查找的高效性能。</p></blockquote><h1 id="跳表的定义"><a href="#跳表的定义" class="headerlink" title="跳表的定义"></a>跳表的定义</h1><p>本节将深入探讨 K-V 存储引擎实现的关键组成部分：Node 类与 SkipList 类。<strong>Node 类的核心在于其属性</strong>，<strong>特别是其 forward 属性</strong>。可以说理解了 forward 属性，就理解了整个 K-V 存储引擎底层使用数据结构 —— 跳表。</p><p><strong>而 SkipList 类的重点在于其提供的一系列公共成员函数</strong>，这些函数负责组织和管理 Node 类的实例。后续的章节将围绕这些函数进行展开，详细介绍它们的实现和应用。</p><h2 id="1-Node-类"><a href="#1-Node-类" class="headerlink" title="1. Node 类"></a>1. Node 类</h2><h3 id="1-1-Node-类中的关键属性"><a href="#1-1-Node-类中的关键属性" class="headerlink" title="1.1 Node 类中的关键属性"></a>1.1 Node 类中的关键属性</h3><p>在开发一个基于跳表的 K-V 存储引擎、设计用于实际存储数据的 Node 类（节点）时，我们需要考虑以下三个因素。</p><blockquote><p>为了明确语义以及方便叙述，后文中所有的名词「节点」都是代指 Node 类，更具体的来说是指 Node 类的实例。</p></blockquote><ol><li><strong>键值存储机制</strong>：如何存储键和对应的值</li><li><strong>跳转机制实现</strong>：跳表的搜索操作核心在于节点间的跳转，这如何实现</li><li><strong>层级确定</strong>：如何确定节点存在于跳表中的哪些层级</li></ol><p>针对上述第一点和第三点考虑因素，Node 类需要包含两个主要私有属性：key 和 value，分别用于存储键和值。此外，Node 类还有一个 node_level 公共属性，用于标识节点在跳表中的层级位置。</p><ul><li>当 node_level &#x3D; 1 时，表示当前的节点只会出现在跳表中的第 1 层</li><li>当 node_level &#x3D; 2 时，表示当前的节点会出现在跳表中的第 2 层和第 1 层</li><li>以此类推</li></ul><p>此时，Node 类的结构如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> node_level;<br><span class="hljs-keyword">private</span>:<br>    K key;<br>    V value;<br>&#125;<br></code></pre></td></tr></table></figure><p>在介绍了 Node 类中负责键值存储和标识节点层次的属性之后，下文将会介绍用于支持节点间跳转机制的属性。</p><blockquote><p>所谓跳转，指的是通过定义一种特定的指针机制，使得该指针能够以一定规则指向跳表中的各个节点。以单链表为例，其 next 指针便是一种实现节点间顺序跳转功能的关键属性。</p></blockquote><p>在 “跳表简介” 章节中模拟跳表搜索部份，我们知道节点间的跳转机制可以分为两大类：</p><ol><li><strong>同一节点的多层跳转：在相同键值、不同层级节点之间的跳转</strong></li><li><strong>不同节点的单层跳转：在相同层级、不同键值节点之间的跳转</strong></li></ol><p>通过这两类跳转机制的结合，我们可以在跳表中灵活地实现不同层级和不同节点之间的跳转。</p><blockquote><p>就像通过 x 坐标和 y 坐标结合，可以表示坐标轴内上的任意一个点一样。</p></blockquote><p>那么，能够支持这两种节点间的跳转机制的属性长什么样子呢？</p><p>让我们先聚焦于第二种跳转机制：不同节点的单层跳转。<strong>这实际上与单链表的结构相似。</strong></p><p>在单链表中，每个节点由两部分组成：数据域和指针域。数据域负责存储当前节点的值，而指针域则指向下一个节点，将各个单独的节点链接起来。</p><p>链表结构的实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 单链表结构简单示例</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkList</span> &#123;<br>  <span class="hljs-type">int</span> data;<br>  LinkList* next;<br>&#125;<br></code></pre></td></tr></table></figure><p>在单链表的结构中，可以通过访问当前节点的 next 指针，来实现从当前节点到下一个节点之间跳转的功能。这个 next 指针指向链表中的后续节点，从而使我们能够从当前节点顺利跳转到紧随其后的节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 单链表实现节点跳转的简单实现</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">travasal</span><span class="hljs-params">(LinkList* listHeader)</span> </span>&#123;<br>    LinkList* current = listHeader;<br>    <span class="hljs-keyword">while</span> (current-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;<br>        current = current-&gt;next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以，我们可以借鉴单链表中访问 next 指针的成员函数，来实现跳表内同一层级上不同节点间的跳转功能。也就是说，<strong>节点内部用于支持跳转功能的属性，实质上是一种指针</strong>。这个指针将会指向当前节点同一层中的后一个节点。</p><p>现在还需要解决节点跳转的第一个问题，就是节点内的该属性如何支持节点在其不同层级间的跳转呢？</p><p>到目前为止，我们可以通过 node_level 属性确定一个节点会在跳表的哪些层级出现。基于这一点，我们可以采用数组结构来组织一个节点在不同层级的指针。这意味着，用于支持两种跳转功能的属性，实际上是一个指针数组，数组其中的每个指针对应节点在一个特定层级的后继节点。<strong>通过变更数组下标，我们便能够实现同一节点在不同层级之间的跳转功能</strong>。这样的设计不仅保持了结构的简洁性，也为跳表提供了必要的灵活性和效率。</p><p>为了保持一致性和易于理解，我们将这个指针数组命名为 forward，这个命名方式与大多数跳表实现中的惯例相同。</p><p>最终的节点定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    Node&lt;K, V&gt;** forward; <span class="hljs-comment">// 在 C++ 中，二维指针等价于指针数组 </span><br>    <span class="hljs-type">int</span> node_level;<br><span class="hljs-keyword">private</span>:<br>    K key;<br>    V value;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>假设一个节点在跳表中的层级为 3，那么这个节点的 forward 指针数组的大小为 3。其 forward[0] 指向该节点在第一层的下一个节点；forward[1] 指向该节点在第二层的下一个节点，forward[2] 指向该节点在第三层的下一个节点。</p></blockquote><h3 id="1-2-Node-类的代码实现"><a href="#1-2-Node-类的代码实现" class="headerlink" title="1.2 Node 类的代码实现"></a>1.2 Node 类的代码实现</h3><p>在定义完毕 Node 类关键的属性之后，还需要一些基本的问题需要处理。例如获取 &#x2F; 设置key 对应的 value、构造函数的实现、析构函数的实现等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-comment">// 定义节点</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K,<span class="hljs-keyword">typename</span> V&gt; <span class="hljs-comment">// 函数模版</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Node</span>()&#123;&#125;;<span class="hljs-comment">//默认构造函数</span><br>    <span class="hljs-built_in">Node</span>(K k,V v,<span class="hljs-type">int</span>);<span class="hljs-comment">// 构造函数</span><br>    ~<span class="hljs-built_in">Node</span>();<span class="hljs-comment">// 析构函数</span><br>    <span class="hljs-function">K <span class="hljs-title">get_key</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<span class="hljs-comment">// 获取键</span><br>    <span class="hljs-function">V <span class="hljs-title">get_value</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<span class="hljs-comment">// 获取键值</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_value</span><span class="hljs-params">(V)</span></span>;<span class="hljs-comment">//设置key对应的value</span><br>    Node&lt;K,V&gt; **forward;<span class="hljs-comment">// 在C++中，二维指针等价于指针数组。要明确forward数组的含义</span><br>    <span class="hljs-type">int</span> node_level;<span class="hljs-comment">//用来标识当前节点在跳表中的层级位置</span><br><span class="hljs-keyword">private</span>:<br>    K key; <span class="hljs-comment">//存储键</span><br>    V value; <span class="hljs-comment">// 存储键值</span><br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K,<span class="hljs-keyword">typename</span> V&gt;<br>Node&lt;K,V&gt;::<span class="hljs-built_in">Node</span>(<span class="hljs-type">const</span> K k,<span class="hljs-type">const</span> V v,<span class="hljs-type">int</span> level)&#123;<br>    <span class="hljs-keyword">this</span>-&gt;key = k;<br>    <span class="hljs-keyword">this</span>-&gt;value =v;<br>    <span class="hljs-keyword">this</span>-&gt;node_level =level;<br>    <span class="hljs-keyword">this</span>-&gt;forward = <span class="hljs-keyword">new</span> Node&lt;K,V&gt; *[level+<span class="hljs-number">1</span>];<span class="hljs-comment">// 定义当前节点的forward数组的大小，下标从0开始，所以动态分配的大小为level+1</span><br>    <span class="hljs-built_in">memset</span>(<span class="hljs-keyword">this</span>-&gt;forward,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(Node&lt;K,V&gt;*) *(level+<span class="hljs-number">1</span>));<span class="hljs-comment">// 这行代码啥意思：将分配的指针数组初始化为零</span><br><span class="hljs-comment">//memset 是一个标准库函数，定义在 &lt;cstring&gt; 头文件中，用于将某一块内存中的所有字节都设置为指定的值 </span><br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K,<span class="hljs-keyword">typename</span> V&gt;<br>Node&lt;K,V&gt;::~<span class="hljs-built_in">Node</span>()&#123;<span class="hljs-comment">//析构函数实现</span><br>    <span class="hljs-keyword">delete</span>[] forward;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K,<span class="hljs-keyword">typename</span> V&gt;<br>K Node&lt;K,V&gt;::<span class="hljs-built_in">get_key</span>() <span class="hljs-type">const</span>&#123;<span class="hljs-comment">// 获取键函数实现</span><br>    <span class="hljs-keyword">return</span> key;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K,<span class="hljs-keyword">typename</span> V&gt;<br>V Node&lt;K,V&gt;::<span class="hljs-built_in">get_value</span>() <span class="hljs-type">const</span>&#123;<span class="hljs-comment">// 获取键值函数实现</span><br>    <span class="hljs-keyword">return</span> value;<br>&#125;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-type">void</span> Node&lt;K, V&gt;::<span class="hljs-built_in">set_value</span>(V value) &#123;<span class="hljs-comment">// 这里不用加const！编译没通过</span><br>    <span class="hljs-keyword">this</span>-&gt;value = value;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> K,V,L;<span class="hljs-comment">//定义变量</span><br>    std::cin &gt;&gt; K&gt;&gt;V&gt;&gt;L;<span class="hljs-comment">//获取变量</span><br>    <span class="hljs-comment">//创造对应的类</span><br>    Node&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; *node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(K,V,L);<br>    <span class="hljs-comment">//调用get_key和get_value函数</span><br>    std::cout &lt;&lt; node-&gt;<span class="hljs-built_in">get_key</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>&lt;&lt; node-&gt;<span class="hljs-built_in">get_value</span>()&lt;&lt; std::endl;<br>    <span class="hljs-comment">// 释放内存</span><br>    <span class="hljs-keyword">delete</span> node;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-SkipList-类"><a href="#2-SkipList-类" class="headerlink" title="2. SkipList 类"></a>2. SkipList 类</h2><p>在确定了具体用于存储键值对的 Node 类之后，现在我们需要设计一个能组织和管理存储引擎 Node 类的 SkipList 类。</p><h3 id="2-1-SkipList-属性"><a href="#2-1-SkipList-属性" class="headerlink" title="2.1 SkipList 属性"></a>2.1 SkipList 属性</h3><ol><li>头节点：作为跳表中所有节点组织的入口点，类似于单链表</li><li>最大层数：跳表中允许的最大层数</li><li>当前层数：跳表当前的层数</li><li>节点数量：跳表当前的组织的所有节点总数</li><li>文件读写：跳表生成持久化文件和读取持久化文件的写入器和读取器</li></ol><p>具体定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SkipList</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> _max_level;              <span class="hljs-comment">// 跳表允许的最大层数</span><br>    <span class="hljs-type">int</span> _skip_list_level;        <span class="hljs-comment">// 跳表当前的层数</span><br>    Node&lt;K, V&gt; *_header;         <span class="hljs-comment">// 跳表的头节点</span><br>    <span class="hljs-type">int</span> _element_count;          <span class="hljs-comment">// 跳表中组织的所有节点的数量</span><br>    std::ofstream _file_writer;  <span class="hljs-comment">// 文件写入器</span><br>    std::ifstream _file_reader;  <span class="hljs-comment">// 文件读取器</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-2-SkipList-成员函数"><a href="#2-2-SkipList-成员函数" class="headerlink" title="2.2 SkipList 成员函数"></a>2.2 SkipList 成员函数</h3><p>在定义完毕 SkipList 类的关键属性后，我们还需要设计出组织和管理 Node 类的成员函数。</p><p>核心成员函数：</p><ol><li>节点创建：生成新的节点实例</li><li>层级分配：为每个新创建的节点分配一个合适的层数</li><li>节点插入：将节点加入到跳表中的适当位置</li><li>节点搜索：在跳表中查找特定的节点</li><li>节点删除：从跳表中移除指定的节点</li><li>节点展示：显示跳表中所有节点的信息</li><li>节点计数：获取跳表中当前的节点总数</li><li>数据持久化：将跳表的数据保存到磁盘中</li><li>数据加载：从磁盘加载持久化的数据到跳表中</li><li>垃圾回收：对于删除的节点，需要回收其内存空间</li><li>获取节点数量：获取跳表组织的节点个数</li></ol><p>接口的具体代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SkipList</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SkipList</span>(<span class="hljs-type">int</span>);                      <span class="hljs-comment">// 构造函数</span><br>    ~<span class="hljs-built_in">SkipList</span>();                        <span class="hljs-comment">// 析构函数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_random_level</span><span class="hljs-params">()</span></span>;             <span class="hljs-comment">// 获取节点的随机层级</span><br>    <span class="hljs-function">Node&lt;K, V&gt; *<span class="hljs-title">create_node</span><span class="hljs-params">(K, V, <span class="hljs-type">int</span>)</span></span>; <span class="hljs-comment">// 节点创建</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">insert_element</span><span class="hljs-params">(K, V)</span></span>;           <span class="hljs-comment">// 插入节点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display_list</span><span class="hljs-params">()</span></span>;                <span class="hljs-comment">// 展示节点</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">search_element</span><span class="hljs-params">(K)</span></span>;             <span class="hljs-comment">// 搜索节点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">delete_element</span><span class="hljs-params">(K)</span></span>;             <span class="hljs-comment">// 删除节点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dump_file</span><span class="hljs-params">()</span></span>;                   <span class="hljs-comment">// 持久化数据到文件</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">load_file</span><span class="hljs-params">()</span></span>;                   <span class="hljs-comment">// 从文件加载数据</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(Node&lt;K, V&gt; *)</span></span>;           <span class="hljs-comment">// 递归删除节点</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>;                         <span class="hljs-comment">// 跳表中的节点个数</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>在定义完毕 SkipList 类中的属性和成员函数之后，<strong>后续的章节内容就是实现上述的各个函数</strong>。</p><h1 id="跳表的层级"><a href="#跳表的层级" class="headerlink" title="跳表的层级"></a>跳表的层级</h1><p>通过之前的简介，我们已经了解到跳表是一种极为高效的数据结构，其独特之处在于节点层级的设定，这一层级是通过一个随机过程来选择的。为了实现这一过程，我们设计了一个专门的成员函数，通过该函数，可以在跳表中实现随机层级的选择。</p><h2 id="1-随机层级的选择过程"><a href="#1-随机层级的选择过程" class="headerlink" title="1. 随机层级的选择过程"></a>1. 随机层级的选择过程</h2><p>想象你在玩抛硬币游戏，决定你在游戏中可以前进多远：</p><ol><li>起点：每当添加一个新元素，从地面层（即跳表的最底层，第0层）开始</li><li>抛硬币决定层级：<ul><li>正面：向上升一层并继续抛硬币</li><li>反面：停止升层，确定当前层级作为元素的最终层级</li></ul></li><li><strong>重复过程</strong>：持续此过程直至得到反面为止</li></ol><p>这个随机过程的结果是：</p><p>许多元素会停留在较低层级，一部分元素会到达较高层级，极少数元素可能会到达非常高的层级。</p><h2 id="2-为什么采用随机过程"><a href="#2-为什么采用随机过程" class="headerlink" title="2. 为什么采用随机过程"></a>2. 为什么采用随机过程</h2><ul><li>平衡性：随机层级分配自然保持跳表平衡，无需额外操作（如AVL或红黑树的旋转）</li><li>效率：随机分配层级保证节点在各层均匀分布，实现对数时间复杂度的查找、插入和删除</li><li>简单性：这种方法易于实现且效果显著，使跳表成为性能优异的简洁数据结构</li></ul><p>来看具体代码的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-type">int</span> SkipList&lt;K, V&gt;::<span class="hljs-built_in">get_random_level</span>() &#123;<br>   <span class="hljs-comment">// 初始化层级：每个节点至少出现在第一层。</span><br>   <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<br>   <span class="hljs-comment">// 随机层级增加：使用 rand() % 2 实现抛硬币效果，决定是否升层。</span><br>   <span class="hljs-keyword">while</span> (<span class="hljs-built_in">rand</span>() % <span class="hljs-number">2</span>) &#123;<br>      k++;<br>   &#125;<br>   <span class="hljs-comment">// 层级限制：确保节点层级不超过最大值 _max_level。</span><br>   k = (k &lt; _max_level) ? k : _max_level;<br>   <span class="hljs-comment">// 返回层级：返回确定的层级值，决定节点插入的层。</span><br>   <span class="hljs-keyword">return</span> k;<br>&#125;;<br></code></pre></td></tr></table></figure><p>随机过程的实现方式中有这样一行代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">k = (k &lt; _max_level) ? k : _max_level;<br></code></pre></td></tr></table></figure><p>这是因为在具体的实现中，我们的跳表有一个最大层级限制，限制了索引的最高层，所以这里额外添加一行代码对随机生成的层级进行限制。</p><p>这个函数通过简单的随机过程（模拟抛硬币），以概率方式决定节点的层级，同时确保层级不会超过设定的最大值。<strong>这种随机层级分配策略有助于保持跳表的性能，确保操作（如搜索、插入、删除）的时间复杂度在平均情况下接近 O(log n)。</strong></p><h1 id="跳表的插入、搜索"><a href="#跳表的插入、搜索" class="headerlink" title="跳表的插入、搜索"></a>跳表的插入、搜索</h1><p>本文将正式介绍跳表的创建和搜索、插入操作几个核心部分：</p><p><strong>1、创建跳表</strong></p><p>我们将从基础开始，介绍如何创建跳表的方法。</p><p><strong>2、实现搜索方法</strong></p><p>详细介绍跳表中如何实现搜索操作。</p><p><strong>3、实现插入方法</strong></p><p>解析跳表中插入新节点的过程，包括如何通过随机过程函数，比如 get_random_level()，决定新插入节点的层级，以及如何搜索到合适的位置进行节点插入，包括在插入节点时的具体操作，如何替换前置和后置节点。</p><h2 id="1-创建跳表"><a href="#1-创建跳表" class="headerlink" title="1. 创建跳表"></a>1. 创建跳表</h2><p>下面是跳表的基础代码框架，仅仅包括本节内容中必要的类定义和成员函数，其余内容为了保证篇幅长度均已省略：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-comment">// 节点类定义</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-comment">// 节点类成员变量和方法（省略）</span><br>&#125;;<br><br><span class="hljs-comment">// 跳表类定义</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SkipList</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SkipList</span>(<span class="hljs-type">int</span>);  <span class="hljs-comment">// 构造函数</span><br>    ~<span class="hljs-built_in">SkipList</span>();  <span class="hljs-comment">// 析构函数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_random_level</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 生成随机层级</span><br>    <span class="hljs-function">Node&lt;K, V&gt; *<span class="hljs-title">create_node</span><span class="hljs-params">(K, V, <span class="hljs-type">int</span>)</span></span>;  <span class="hljs-comment">// 创建新节点</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">insert_element</span><span class="hljs-params">(K, V)</span></span>;  <span class="hljs-comment">// 插入元素</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">search_element</span><span class="hljs-params">(K)</span></span>;  <span class="hljs-comment">// 搜索元素</span><br>    <span class="hljs-comment">// 其他成员变量和函数（省略）</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> _max_level;  <span class="hljs-comment">// 最大层级</span><br>    <span class="hljs-type">int</span> _skip_list_level;  <span class="hljs-comment">// 当前层级</span><br>    Node&lt;K, V&gt; *_header;  <span class="hljs-comment">// 头节点</span><br>    <span class="hljs-comment">// 其他私有成员（省略）</span><br>    <span class="hljs-type">int</span> _element_count;  <span class="hljs-comment">// 节点数量</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>跳表的构造函数负责初始化跳表，主要包括以下步骤：</p><ol><li>设置最大层级：根据预设值确定跳表的最大层级</li><li>初始化成员变量：设置跳表当前层级为 0，节点计数为 0</li><li><strong>创建头节点：初始化一个头节点，其层级等于跳表的最大层级</strong></li></ol><p>具体代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br>SkipList&lt;K, V&gt;::<span class="hljs-built_in">SkipList</span>(<span class="hljs-type">int</span> max_level) &#123;<br>    <span class="hljs-keyword">this</span>-&gt;_max_level = max_level;  <span class="hljs-comment">// 设置最大层级</span><br>    <span class="hljs-keyword">this</span>-&gt;_skip_list_level = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 初始化当前层级为 0</span><br>    <span class="hljs-keyword">this</span>-&gt;_element_count = <span class="hljs-number">0</span>;      <span class="hljs-comment">// 初始化节点计数为 0</span><br>    K k;  <span class="hljs-comment">// 默认键</span><br>    V v;  <span class="hljs-comment">// 默认值</span><br>    <span class="hljs-comment">// 创建头节点，并初始化键值为默认值</span><br>    <span class="hljs-keyword">this</span>-&gt;_header = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>&lt;K, V&gt;(k, v, _max_level);<br>    <span class="hljs-comment">// 将头结点的层级设为跳表的最大层级，是为了搜索时从顶层往下搜索。</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>完成跳表的初始化之后，接下来的环节是实现节点创建的方法。</p><p>创建新节点的过程涉及以下主要步骤：</p><ol><li>节点实例化：依据提供的键（k）和值（v），创建一个新的节点实例。同时，为这个新节点指定一个层级（level），这一层级决定了节点在跳表中的高度</li><li>返回新节点：完成节点的创建后，返回这个新创建的节点实例，以便于进一步在跳表中进行插入操作。</li></ol><p>具体代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建一个新节点</span><br><span class="hljs-comment"> * @param k 节点的键</span><br><span class="hljs-comment"> * @param v 节点的值</span><br><span class="hljs-comment"> * @param level 节点的层级</span><br><span class="hljs-comment"> * @return 新创建的节点指针</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br>Node&lt;K, V&gt; *SkipList&lt;K, V&gt;::<span class="hljs-built_in">create_node</span>(<span class="hljs-type">const</span> K k, <span class="hljs-type">const</span> V v, <span class="hljs-type">int</span> level) &#123;<br>    <span class="hljs-comment">// 实例化新节点，并为其分配指定的键、值和层级</span><br>    Node&lt;K, V&gt; *n = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>&lt;K, V&gt;(k, v, level);<br>    <span class="hljs-keyword">return</span> n; <span class="hljs-comment">// 返回新创建的节点</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-实现搜索方法"><a href="#2-实现搜索方法" class="headerlink" title="2. 实现搜索方法"></a>2. 实现搜索方法</h2><h3 id="2-1-理论基础"><a href="#2-1-理论基础" class="headerlink" title="2.1 理论基础"></a>2.1 理论基础</h3><p>完成跳表的创建之后，让我们先了解跳表的搜索方法，因为后续的插入方法和删除方法都依赖于搜索方法。</p><p>我们之前已经简要介绍过跳表的搜索机制。搜索开始于跳表的顶层，这一点在我们的 SkipList 类中通过变量 _skip_list_level 得到体现，该变量记录了跳表当前的最高层级。</p><p>并且在 “跳表的定义” 章节中，我们曾经介绍过，每个节点都维护一个 forward 数组，该数组记录了<strong>该节点在每一层的下一个节点的指针</strong>。</p><blockquote><p>_header 作为跳表的头节点，为操作跳表提供了一个统一的入口。跳表的本质是由原始链表经过筛选部分节点构建成的多级索引链表。因此，跳表可视为多个层级的单链表组合而成。在单链表结构中，通常会有一个头节点，其 next 指针指向链表的第一个实际节点。相应地，对于多层级的跳表结构，我们需要多个头节点来指向各层的第一个节点。这些头节点被存储在 _header 节点的 forward 数组中。例如，_header-&gt;forward[0] 指向最底层的第一个节点，_header-&gt;forward[1] 指向第二层的第一个节点，依此类推。</p></blockquote><p>基于这个结构，利用 _header 节点和 _skip_list_level（记录跳表实际最高层级的变量）作为起点，我们可以从跳表的最顶层开始进行搜索。</p><h3 id="2-2-代码实现"><a href="#2-2-代码实现" class="headerlink" title="2.2 代码实现"></a>2.2 代码实现</h3><p>以下是拥有详细注释的搜索方法代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 搜索指定的键值是否存在于跳表中。</span><br><span class="hljs-comment"> * @param key 待查找的键值</span><br><span class="hljs-comment"> * @return 如果找到键值，返回 true；否则返回 false。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-type">bool</span> SkipList&lt;K, V&gt;::<span class="hljs-built_in">search_element</span>(K key) &#123;<br>    <span class="hljs-comment">// 定义一个指针 current，初始化为跳表的头节点 _header</span><br>    Node&lt;K, V&gt; *current = _header;<br>    <span class="hljs-comment">// 从跳表的最高层开始搜索</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = _skip_list_level; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// 遍历当前层级，直到下一个节点的键值大于或等于待查找的键值</span><br>        <span class="hljs-keyword">while</span> (current-&gt;forward[i] &amp;&amp; current-&gt;forward[i]-&gt;<span class="hljs-built_in">get_key</span>() &lt; key) &#123;<br>            <span class="hljs-comment">// 移动到当前层的下一个节点</span><br>            current = current-&gt;forward[i];<br>        &#125;<br>        <span class="hljs-comment">// 当前节点的下一个节点的键值大于待查找的键值时，进行下沉到下一层</span><br>        <span class="hljs-comment">// 下沉操作通过循环的 i-- 实现</span><br>    &#125;<br>    <span class="hljs-comment">// 检查当前层（最底层）的下一个节点的键值是否为待查找的键值</span><br>    current = current-&gt;forward[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">if</span> (current &amp;&amp; current-&gt;<span class="hljs-built_in">get_key</span>() == key) &#123;<br>        <span class="hljs-comment">// 如果找到匹配的键值，返回 true</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果没有找到匹配的键值，返回 false</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-实现插入方法"><a href="#3-实现插入方法" class="headerlink" title="3. 实现插入方法"></a>3. 实现插入方法</h2><h3 id="3-1-理论基础"><a href="#3-1-理论基础" class="headerlink" title="3.1 理论基础"></a>3.1 理论基础</h3><p>继搜索节点的逻辑之后，我们现在转向如何在跳表中插入新节点。</p><p>插入过程主要涉及三个关键步骤：</p><p><strong>1、确定节点层级</strong></p><p>首先，我们需要为新插入的节点随机确定其所在的层级</p><p><strong>2、寻找插入位置</strong></p><p>通过之前讨论的搜索方法，我们能够定位到了新节点应当插入的具体位置</p><p><strong>3、更新指针关系</strong></p><p>最关键的步骤是在插入节点时更新各层的指针关系。</p><p>具体而言，这包括两个方面：</p><ol><li>将新节点在各层的前驱节点（即在该层中小于新节点且最接近新节点的节点）的 forward 指针指向新节点。</li><li>同时，新节点的 forward 指针需要指向其在各层的前驱节点原本指向的节点。</li></ol><p>此操作和单链表的插入操作类似，区别在于跳表需要在多层中的重复进行此操作，而链表只需要进行一次。</p><h3 id="3-2-代码实现"><a href="#3-2-代码实现" class="headerlink" title="3.2 代码实现"></a>3.2 代码实现</h3><p>在插入新节点前，我们首先需要定位插入位置，此过程与 search_element 函数的逻辑相似。下面的代码框架展示了如何执行这一操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在跳表中插入一个新元素。</span><br><span class="hljs-comment"> * @param key 待插入节点的 key</span><br><span class="hljs-comment"> * @param value 待插入节点的 value</span><br><span class="hljs-comment"> * @return 如果元素已存在，返回 1；否则，进行更新 value 操作并返回 0。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-type">int</span> SkipList&lt;K, V&gt;::<span class="hljs-built_in">insert_element</span>(<span class="hljs-type">const</span> K key, <span class="hljs-type">const</span> V value) &#123;<br>    Node&lt;K, V&gt; *current = <span class="hljs-keyword">this</span>-&gt;_header;<br>    <span class="hljs-comment">// 用于在各层更新指针的数组</span><br>    Node&lt;K, V&gt; *update[_max_level + <span class="hljs-number">1</span>];  <span class="hljs-comment">// 用于记录每层中待更新指针的节点</span><br>    <span class="hljs-built_in">memset</span>(update, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(Node&lt;K, V&gt; *) * (_max_level + <span class="hljs-number">1</span>));<span class="hljs-comment">// 初始化为0</span><br><br>    <span class="hljs-comment">// 从最高层向下搜索插入位置</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = _skip_list_level; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// 寻找当前层中最接近且小于 key 的节点</span><br>        <span class="hljs-keyword">while</span> (current-&gt;forward[i] != <span class="hljs-literal">NULL</span> &amp;&amp; current-&gt;forward[i]-&gt;<span class="hljs-built_in">get_key</span>() &lt; key) &#123;<br>            current = current-&gt;forward[i]; <span class="hljs-comment">// 移动到下一节点</span><br>        &#125;<br>        <span class="hljs-comment">// 保存每层中该节点，以便后续插入时更新指针</span><br>        update[i] = current;<br>    &#125;<br><br>    <span class="hljs-comment">// 移动到最底层的下一节点，准备插入操作</span><br>    current = current-&gt;forward[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">// 检查待插入的节点的键是否已存在</span><br>    <span class="hljs-keyword">if</span> (current != <span class="hljs-literal">NULL</span> &amp;&amp; current-&gt;<span class="hljs-built_in">get_key</span>() == key) &#123;<br>        <span class="hljs-comment">// 键已存在，取消插入</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 后续插入操作（略）</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这段代码中，<code>Node&lt;K, V&gt;* update[_max_level + 1]</code> 是用于实现插入节点的关键数据结构，它是一个节点指针数组，<strong>用于记录在上文中提到的，待插入节点的前驱节点（即在该层中小于新节点且最接近新节点的节点</strong>）。这个数组解决了之前提到的关键问题：<strong>在插入新节点时如何更新每层的指针关系。</strong></p><p><strong>通过内层的 while 循环，一旦发现 current-&gt;forward[i] 指向的节点的 key 值 &gt; 待插入节点的 key，那么 current 就是待插入节点的前驱节点。而通过外层的 for 循环，我们可以寻找出待插入节点在不同层的所有前驱节点。</strong></p><p>接下来的判断逻辑是为了确保不会插入重复的节点。如果 current 指向的节点的 key 与待插入的节点的 key 相等，说明跳表中已存在与待插入节点相同 key 的节点，此时我们只需要将该节点的 value 更新，并且返回 1；</p><p>继续深入跳表的插入逻辑，以下是插入操作的代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在跳表中插入一个新元素。</span><br><span class="hljs-comment"> * @param key 新元素的键。</span><br><span class="hljs-comment"> * @param value 新元素的值。</span><br><span class="hljs-comment"> * @return 如果元素已存在，返回 1；否则，进行插入操作并返回 0。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-type">int</span> SkipList&lt;K, V&gt;::<span class="hljs-built_in">insert_element</span>(<span class="hljs-type">const</span> K key, <span class="hljs-type">const</span> V value) &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 检查待插入的节点是否已存在于跳表中</span><br>    <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">NULL</span> || current-&gt;<span class="hljs-built_in">get_key</span>() != key) &#123;<br>        <span class="hljs-comment">// 通过随机函数决定新节点的层级高度</span><br>        <span class="hljs-type">int</span> random_level = <span class="hljs-built_in">get_random_level</span>();<br>        <span class="hljs-comment">// 如果新节点的层级超出了跳表的当前最高层级</span><br>        <span class="hljs-keyword">if</span> (random_level &gt; _skip_list_level) &#123;<br>            <span class="hljs-comment">// 对所有新的更高层级，将头节点设置为它们的前驱节点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = _skip_list_level + <span class="hljs-number">1</span>; i &lt;= random_level; i++) &#123;<br>                update[i] = _header;<br>            &#125;<br>            <span class="hljs-comment">// 更新跳表的当前最高层级为新节点的层级</span><br>            _skip_list_level = random_level;<br>        &#125;<br>        <br>        Node&lt;K, V&gt; *inserted_node = <span class="hljs-built_in">create_node</span>(key, value, random_level);<br>        <span class="hljs-comment">// 在各层插入新节点，同时更新前驱节点的forward指针</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= random_level; i++) &#123;<br>            <span class="hljs-comment">// 新节点指向当前节点的下一个节点</span><br>            inserted_node-&gt;forward[i] = update[i]-&gt;forward[i];<br>            <span class="hljs-comment">// 当前节点的下一个节点更新为新节点</span><br>            update[i]-&gt;forward[i] = inserted_node;<br>        &#125;<br>        _element_count++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当新插入节点的层级高于跳表当前层级时，我们需要在 update 数组中为这些新层级指定头节点（_header），因为这些层级在插入之前是不存在节点的。这样，新节点在这些高层级直接作为第一个节点。</p><p>新节点按照确定的层级被插入。对每一层，我们首先设置新节点的 forward 指针指向当前节点的下一个节点，然后更新当前节点的 forward 指针指向新节点。这一过程确保了新节点正确地被链入每一层。</p><p>通过这些步骤，我们不仅完成了新节点的插入操作，还确保了跳表结构的正确性和索引的有效维护。</p><h3 id="3-3-完整代码与解释"><a href="#3-3-完整代码与解释" class="headerlink" title="3.3 完整代码与解释"></a>3.3 完整代码与解释</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在跳表中插入一个新元素。</span><br><span class="hljs-comment"> * @param key 新元素的键。</span><br><span class="hljs-comment"> * @param value 新元素的值。</span><br><span class="hljs-comment"> * @return 如果元素已存在，返回 1；否则，进行插入操作并返回 0。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-type">int</span> SkipList&lt;K, V&gt;::<span class="hljs-built_in">insert_element</span>(<span class="hljs-type">const</span> K key, <span class="hljs-type">const</span> V value) &#123;<br>        Node&lt;K, V&gt; *current = <span class="hljs-keyword">this</span>-&gt;_header;<br>    <span class="hljs-comment">// 用于在各层更新指针的数组</span><br>    Node&lt;K, V&gt; *update[_max_level + <span class="hljs-number">1</span>];  <span class="hljs-comment">// 用于记录每层中待更新指针的节点</span><br>    <span class="hljs-built_in">memset</span>(update, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(Node&lt;K, V&gt; *) * (_max_level + <span class="hljs-number">1</span>));<br><br>    <span class="hljs-comment">// 从最高层向下搜索插入位置</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = _skip_list_level; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// 寻找当前层中最接近且小于 key 的节点</span><br>        <span class="hljs-keyword">while</span> (current-&gt;forward[i] != <span class="hljs-literal">NULL</span> &amp;&amp; current-&gt;forward[i]-&gt;<span class="hljs-built_in">get_key</span>() &lt; key) &#123;<br>            current = current-&gt;forward[i]; <span class="hljs-comment">// 移动到下一节点</span><br>        &#125;<br>        <span class="hljs-comment">// 保存每层中该节点，以便后续插入时更新指针</span><br>        update[i] = current;<br>    &#125;<br><br>    <span class="hljs-comment">// 移动到最底层的下一节点，准备插入操作</span><br>    current = current-&gt;forward[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">// 检查待插入的键是否已存在</span><br>    <span class="hljs-keyword">if</span> (current != <span class="hljs-literal">NULL</span> &amp;&amp; current-&gt;<span class="hljs-built_in">get_key</span>() == key) &#123;<br>        <span class="hljs-comment">// 键已存在，取消插入</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 检查待插入的键是否已存在于跳表中</span><br>    <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">NULL</span> || current-&gt;<span class="hljs-built_in">get_key</span>() != key) &#123;<br>        <span class="hljs-comment">// 通过随机函数决定新节点的层级高度</span><br>        <span class="hljs-type">int</span> random_level = <span class="hljs-built_in">get_random_level</span>();<br>        <span class="hljs-comment">// 如果新节点的层级超出了跳表的当前最高层级</span><br>        <span class="hljs-keyword">if</span> (random_level &gt; _skip_list_level) &#123;<br>            <span class="hljs-comment">// 对所有新的更高层级，将头节点设置为它们的前驱节点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = _skip_list_level + <span class="hljs-number">1</span>; i &lt;= random_level; i++) &#123;<br>                update[i] = _header;<br>            &#125;<br>            <span class="hljs-comment">// 更新跳表的当前最高层级为新节点的层级</span><br>            _skip_list_level = random_level;<br>            <span class="hljs-comment">// 原来是在这里更新了跳表的当前最高层级，初始化的时候是0</span><br>        &#125;<span class="hljs-comment">//--插入节点的核心逻辑。</span><br>        <br>        Node&lt;K, V&gt; *inserted_node = <span class="hljs-built_in">create_node</span>(key, value, random_level);<br>        <span class="hljs-comment">// 在各层插入新节点，同时更新前驱节点的 forward 指针</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= random_level; i++) &#123;<br>            <span class="hljs-comment">// 新节点指向当前节点的下一个节点</span><br>            inserted_node-&gt;forward[i] = update[i]-&gt;forward[i];<br>            <span class="hljs-comment">// 当前节点的下一个节点更新为新节点</span><br>            update[i]-&gt;forward[i] = inserted_node;<br>        &#125;<br>        _element_count++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4-跳表搜索、插入功能实现完整代码"><a href="#3-4-跳表搜索、插入功能实现完整代码" class="headerlink" title="3.4 跳表搜索、插入功能实现完整代码"></a>3.4 跳表搜索、插入功能实现完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-comment">// 节点类定义</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K,<span class="hljs-keyword">typename</span> V&gt; <span class="hljs-comment">// 函数模版</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Node</span>()&#123;&#125;;<span class="hljs-comment">//默认构造函数</span><br>    <span class="hljs-built_in">Node</span>(K k,V v,<span class="hljs-type">int</span>);<span class="hljs-comment">// 构造函数</span><br>    ~<span class="hljs-built_in">Node</span>();<span class="hljs-comment">// 析构函数</span><br>    <span class="hljs-function">K <span class="hljs-title">get_key</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<span class="hljs-comment">// 获取键</span><br>    <span class="hljs-function">V <span class="hljs-title">get_value</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<span class="hljs-comment">// 获取键值</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_value</span><span class="hljs-params">(V)</span></span>;<span class="hljs-comment">//设置key对应的value</span><br>    Node&lt;K,V&gt; **forward;<span class="hljs-comment">// 在C++中，二维指针等价于指针数组。要明确forward数组的含义</span><br>    <span class="hljs-type">int</span> node_level;<span class="hljs-comment">//用来标识当前节点在跳表中的层级位置</span><br><span class="hljs-keyword">private</span>:<br>    K key; <span class="hljs-comment">//存储键</span><br>    V value; <span class="hljs-comment">// 存储键值</span><br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K,<span class="hljs-keyword">typename</span> V&gt;<br>Node&lt;K,V&gt;::<span class="hljs-built_in">Node</span>(<span class="hljs-type">const</span> K k,<span class="hljs-type">const</span> V v,<span class="hljs-type">int</span> level)&#123;<br>    <span class="hljs-keyword">this</span>-&gt;key = k;<br>    <span class="hljs-keyword">this</span>-&gt;value =v;<br>    <span class="hljs-keyword">this</span>-&gt;node_level =level;<br>    <span class="hljs-keyword">this</span>-&gt;forward = <span class="hljs-keyword">new</span> Node&lt;K,V&gt; *[level+<span class="hljs-number">1</span>];<span class="hljs-comment">// 定义当前节点的forward数组的大小，下标从0开始，所以动态分配的大小为level+1</span><br>    <span class="hljs-built_in">memset</span>(<span class="hljs-keyword">this</span>-&gt;forward,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(Node&lt;K,V&gt;*) *(level+<span class="hljs-number">1</span>));<span class="hljs-comment">// 这行代码啥意思：将分配的指针数组初始化为零</span><br><span class="hljs-comment">//memset 是一个标准库函数，定义在 &lt;cstring&gt; 头文件中，用于将某一块内存中的所有字节都设置为指定的值 </span><br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K,<span class="hljs-keyword">typename</span> V&gt;<br>Node&lt;K,V&gt;::~<span class="hljs-built_in">Node</span>()&#123;<span class="hljs-comment">//析构函数实现</span><br>    <span class="hljs-keyword">delete</span>[] forward;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K,<span class="hljs-keyword">typename</span> V&gt;<br>K Node&lt;K,V&gt;::<span class="hljs-built_in">get_key</span>() <span class="hljs-type">const</span>&#123;<span class="hljs-comment">// 获取键函数实现</span><br>    <span class="hljs-keyword">return</span> key;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K,<span class="hljs-keyword">typename</span> V&gt;<br>V Node&lt;K,V&gt;::<span class="hljs-built_in">get_value</span>() <span class="hljs-type">const</span>&#123;<span class="hljs-comment">// 获取键值函数实现</span><br>    <span class="hljs-keyword">return</span> value;<br>&#125;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-type">void</span> Node&lt;K, V&gt;::<span class="hljs-built_in">set_value</span>(V value) &#123;<span class="hljs-comment">// 这里不用加const！编译没通过</span><br>    <span class="hljs-keyword">this</span>-&gt;value = value;<br>&#125;;<br><span class="hljs-comment">// 跳表类定义</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SkipList</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SkipList</span>(<span class="hljs-type">int</span>);  <span class="hljs-comment">// 构造函数</span><br>    ~<span class="hljs-built_in">SkipList</span>();  <span class="hljs-comment">// 析构函数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_random_level</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 生成随机层级</span><br>    <span class="hljs-function">Node&lt;K,V&gt; *<span class="hljs-title">create_node</span><span class="hljs-params">(K, V, <span class="hljs-type">int</span>)</span></span>;  <span class="hljs-comment">// 创建新节点</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">insert_element</span><span class="hljs-params">(K, V)</span></span>;  <span class="hljs-comment">// 插入元素</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">search_element</span><span class="hljs-params">(K)</span></span>;  <span class="hljs-comment">// 搜索元素</span><br>    <span class="hljs-comment">// 其他成员变量和函数（省略）</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> _max_level;  <span class="hljs-comment">// 最大层级</span><br>    <span class="hljs-type">int</span> _skip_list_level;  <span class="hljs-comment">// 当前层级</span><br>    Node&lt;K,V&gt; *_header;  <span class="hljs-comment">// 头节点</span><br>    <span class="hljs-type">int</span> _element_count;  <span class="hljs-comment">// 节点数量</span><br>        <span class="hljs-comment">// 其他私有成员（省略）</span><br>&#125;;<br><br><span class="hljs-comment">// 跳表的构造函数：设置最大层级、初始化成员变量、创建头结点</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K,<span class="hljs-keyword">typename</span> V&gt;<br>SkipList&lt;K,V&gt;::<span class="hljs-built_in">SkipList</span>(<span class="hljs-type">int</span> max_level)&#123;<br>    <span class="hljs-keyword">this</span>-&gt;_max_level = max_level;<span class="hljs-comment">//设置最大层级等于传进来的预设值</span><br>    <span class="hljs-keyword">this</span>-&gt;_skip_list_level = <span class="hljs-number">0</span>;<span class="hljs-comment">//初始化当前层级为0</span><br>    <span class="hljs-keyword">this</span>-&gt;_element_count = <span class="hljs-number">0</span>;<span class="hljs-comment">//初始化节点数量为0</span><br>    K k;<span class="hljs-comment">//默认键</span><br>    V v;<span class="hljs-comment">// 默认键值</span><br>    <span class="hljs-comment">//创建头结点，并初始化为默认值</span><br>    <span class="hljs-keyword">this</span>-&gt;_header = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>&lt;K,V&gt; (k,v,_max_level);<br>&#125;;<br><span class="hljs-comment">// 获取跳表的随机层数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-type">int</span> SkipList&lt;K, V&gt;::<span class="hljs-built_in">get_random_level</span>() &#123;<br>   <span class="hljs-comment">// 初始化层级：每个节点至少出现在第一层。</span><br>   <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<br>   <span class="hljs-comment">// 随机层级增加：使用 rand() % 2 实现抛硬币效果，决定是否升层。</span><br>   <span class="hljs-keyword">while</span> (<span class="hljs-built_in">rand</span>() % <span class="hljs-number">2</span>) &#123;<br>      k++;<br>   &#125;<br>   <span class="hljs-comment">// 层级限制：确保节点层级不超过最大值 _max_level。</span><br>   k = (k &lt; _max_level) ? k : _max_level;<br>   <span class="hljs-comment">// 返回层级：返回确定的层级值，决定节点插入的层。</span><br>   <span class="hljs-keyword">return</span> k;<br>&#125;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K,<span class="hljs-keyword">typename</span> V&gt;<br>Node&lt;K,V&gt; *SkipList&lt;K,V&gt;::<span class="hljs-built_in">create_node</span>(<span class="hljs-type">const</span> K k,<span class="hljs-type">const</span> V v,<span class="hljs-type">int</span> level)&#123;<br>    Node&lt;K,V&gt; *n = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>&lt;K,V&gt;(k,v,level);<span class="hljs-comment">// 实例化新节点，并为其分配指定的键、值、和层级</span><br>    <span class="hljs-keyword">return</span> n;<span class="hljs-comment">//返回创建的新节点</span><br>&#125;<br><span class="hljs-comment">//实现搜索节点功能</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K,<span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-type">bool</span> SkipList&lt;K,V&gt;::<span class="hljs-built_in">search_element</span>(K key)&#123;<br>    <span class="hljs-comment">//定义一个指针current，初始化为跳表的头结点_header</span><br>    Node&lt;K,V&gt; *current = _header;<br>    <span class="hljs-comment">// 从跳表的最高层开始搜素</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = _skip_list_level;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-comment">//遍历当前层级，直到下一个节点的键值大于或等于待查找的键值</span><br>        <span class="hljs-keyword">while</span>(current-&gt;forward[i] &amp;&amp; current-&gt;forward[i]-&gt;<span class="hljs-built_in">get_key</span>() &lt; key)&#123;<br>           <span class="hljs-comment">// 移动到当前层的下一个节点</span><br>           current = current-&gt;forward[i];<br>        &#125;<br>        <span class="hljs-comment">//当前节点的下一个节点的键值大于待查找的键值时，进行下沉到下一层</span><br>        <span class="hljs-comment">// 下沉的操作通过循环i--实现</span><br>    &#125;<br>    <span class="hljs-comment">// 检查当前层（最底层）的下一个节点的键值是否为待查找的键值</span><br>    current = current-&gt;forward[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">if</span>(current &amp;&amp; current-&gt;<span class="hljs-built_in">get_key</span>() == key)&#123;<br>        <span class="hljs-comment">//如果找到匹配的键值，返回 true</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>     <span class="hljs-comment">// 如果没有找到匹配的键值，返回 false</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-type">int</span> SkipList&lt;K,V&gt;::<span class="hljs-built_in">insert_element</span>(<span class="hljs-type">const</span> K key,<span class="hljs-type">const</span> V value)&#123;<br>    Node&lt;K,V&gt; *current = <span class="hljs-keyword">this</span>-&gt;_header; <span class="hljs-comment">// 定义一个指针current，初始化为当前跳表的头结点</span><br>    <span class="hljs-comment">// 定义一个数组用来在各层更新指针</span><br>    Node&lt;K,V&gt; *update[_max_level+<span class="hljs-number">1</span>];<span class="hljs-comment">// 用来记录每层中待更新指针的节点</span><br>    <span class="hljs-built_in">memset</span>(update,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(Node&lt;K,V&gt;*)*(_max_level+<span class="hljs-number">1</span>));<span class="hljs-comment">// 初始化为0</span><br>    <span class="hljs-comment">// 搜索插入位置（自顶向下，参考搜素节点的代码）</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = _skip_list_level;i &gt;= <span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-comment">//寻找当前层中最接近且小于key的节点（待插入节点的前置节点）</span><br>        <span class="hljs-keyword">while</span>(current-&gt;forward[i]!=<span class="hljs-literal">NULL</span> &amp;&amp; current-&gt;forward[i]-&gt;<span class="hljs-built_in">get_key</span>()&lt;key)&#123;<br>            current = current-&gt;forward[i];<span class="hljs-comment">//移动到下一节点</span><br>        &#125;<span class="hljs-comment">// 一旦大于key值，跳出循环，此时current就是待插入节点的前置节点</span><br>        update[i] = current;<span class="hljs-comment">//保存每层中待插入节点的前置节点，以便后续插入时更新指针</span><br>    &#125;<br>    <span class="hljs-comment">// 移动到最底层的下一节点，准备插入操作</span><br>    current = current-&gt;forward[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">//检查待插入的键是否已存在</span><br>    <span class="hljs-keyword">if</span>(current !=<span class="hljs-literal">NULL</span> &amp;&amp;current-&gt;<span class="hljs-built_in">get_key</span>() == key)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//键已存在，取消插入</span><br>    &#125;<br>    <span class="hljs-comment">// 插入操作</span><br>    <span class="hljs-keyword">if</span>(current == <span class="hljs-literal">NULL</span> || current-&gt;<span class="hljs-built_in">get_key</span>() != key)&#123;<br>        <span class="hljs-comment">// 获取插入节点的层级</span><br>        <span class="hljs-type">int</span> random_level = <span class="hljs-built_in">get_random_level</span>();<br>        <span class="hljs-comment">// 如果新节点的层级超出了跳表的当前最高层级</span><br>        <span class="hljs-keyword">if</span>(random_level &gt; _skip_list_level)&#123;<br>            <span class="hljs-comment">//对于所有新的更高层级，将头结点设置为他们的前置节点</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = _skip_list_level+<span class="hljs-number">1</span>;i&lt;= random_level;i++)&#123;<br>                update[i] = _header;<br>            &#125;<br>            <span class="hljs-comment">// 更新跳表的当前最高层级为新节点的层级</span><br>            _skip_list_level = random_level;<br>            <span class="hljs-comment">// 这里更新了当前跳表的最高层级，以便从顶层向下遍历。</span><br>        &#125;<br>        Node&lt;K,V&gt; *insert_node = <span class="hljs-built_in">create_node</span>(key,value,random_level);<br>        <span class="hljs-comment">// 在各层插入新节点，同时更新前置节点的forward指针</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;=random_level;i++)&#123;<br>            <span class="hljs-comment">// 新节点指向当前节点的下一个节点</span><br>            insert_node-&gt;forward[i] = update[i]-&gt;forward[i];<span class="hljs-comment">//这里的update[i]就是之前记录的每个层级要插入的新节点的前置节点</span><br>            <span class="hljs-comment">//当前节点的下一个节点更新为新节点</span><br>            update[i]-&gt;forward[i] = insert_node;<br>        &#125;<br>        _element_count++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//插入</span><br>    <span class="hljs-type">int</span> N;<br>    <span class="hljs-type">int</span> M;<br>    SkipList&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; *skip_list = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SkipList</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">16</span>);<br>    std::cin &gt;&gt; N &gt;&gt; M;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-type">int</span> key;<br>        <span class="hljs-type">int</span> value;<br>        std::cin &gt;&gt; key &gt;&gt; value;<br>        <span class="hljs-keyword">if</span> (skip_list-&gt;<span class="hljs-built_in">insert_element</span>(key, value) == <span class="hljs-number">0</span>) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Insert Success&quot;</span> &lt;&lt; std::endl;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Insert Failed&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 搜索</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; M; i++) &#123;<br>        <span class="hljs-type">int</span> key;<br>        std::cin &gt;&gt; key;<br>        <span class="hljs-keyword">if</span> (skip_list-&gt;<span class="hljs-built_in">search_element</span>(key)) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Search Success&quot;</span> &lt;&lt; std::endl;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Search Failed&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输入描述：</strong>首行输入两个正整数 N 和 M。N 表示接下来有 N 行数据，每行包含两个整数：第一个整数是 key，第二个整数是 value，表示需要向跳表中插入该键值对。 后续有 M 行数据，每行包含一个整数，表示需要在跳表中查询的 key 值。</p><p><strong>输出描述：</strong>输出一共有 N + M 行。前 N 行显示数据插入的结果。如果插入成功，输出 “Insert Success”。如果插入失败（例如，跳表中已存在该 key），则输出 “Insert Failed”。接下来的 M 行显示查询跳表的结果。如果找到了插入了 key，输出 “Search Success”，否则输出该 “Search Failed”。</p><h1 id="跳表的删除"><a href="#跳表的删除" class="headerlink" title="跳表的删除"></a>跳表的删除</h1><h2 id="1-删除跳表中的节点"><a href="#1-删除跳表中的节点" class="headerlink" title="1. 删除跳表中的节点"></a>1. 删除跳表中的节点</h2><h3 id="1-1-理论基础"><a href="#1-1-理论基础" class="headerlink" title="1.1 理论基础"></a>1.1 理论基础</h3><p>删除操作是跳表功能的重要组成部分。</p><p>它涉及以下几个关键步骤：</p><ol><li>定位待删除节点：通过搜索确定需要删除的节点位置</li><li>更新指针关系：调整相关节点的指针，以从跳表中移除目标节点</li><li>内存回收：释放被删除节点所占用的资源</li></ol><h3 id="1-2-代码实现"><a href="#1-2-代码实现" class="headerlink" title="1.2 代码实现"></a>1.2 代码实现</h3><p>删除操作首先需要定位到待删除的节点，这一过程与 search_element 和 insert_element 函数类似。</p><p>此外，我们同样使用 update 数组记录每层待删除节点的前驱节点，以便更新指针关系。</p><p>具体实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 删除跳表中的节点</span><br><span class="hljs-comment"> * @param key 待删除节点的 key 值</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-type">void</span> SkipList&lt;K, V&gt;::<span class="hljs-built_in">delete_element</span>(K key) &#123;<br>    Node&lt;K, V&gt; *current = <span class="hljs-keyword">this</span>-&gt;_header;<br>    Node&lt;K, V&gt; *update[_max_level + <span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">memset</span>(update, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(Node&lt;K, V&gt; *) * (_max_level + <span class="hljs-number">1</span>));<br><br>    <span class="hljs-comment">// 从最高层开始向下搜索待删除节点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = _skip_list_level; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">while</span> (current-&gt;forward[i] != <span class="hljs-literal">NULL</span> &amp;&amp; current-&gt;forward[i]-&gt;<span class="hljs-built_in">get_key</span>() &lt; key) &#123;<br>            current = current-&gt;forward[i];<br>        &#125;<br>        update[i] = current; <span class="hljs-comment">// 记录每层待删除节点的前驱</span><br>    &#125;<br><br>    current = current-&gt;forward[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">// 确认找到了待删除的节点</span><br>    <span class="hljs-keyword">if</span> (current != <span class="hljs-literal">NULL</span> &amp;&amp; current-&gt;<span class="hljs-built_in">get_key</span>() == key) &#123;<br>        <span class="hljs-comment">// 逐层更新指针，移除节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= _skip_list_level; i++) &#123;<br>            <span class="hljs-keyword">if</span> (update[i]-&gt;forward[i] != current) <span class="hljs-keyword">break</span>;<br>            update[i]-&gt;forward[i] = current-&gt;forward[i];<br>        &#125;<br>        <span class="hljs-comment">// 调整跳表的层级</span><br>        <span class="hljs-keyword">while</span> (_skip_list_level &gt; <span class="hljs-number">0</span> &amp;&amp; _header-&gt;forward[_skip_list_level] == <span class="hljs-literal">NULL</span>) &#123;<br>            _skip_list_level--;<br>        &#125;<span class="hljs-comment">// while循环里的判断条件是什么含义</span><br>        <span class="hljs-keyword">delete</span> current; <span class="hljs-comment">// 释放节点占用的内存</span><br>        _element_count--; <span class="hljs-comment">// 节点计数减一</span><br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现删除操作的测试用例完整代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-comment">// 节点类定义</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K,<span class="hljs-keyword">typename</span> V&gt; <span class="hljs-comment">// 函数模版</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Node</span>()&#123;&#125;;<span class="hljs-comment">//默认构造函数</span><br>    <span class="hljs-built_in">Node</span>(K k,V v,<span class="hljs-type">int</span>);<span class="hljs-comment">// 构造函数</span><br>    ~<span class="hljs-built_in">Node</span>();<span class="hljs-comment">// 析构函数</span><br>    <span class="hljs-function">K <span class="hljs-title">get_key</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<span class="hljs-comment">// 获取键</span><br>    <span class="hljs-function">V <span class="hljs-title">get_value</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<span class="hljs-comment">// 获取键值</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_value</span><span class="hljs-params">(V)</span></span>;<span class="hljs-comment">//设置key对应的value</span><br>    Node&lt;K,V&gt; **forward;<span class="hljs-comment">// 在C++中，二维指针等价于指针数组。要明确forward数组的含义</span><br>    <span class="hljs-type">int</span> node_level;<span class="hljs-comment">//用来标识当前节点在跳表中的层级位置</span><br><span class="hljs-keyword">private</span>:<br>    K key; <span class="hljs-comment">//存储键</span><br>    V value; <span class="hljs-comment">// 存储键值</span><br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K,<span class="hljs-keyword">typename</span> V&gt;<br>Node&lt;K,V&gt;::<span class="hljs-built_in">Node</span>(<span class="hljs-type">const</span> K k,<span class="hljs-type">const</span> V v,<span class="hljs-type">int</span> level)&#123;<br>    <span class="hljs-keyword">this</span>-&gt;key = k;<br>    <span class="hljs-keyword">this</span>-&gt;value =v;<br>    <span class="hljs-keyword">this</span>-&gt;node_level =level;<br>    <span class="hljs-keyword">this</span>-&gt;forward = <span class="hljs-keyword">new</span> Node&lt;K,V&gt; *[level+<span class="hljs-number">1</span>];<span class="hljs-comment">// 定义当前节点的forward数组的大小，下标从0开始，所以动态分配的大小为level+1</span><br>    <span class="hljs-built_in">memset</span>(<span class="hljs-keyword">this</span>-&gt;forward,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(Node&lt;K,V&gt;*) *(level+<span class="hljs-number">1</span>));<span class="hljs-comment">// 这行代码啥意思：将分配的指针数组初始化为零</span><br><span class="hljs-comment">//memset 是一个标准库函数，定义在 &lt;cstring&gt; 头文件中，用于将某一块内存中的所有字节都设置为指定的值 </span><br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K,<span class="hljs-keyword">typename</span> V&gt;<br>Node&lt;K,V&gt;::~<span class="hljs-built_in">Node</span>()&#123;<span class="hljs-comment">//析构函数实现</span><br>    <span class="hljs-keyword">delete</span>[] forward;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K,<span class="hljs-keyword">typename</span> V&gt;<br>K Node&lt;K,V&gt;::<span class="hljs-built_in">get_key</span>() <span class="hljs-type">const</span>&#123;<span class="hljs-comment">// 获取键函数实现</span><br>    <span class="hljs-keyword">return</span> key;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K,<span class="hljs-keyword">typename</span> V&gt;<br>V Node&lt;K,V&gt;::<span class="hljs-built_in">get_value</span>() <span class="hljs-type">const</span>&#123;<span class="hljs-comment">// 获取键值函数实现</span><br>    <span class="hljs-keyword">return</span> value;<br>&#125;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-type">void</span> Node&lt;K, V&gt;::<span class="hljs-built_in">set_value</span>(V value) &#123;<span class="hljs-comment">// 这里不用加const！编译没通过</span><br>    <span class="hljs-keyword">this</span>-&gt;value = value;<br>&#125;;<br><span class="hljs-comment">// 跳表类定义</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SkipList</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SkipList</span>(<span class="hljs-type">int</span>);  <span class="hljs-comment">// 构造函数</span><br>    ~<span class="hljs-built_in">SkipList</span>();  <span class="hljs-comment">// 析构函数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_random_level</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 生成随机层级</span><br>    <span class="hljs-function">Node&lt;K,V&gt; *<span class="hljs-title">create_node</span><span class="hljs-params">(K, V, <span class="hljs-type">int</span>)</span></span>;  <span class="hljs-comment">// 创建新节点</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">insert_element</span><span class="hljs-params">(K, V)</span></span>;  <span class="hljs-comment">// 插入元素</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">search_element</span><span class="hljs-params">(K)</span></span>;  <span class="hljs-comment">// 搜索元素</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">delete_element</span><span class="hljs-params">(K)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display_list</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 其他成员变量和函数（省略）</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> _max_level;  <span class="hljs-comment">// 最大层级</span><br>    <span class="hljs-type">int</span> _skip_list_level;  <span class="hljs-comment">// 当前层级</span><br>    Node&lt;K,V&gt; *_header;  <span class="hljs-comment">// 头节点</span><br>    <span class="hljs-type">int</span> _element_count;  <span class="hljs-comment">// 节点数量</span><br>        <span class="hljs-comment">// 其他私有成员（省略）</span><br>&#125;;<br><br><span class="hljs-comment">// 跳表的构造函数：设置最大层级、初始化成员变量、创建头结点</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K,<span class="hljs-keyword">typename</span> V&gt;<br>SkipList&lt;K,V&gt;::<span class="hljs-built_in">SkipList</span>(<span class="hljs-type">int</span> max_level)&#123;<br>    <span class="hljs-keyword">this</span>-&gt;_max_level = max_level;<span class="hljs-comment">//设置最大层级等于传进来的预设值</span><br>    <span class="hljs-keyword">this</span>-&gt;_skip_list_level = <span class="hljs-number">0</span>;<span class="hljs-comment">//初始化当前层级为0</span><br>    <span class="hljs-keyword">this</span>-&gt;_element_count = <span class="hljs-number">0</span>;<span class="hljs-comment">//初始化节点数量为0</span><br>    K k;<span class="hljs-comment">//默认键</span><br>    V v;<span class="hljs-comment">// 默认键值</span><br>    <span class="hljs-comment">//创建头结点，并初始化为默认值</span><br>    <span class="hljs-keyword">this</span>-&gt;_header = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>&lt;K,V&gt; (k,v,_max_level);<br>&#125;;<br><span class="hljs-comment">// 获取跳表的随机层数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-type">int</span> SkipList&lt;K, V&gt;::<span class="hljs-built_in">get_random_level</span>() &#123;<br>   <span class="hljs-comment">// 初始化层级：每个节点至少出现在第一层。</span><br>   <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<br>   <span class="hljs-comment">// 随机层级增加：使用 rand() % 2 实现抛硬币效果，决定是否升层。</span><br>   <span class="hljs-keyword">while</span> (<span class="hljs-built_in">rand</span>() % <span class="hljs-number">2</span>) &#123;<br>      k++;<br>   &#125;<br>   <span class="hljs-comment">// 层级限制：确保节点层级不超过最大值 _max_level。</span><br>   k = (k &lt; _max_level) ? k : _max_level;<br>   <span class="hljs-comment">// 返回层级：返回确定的层级值，决定节点插入的层。</span><br>   <span class="hljs-keyword">return</span> k;<br>&#125;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K,<span class="hljs-keyword">typename</span> V&gt;<br>Node&lt;K,V&gt; *SkipList&lt;K,V&gt;::<span class="hljs-built_in">create_node</span>(<span class="hljs-type">const</span> K k,<span class="hljs-type">const</span> V v,<span class="hljs-type">int</span> level)&#123;<br>    Node&lt;K,V&gt; *n = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>&lt;K,V&gt;(k,v,level);<span class="hljs-comment">// 实例化新节点，并为其分配指定的键、值、和层级</span><br>    <span class="hljs-keyword">return</span> n;<span class="hljs-comment">//返回创建的新节点</span><br>&#125;<br><span class="hljs-comment">//实现搜索节点功能</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K,<span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-type">bool</span> SkipList&lt;K,V&gt;::<span class="hljs-built_in">search_element</span>(K key)&#123;<br>    <span class="hljs-comment">//定义一个指针current，初始化为跳表的头结点_header</span><br>    Node&lt;K,V&gt; *current = _header;<br>    <span class="hljs-comment">// 从跳表的最高层开始搜素</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = _skip_list_level;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-comment">//遍历当前层级，直到下一个节点的键值大于或等于待查找的键值</span><br>        <span class="hljs-keyword">while</span>(current-&gt;forward[i] &amp;&amp; current-&gt;forward[i]-&gt;<span class="hljs-built_in">get_key</span>() &lt; key)&#123;<br>           <span class="hljs-comment">// 移动到当前层的下一个节点</span><br>           current = current-&gt;forward[i];<br>        &#125;<br>        <span class="hljs-comment">//当前节点的下一个节点的键值大于待查找的键值时，进行下沉到下一层</span><br>        <span class="hljs-comment">// 下沉的操作通过循环i--实现</span><br>    &#125;<br>    <span class="hljs-comment">// 检查当前层（最底层）的下一个节点的键值是否为待查找的键值</span><br>    current = current-&gt;forward[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">if</span>(current &amp;&amp; current-&gt;<span class="hljs-built_in">get_key</span>() == key)&#123;<br>        <span class="hljs-comment">//如果找到匹配的键值，返回 true</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>     <span class="hljs-comment">// 如果没有找到匹配的键值，返回 false</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-type">int</span> SkipList&lt;K,V&gt;::<span class="hljs-built_in">insert_element</span>(<span class="hljs-type">const</span> K key,<span class="hljs-type">const</span> V value)&#123;<br>    Node&lt;K,V&gt; *current = <span class="hljs-keyword">this</span>-&gt;_header; <span class="hljs-comment">// 定义一个指针current，初始化为当前跳表的头结点</span><br>    <span class="hljs-comment">// 定义一个数组用来在各层更新指针</span><br>    Node&lt;K,V&gt; *update[_max_level+<span class="hljs-number">1</span>];<span class="hljs-comment">// 用来记录每层中待更新指针的节点</span><br>    <span class="hljs-built_in">memset</span>(update,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(Node&lt;K,V&gt;*)*(_max_level+<span class="hljs-number">1</span>));<span class="hljs-comment">// 初始化为0</span><br>    <span class="hljs-comment">// 搜索插入位置（自顶向下，参考搜素节点的代码）</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = _skip_list_level;i &gt;= <span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-comment">//寻找当前层中最接近且小于key的节点（待插入节点的前置节点）</span><br>        <span class="hljs-keyword">while</span>(current-&gt;forward[i]!=<span class="hljs-literal">NULL</span> &amp;&amp; current-&gt;forward[i]-&gt;<span class="hljs-built_in">get_key</span>()&lt;key)&#123;<br>            current = current-&gt;forward[i];<span class="hljs-comment">//移动到下一节点</span><br>        &#125;<span class="hljs-comment">// 一旦大于key值，跳出循环，此时current就是待插入节点的前置节点</span><br>        update[i] = current;<span class="hljs-comment">//保存每层中待插入节点的前置节点，以便后续插入时更新指针</span><br>    &#125;<br>    <span class="hljs-comment">// 移动到最底层的下一节点，准备插入操作</span><br>    current = current-&gt;forward[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">//检查待插入的键是否已存在</span><br>    <span class="hljs-keyword">if</span>(current !=<span class="hljs-literal">NULL</span> &amp;&amp;current-&gt;<span class="hljs-built_in">get_key</span>() == key)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//键已存在，取消插入</span><br>    &#125;<br>    <span class="hljs-comment">// 插入操作</span><br>    <span class="hljs-keyword">if</span>(current == <span class="hljs-literal">NULL</span> || current-&gt;<span class="hljs-built_in">get_key</span>() != key)&#123;<br>        <span class="hljs-comment">// 获取插入节点的层级</span><br>        <span class="hljs-type">int</span> random_level = <span class="hljs-built_in">get_random_level</span>();<br>        <span class="hljs-comment">// 如果新节点的层级超出了跳表的当前最高层级</span><br>        <span class="hljs-keyword">if</span>(random_level &gt; _skip_list_level)&#123;<br>            <span class="hljs-comment">//对于所有新的更高层级，将头结点设置为他们的前置节点</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = _skip_list_level+<span class="hljs-number">1</span>;i&lt;= random_level;i++)&#123;<br>                update[i] = _header;<br>            &#125;<br>            <span class="hljs-comment">// 更新跳表的当前最高层级为新节点的层级</span><br>            _skip_list_level = random_level;<br>            <span class="hljs-comment">// 这里更新了当前跳表的最高层级，以便从顶层向下遍历。</span><br>        &#125;<br>        Node&lt;K,V&gt; *insert_node = <span class="hljs-built_in">create_node</span>(key,value,random_level);<br>        <span class="hljs-comment">// 在各层插入新节点，同时更新前置节点的forward指针</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;=random_level;i++)&#123;<br>            <span class="hljs-comment">// 新节点指向当前节点的下一个节点</span><br>            insert_node-&gt;forward[i] = update[i]-&gt;forward[i];<span class="hljs-comment">//这里的update[i]就是之前记录的每个层级要插入的新节点的前置节点</span><br>            <span class="hljs-comment">//当前节点的下一个节点更新为新节点</span><br>            update[i]-&gt;forward[i] = insert_node;<br>        &#125;<br>        _element_count++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-type">void</span> SkipList&lt;K,V&gt;::<span class="hljs-built_in">delete_element</span>(K key)&#123;<br>    Node&lt;K,V&gt; *current = <span class="hljs-keyword">this</span>-&gt;_header;<span class="hljs-comment">//定义一个指针current，初始化为当前跳表的头结点</span><br>    Node&lt;K,V&gt; *update[_max_level+<span class="hljs-number">1</span>];<span class="hljs-comment">//// 定义一个数组用来在各层更新指针</span><br>    <span class="hljs-built_in">memset</span>(update,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(Node&lt;K,V&gt;*)*(_max_level+<span class="hljs-number">1</span>));<span class="hljs-comment">// 初始化为0</span><br>    <br>    <span class="hljs-comment">// 从最高层级往下搜索待删除的节点</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =_skip_list_level;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-comment">//寻找当前层中最接近且小于key的节点（待删除节点的前置节点）</span><br>        <span class="hljs-keyword">while</span>(current-&gt;forward[i] != <span class="hljs-literal">NULL</span> &amp;&amp; current-&gt;forward[i]-&gt;<span class="hljs-built_in">get_key</span>() &lt; key)&#123;<br>            current = current-&gt;forward[i];<br>        &#125;<span class="hljs-comment">// 一旦大于key值，跳出循环，此时current就是待删除节点的前置节点</span><br>        update[i] = current;<span class="hljs-comment">//保存每层中待删除节点的前置节点，以便后续删除时更新指针</span><br>    &#125;<br>    <span class="hljs-comment">// 移动到（当前层）最底层的下一节点，准备删除操作</span><br>    current = current-&gt;forward[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">// 确认找到了待删除的节点</span><br>    <span class="hljs-keyword">if</span>(current != <span class="hljs-literal">NULL</span> &amp;&amp; current-&gt;<span class="hljs-built_in">get_key</span>() == key)&#123;<br>        <span class="hljs-comment">// 逐层更新，移除节点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;=_skip_list_level;i++)&#123;<br>            <span class="hljs-keyword">if</span>(update[i]-&gt;forward[i] != current) <span class="hljs-keyword">break</span>;<span class="hljs-comment">// 确保不是最后一个节点</span><br>            update[i]-&gt;forward[i] = current-&gt;forward[i];<span class="hljs-comment">//这里的update[i]就是之前记录的每个层级要删除的新节点的前置节点</span><br>        &#125;<br>        <span class="hljs-comment">//调整表的层级</span><br>        <span class="hljs-keyword">while</span>(_skip_list_level &gt; <span class="hljs-number">0</span> &amp;&amp; _header-&gt;forward[_skip_list_level] == <span class="hljs-literal">NULL</span>)&#123;<br>            _skip_list_level--;<br>        &#125;<span class="hljs-comment">// 你逐级删除某个key，你的最大层的头结点指向空，因为层级减少了。</span><br>        <span class="hljs-keyword">delete</span> current;<span class="hljs-comment">//释放节点占用的内存</span><br>        _element_count--;<span class="hljs-comment">// 节点计数减一</span><br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> N, K, M;<br><br>    std::cin &gt;&gt; N &gt;&gt; K &gt;&gt; M;<br><br>    SkipList&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; *skiplist = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SkipList</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">16</span>);<br>    <span class="hljs-comment">// 插入数据</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-type">int</span> k, v;<br>        std::cin &gt;&gt; k &gt;&gt; v;<br>        <span class="hljs-keyword">if</span> (skiplist-&gt;<span class="hljs-built_in">insert_element</span>(k, v) == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//返回0</span><br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Insert Success&quot;</span> &lt;&lt; std::endl;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//返回bool 1，代表插入失败（已存在）</span><br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Insert Failed&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 删除数据</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; K; i++) &#123;<br>        <span class="hljs-type">int</span> k;<br>        std::cin &gt;&gt; k;<br>        skiplist-&gt;<span class="hljs-built_in">delete_element</span>(k);<br>    &#125;<br>    <span class="hljs-comment">// 查找数据</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; M; i++) &#123;<br>        <span class="hljs-type">int</span> k;<br>        std::cin &gt;&gt; k;<br>        <span class="hljs-keyword">if</span> (skiplist-&gt;<span class="hljs-built_in">search_element</span>(k)) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Search Success&quot;</span> &lt;&lt; std::endl;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Search Failed&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输入描述：</strong>输入分为三个部分，以空格分隔的三个正整数 N、K 和 M 开头，具体含义如下：</p><p>N：表示接下来有 N 行数据，每行包含两个整数 key 和 value。这些行代表初始时需要向跳表中插入的键值对，其中 key 是键，value 是与键关联的值。</p><p>K：表示接下来有 K 行数据，每行包含一个整数 key。每个 key 对应一个之前已插入的键值对。</p><p>M：表示接下来有 M 行数据，每行包含一个整数 key。这些行代表需要进行查询操作的键，以检查它们是否存在于跳表中。</p><p>输出描述：输出结果分为两个部分，共计 N + M 行，对应于输入数据中的插入和查询操作的结果</p><p>插入操作的结果（前 N 行）：每当一个键值对成功插入跳表时，输出一行 “Insert Success”。 如果插入失败（例如，当跳表中已经存在相同的 key 时），则输出一行 “Insert Failed”。</p><p>查询操作的结果（最后的 M 行）：当查询操作在跳表中找到了指定的 key 时，输出该 “Search Success”。 如果查询失败（即，跳表中不存在该 key），则输出 “Search Failed”。</p><p>中间两行是删除操作。</p><h1 id="跳表的展示"><a href="#跳表的展示" class="headerlink" title="跳表的展示"></a>跳表的展示</h1><p>在完成跳表的节点插入和搜索功能后，展示跳表的结构成为了下一个重要的任务。这不仅有助于理解跳表的工作原理，也是验证实现正确性的一个有效手段。</p><h2 id="1-理论基础"><a href="#1-理论基础" class="headerlink" title="1. 理论基础"></a>1. 理论基础</h2><p>跳表的结构本质上是一个通过对原始链表的部分节点进行筛选而构建的多级索引链表，可以视为多个层级的单链表的组合。</p><p>跳表的每一层都有一个头节点，通过这些头节点可以访问到该层的所有节点。我们首先遍历这些头节点，从而实现对每一层的访问。</p><h2 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2. 代码实现"></a>2. 代码实现</h2><p>为了遍历跳表的每一层，我们利用跳表的头节点数组_header，其中_header[i]代表第i层的头节点。通过以下代码，我们可以实现对每一层头节点的遍历：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= _skip_list_level; i++) &#123;<br>    Node&lt;K, V&gt; *node = _header-&gt;forward[i];<br>&#125;<br></code></pre></td></tr></table></figure><p>在获取到每一层的头节点后，我们通过迭代的方式遍历该层的所有节点，并打印出节点中的键和值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> (node != <span class="hljs-literal">NULL</span>) &#123;<br>    std::cout &lt;&lt; node-&gt;<span class="hljs-built_in">get_key</span>() &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; node-&gt;<span class="hljs-built_in">get_value</span>() &lt;&lt; <span class="hljs-string">&quot;;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>将上述步骤综合起来，我们得到了展示跳表内容的完整方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-type">void</span> SkipList&lt;K, V&gt;::<span class="hljs-built_in">display_list</span>() &#123;<br>    <span class="hljs-comment">// 从最上层开始向下遍历所有层</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = _skip_list_level; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        Node&lt;K, V&gt;* node = <span class="hljs-keyword">this</span>-&gt;_header-&gt;forward[i]; <span class="hljs-comment">// 获取当前层的头节点</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Level &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;: &quot;</span>;<br>        <span class="hljs-comment">// 遍历当前层的所有节点</span><br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-comment">// 打印当前节点的键和值，键值对之间用&quot;:&quot;分隔</span><br>            std::cout &lt;&lt; node-&gt;<span class="hljs-built_in">get_key</span>() &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; node-&gt;<span class="hljs-built_in">get_value</span>() &lt;&lt; <span class="hljs-string">&quot;;&quot;</span>;<br>            <span class="hljs-comment">// 移动到当前层的下一个节点</span><br>            node = node-&gt;forward[i];<br>        &#125;<br>        std::cout &lt;&lt; std::endl; <span class="hljs-comment">// 当前层遍历结束，换行</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="生成和读取持久化文件"><a href="#生成和读取持久化文件" class="headerlink" title="生成和读取持久化文件"></a>生成和读取持久化文件</h1><p>作为核心的存储引擎功能，数据的持久化保存与高效读取是至关重要的。</p><h2 id="1-数据的保存"><a href="#1-数据的保存" class="headerlink" title="1. 数据的保存"></a>1. 数据的保存</h2><p>在之前的章节中，我们介绍了如何在存储引擎中实现数据的搜索、插入和删除操作。这些操作都是在内存中进行的，意味着一旦程序终止，所有的数据就会丢失。因此，实现数据的持久化保存变得尤为重要。</p><p>考虑到键值对数据结构的特点，我们选择将数据保存到文件中，采用 key:value 格式进行存储，每行存储一个键值对。这种格式既简单又易于解析，适合快速的数据存取。</p><p>目标文件结构如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">1:store<br>2:engine<br>3:text<br></code></pre></td></tr></table></figure><p>在 C++ 中，我们利用 std::ofstream 来打开文件、写入数据，并在数据写入完成后关闭文件。</p><p>实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-type">void</span> SkipList&lt;K, V&gt;::<span class="hljs-built_in">dump_file</span>() &#123;<br>    _file_writer.<span class="hljs-built_in">open</span>(STORE_FILE); <span class="hljs-comment">// 打开文件</span><br>    Node&lt;K, V&gt;* node = <span class="hljs-keyword">this</span>-&gt;_header-&gt;forward[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 从头节点开始遍历</span><br><br>    <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>        _file_writer &lt;&lt; node-&gt;<span class="hljs-built_in">get_key</span>() &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; node-&gt;<span class="hljs-built_in">get_value</span>() &lt;&lt; <span class="hljs-string">&quot;;\n&quot;</span>; <span class="hljs-comment">// 写入键值对</span><br>        node = node-&gt;forward[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 移动到下一个节点</span><br>    &#125;<br><br>    _file_writer.<span class="hljs-built_in">flush</span>(); <span class="hljs-comment">// 刷新缓冲区，确保数据完全写入</span><br>    _file_writer.<span class="hljs-built_in">close</span>(); <span class="hljs-comment">// 关闭文件</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>STORE_FILE 是代码中定义的一个路径</p></blockquote><h2 id="2-数据的读取"><a href="#2-数据的读取" class="headerlink" title="2. 数据的读取"></a>2. 数据的读取</h2><p>数据持久化之后，下一步就是实现其读取过程。在这个过程中，我们面临两个挑战：一是如何将文件中的key:value字符串解析为键值对；二是如何将读取的数据插入到内存中的跳表并建立索引。</p><p>我们首先需要定义一个工具函数，用于验证字符串的合法性。这包括检查字符串是否为空，以及是否包含分隔符:。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-type">bool</span> SkipList&lt;K, V&gt;::<span class="hljs-built_in">is_valid_string</span>(<span class="hljs-type">const</span> std::string&amp; str) &#123;<br>    <span class="hljs-keyword">return</span> !str.<span class="hljs-built_in">empty</span>() &amp;&amp; str.<span class="hljs-built_in">find</span>(delimiter) != std::string::npos;<br>&#125;<br></code></pre></td></tr></table></figure><p>验证字符串合法性后，我们将字符串分割为键和值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-type">void</span> SkipList&lt;K, V&gt;::<span class="hljs-built_in">get_key_value_from_string</span>(<span class="hljs-type">const</span> std::string&amp; str, std::string* key, std::string* value) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">is_valid_string</span>(str)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    *key = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, str.<span class="hljs-built_in">find</span>(delimiter));<br>    *value = str.<span class="hljs-built_in">substr</span>(str.<span class="hljs-built_in">find</span>(delimiter) + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>有了上述工具函数，我们可以继续实现从磁盘加载数据到跳表的过程。</p><p>在对字符串进行校验了之后，此时我们就需要将磁盘中 key:value 串转换成内存中的 key 和 value 了。</p><p>通过使用 std::string::substr 函数，我们可以将字符串切片，得到我们想要的 key 和 value。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-type">void</span> SkipList&lt;K, V&gt;::<span class="hljs-built_in">get_key_value_from_string</span>(<span class="hljs-type">const</span> std::string &amp;str, std::string *key, std::string *value) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">is_valid_string</span>(str)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    *key = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, str.<span class="hljs-built_in">find</span>(delimiter));<br>    *value = str.<span class="hljs-built_in">substr</span>(str.<span class="hljs-built_in">find</span>(delimiter) + <span class="hljs-number">1</span>, str.<span class="hljs-built_in">length</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>写完所需的工具函数之后，下一步就是具体的操作了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Load data from disk</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-type">void</span> SkipList&lt;K, V&gt;::<span class="hljs-built_in">load_file</span>() &#123;<br>    _file_reader.<span class="hljs-built_in">open</span>(STORE_FILE);<br>    std::string line;<br>    std::string *key = <span class="hljs-keyword">new</span> std::<span class="hljs-built_in">string</span>();<br>    std::string *value = <span class="hljs-keyword">new</span> std::<span class="hljs-built_in">string</span>();<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(_file_reader, line)) &#123;<br>        <span class="hljs-built_in">get_key_value_from_string</span>(line, key, value);<br>        <span class="hljs-keyword">if</span> (key-&gt;<span class="hljs-built_in">empty</span>() || value-&gt;<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">// Define key as int type</span><br>        <span class="hljs-built_in">insert_element</span>(<span class="hljs-built_in">stoi</span>(*key), *value);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;key:&quot;</span> &lt;&lt; *key &lt;&lt; <span class="hljs-string">&quot;value:&quot;</span> &lt;&lt; *value &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">delete</span> key;<br>    <span class="hljs-keyword">delete</span> value;<br>    _file_reader.<span class="hljs-built_in">close</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码展示了如何将数据从磁盘读取并恢复到跳表中，同时建立必要的索引，以保持存储引擎的效率和响应性。</p><h1 id="模块合并"><a href="#模块合并" class="headerlink" title="模块合并"></a>模块合并</h1><p>在跳表插入和删除数据的过程中，没有进行加锁，在多线程的情况下，可能会出现数据不一致的问题等。</p><p>现在我们将之前所有模块合并，同时补齐那些没有涉及到的内容</p><p>合并过程：</p><ul><li>创建一个 skiplist.h 文件</li><li>添加需要的头文件</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span>  <span class="hljs-comment">// 随机函数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span>    <span class="hljs-comment">// 引入互斥锁</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span>  <span class="hljs-comment">// 引入文件操作</span></span><br></code></pre></td></tr></table></figure><ul><li>定义数据保存和加载时的文件路径</li><li>定义互斥锁</li><li>定义”:”的宏</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> STORE_FILE <span class="hljs-string">&quot;store/dumpFile&quot;</span>  <span class="hljs-comment">// 存储文件路径</span></span><br>std::mutex mtx; <span class="hljs-comment">// 定义互斥锁</span><br>std::string delimiter = <span class="hljs-string">&quot;:&quot;</span>;<br></code></pre></td></tr></table></figure><h2 id="1、对插入节点成员函数和删除节点成员函数进行加锁"><a href="#1、对插入节点成员函数和删除节点成员函数进行加锁" class="headerlink" title="1、对插入节点成员函数和删除节点成员函数进行加锁"></a>1、对插入节点成员函数和删除节点成员函数进行加锁</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在跳表中插入一个新元素。</span><br><span class="hljs-comment"> * @param key 新元素的键。</span><br><span class="hljs-comment"> * @param value 新元素的值。</span><br><span class="hljs-comment"> * @return 如果元素已存在，返回 1；否则，进行插入操作并返回 0。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-type">int</span> SkipList&lt;K, V&gt;::<span class="hljs-built_in">insert_element</span>(<span class="hljs-type">const</span> K key, <span class="hljs-type">const</span> V value) &#123;<br>    mtx.<span class="hljs-built_in">lock</span>();<span class="hljs-comment">// 加互斥锁，防止多线程访问导致数据不一致</span><br>    Node&lt;K, V&gt; *current = <span class="hljs-keyword">this</span>-&gt;_header;<br>    <span class="hljs-comment">// 用于在各层更新指针的数组</span><br>    Node&lt;K, V&gt; *update[_max_level + <span class="hljs-number">1</span>];  <span class="hljs-comment">// 用于记录每层中待更新指针的节点</span><br>    <span class="hljs-built_in">memset</span>(update, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(Node&lt;K, V&gt; *) * (_max_level + <span class="hljs-number">1</span>));<br><br>    <span class="hljs-comment">// 从最高层向下搜索插入位置</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = _skip_list_level; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// 寻找当前层中最接近且小于 key 的节点</span><br>        <span class="hljs-keyword">while</span> (current-&gt;forward[i] != <span class="hljs-literal">NULL</span> &amp;&amp; current-&gt;forward[i]-&gt;<span class="hljs-built_in">get_key</span>() &lt; key) &#123;<br>            current = current-&gt;forward[i]; <span class="hljs-comment">// 移动到下一节点</span><br>        &#125;<br>        <span class="hljs-comment">// 保存每层中该节点，以便后续插入时更新指针</span><br>        update[i] = current;<br>    &#125;<br><br>    <span class="hljs-comment">// 移动到最底层的下一节点，准备插入操作</span><br>    current = current-&gt;forward[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">// 检查待插入的键是否已存在</span><br>    <span class="hljs-keyword">if</span> (current != <span class="hljs-literal">NULL</span> &amp;&amp; current-&gt;<span class="hljs-built_in">get_key</span>() == key) &#123;<br>        <span class="hljs-comment">// 键已存在，取消插入</span><br>        mtx.<span class="hljs-built_in">unlock</span>();<span class="hljs-comment">//在return前提前解锁，释放互斥锁</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 检查待插入的键是否已存在于跳表中</span><br>    <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">NULL</span> || current-&gt;<span class="hljs-built_in">get_key</span>() != key) &#123;<br>        <span class="hljs-comment">// 通过随机函数决定新节点的层级高度</span><br>        <span class="hljs-type">int</span> random_level = <span class="hljs-built_in">get_random_level</span>();<br>        <span class="hljs-comment">// 如果新节点的层级超出了跳表的当前最高层级</span><br>        <span class="hljs-keyword">if</span> (random_level &gt; _skip_list_level) &#123;<br>            <span class="hljs-comment">// 对所有新的更高层级，将头节点设置为它们的前驱节点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = _skip_list_level + <span class="hljs-number">1</span>; i &lt;= random_level; i++) &#123;<br>                update[i] = _header;<br>            &#125;<br>            <span class="hljs-comment">// 更新跳表的当前最高层级为新节点的层级</span><br>            _skip_list_level = random_level;<br>            <span class="hljs-comment">// 原来是在这里更新了跳表的当前最高层级，初始化的时候是0</span><br>        &#125;<span class="hljs-comment">//--插入节点的核心逻辑。</span><br>        <br>        Node&lt;K, V&gt; *inserted_node = <span class="hljs-built_in">create_node</span>(key, value, random_level);<br>        <span class="hljs-comment">// 在各层插入新节点，同时更新前驱节点的 forward 指针</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= random_level; i++) &#123;<br>            <span class="hljs-comment">// 新节点指向当前节点的下一个节点</span><br>            inserted_node-&gt;forward[i] = update[i]-&gt;forward[i];<br>            <span class="hljs-comment">// 当前节点的下一个节点更新为新节点</span><br>            update[i]-&gt;forward[i] = inserted_node;<br>        &#125;<br>        _element_count++;<br>    &#125;<br>    mtx.<span class="hljs-built_in">unlock</span>();<span class="hljs-comment">//释放互斥锁</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、同理，删除函数中也要加入锁："><a href="#2、同理，删除函数中也要加入锁：" class="headerlink" title="2、同理，删除函数中也要加入锁："></a>2、同理，删除函数中也要加入锁：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 删除跳表中的节点</span><br><span class="hljs-comment"> * @param key 待删除节点的 key 值</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-type">void</span> SkipList&lt;K, V&gt;::<span class="hljs-built_in">delete_element</span>(K key) &#123;<br>    mtx.<span class="hljs-built_in">lock</span>();<span class="hljs-comment">// 加互斥锁，防止多线程访问导致数据不一致</span><br>    Node&lt;K, V&gt; *current = <span class="hljs-keyword">this</span>-&gt;_header;<br>    Node&lt;K, V&gt; *update[_max_level + <span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">memset</span>(update, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(Node&lt;K, V&gt; *) * (_max_level + <span class="hljs-number">1</span>));<br><br>    <span class="hljs-comment">// 从最高层开始向下搜索待删除节点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = _skip_list_level; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">while</span> (current-&gt;forward[i] != <span class="hljs-literal">NULL</span> &amp;&amp; current-&gt;forward[i]-&gt;<span class="hljs-built_in">get_key</span>() &lt; key) &#123;<br>            current = current-&gt;forward[i];<br>        &#125;<br>        update[i] = current; <span class="hljs-comment">// 记录每层待删除节点的前驱</span><br>    &#125;<br><br>    current = current-&gt;forward[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">// 确认找到了待删除的节点</span><br>    <span class="hljs-keyword">if</span> (current != <span class="hljs-literal">NULL</span> &amp;&amp; current-&gt;<span class="hljs-built_in">get_key</span>() == key) &#123;<br>        <span class="hljs-comment">// 逐层更新指针，移除节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= _skip_list_level; i++) &#123;<br>            <span class="hljs-keyword">if</span> (update[i]-&gt;forward[i] != current) <span class="hljs-keyword">break</span>;<br>            update[i]-&gt;forward[i] = current-&gt;forward[i];<br>        &#125;<br>        <span class="hljs-comment">// 调整跳表的层级</span><br>        <span class="hljs-keyword">while</span> (_skip_list_level &gt; <span class="hljs-number">0</span> &amp;&amp; _header-&gt;forward[_skip_list_level] == <span class="hljs-literal">NULL</span>) &#123;<br>            _skip_list_level--;<br>        &#125;<span class="hljs-comment">// while循环里的判断条件是什么含义</span><br>        <span class="hljs-keyword">delete</span> current; <span class="hljs-comment">// 释放节点占用的内存</span><br>        _element_count--; <span class="hljs-comment">// 节点计数减一</span><br>    &#125;<br>    mtx.<span class="hljs-built_in">unlock</span>();<span class="hljs-comment">// 释放锁</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3、综合形成的skiplist-h完整代码如下所示："><a href="#3、综合形成的skiplist-h完整代码如下所示：" class="headerlink" title="3、综合形成的skiplist.h完整代码如下所示："></a>3、综合形成的skiplist.h完整代码如下所示：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span>  <span class="hljs-comment">// 随机函数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span>    <span class="hljs-comment">// 引入互斥锁</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span>  <span class="hljs-comment">// 引入文件操作</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STORE_FILE <span class="hljs-string">&quot;store/dumpFile&quot;</span>  <span class="hljs-comment">// 存储文件路径</span></span><br>std::mutex mtx; <span class="hljs-comment">// 定义互斥锁</span><br>std::string delimiter = <span class="hljs-string">&quot;:&quot;</span>;<span class="hljs-comment">// 定义冒号的宏</span><br><span class="hljs-comment">// 节点类定义</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K,<span class="hljs-keyword">typename</span> V&gt; <span class="hljs-comment">// 函数模版</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Node</span>()&#123;&#125;;<span class="hljs-comment">//默认构造函数</span><br>    <span class="hljs-built_in">Node</span>(K k,V v,<span class="hljs-type">int</span>);<span class="hljs-comment">// 构造函数</span><br>    ~<span class="hljs-built_in">Node</span>();<span class="hljs-comment">// 析构函数</span><br>    <span class="hljs-function">K <span class="hljs-title">get_key</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<span class="hljs-comment">// 获取键</span><br>    <span class="hljs-function">V <span class="hljs-title">get_value</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<span class="hljs-comment">// 获取键值</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_value</span><span class="hljs-params">(V)</span></span>;<span class="hljs-comment">//设置key对应的value</span><br>    Node&lt;K,V&gt; **forward;<span class="hljs-comment">// 在C++中，二维指针等价于指针数组。要明确forward数组的含义，标识每一层的下一个节点</span><br>    <span class="hljs-type">int</span> node_level;<span class="hljs-comment">//用来标识当前节点在跳表中的层级位置</span><br><span class="hljs-keyword">private</span>:<br>    K key; <span class="hljs-comment">//存储键</span><br>    V value; <span class="hljs-comment">// 存储键值</span><br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K,<span class="hljs-keyword">typename</span> V&gt;<br>Node&lt;K,V&gt;::<span class="hljs-built_in">Node</span>(<span class="hljs-type">const</span> K k,<span class="hljs-type">const</span> V v,<span class="hljs-type">int</span> level)&#123;<br>    <span class="hljs-keyword">this</span>-&gt;key = k;<br>    <span class="hljs-keyword">this</span>-&gt;value =v;<br>    <span class="hljs-keyword">this</span>-&gt;node_level =level;<br>    <span class="hljs-keyword">this</span>-&gt;forward = <span class="hljs-keyword">new</span> Node&lt;K,V&gt; *[level+<span class="hljs-number">1</span>];<span class="hljs-comment">// 定义当前节点的forward数组的大小，下标从0开始，所以动态分配的大小为level+1</span><br>    <span class="hljs-built_in">memset</span>(<span class="hljs-keyword">this</span>-&gt;forward,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(Node&lt;K,V&gt;*) *(level+<span class="hljs-number">1</span>));<span class="hljs-comment">// 这行代码啥意思：将分配的指针数组初始化为零</span><br><span class="hljs-comment">//memset 是一个标准库函数，定义在 &lt;cstring&gt; 头文件中，用于将某一块内存中的所有字节都设置为指定的值 </span><br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K,<span class="hljs-keyword">typename</span> V&gt;<br>Node&lt;K,V&gt;::~<span class="hljs-built_in">Node</span>()&#123;<span class="hljs-comment">//析构函数实现</span><br>    <span class="hljs-keyword">delete</span>[] forward;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K,<span class="hljs-keyword">typename</span> V&gt;<br>K Node&lt;K,V&gt;::<span class="hljs-built_in">get_key</span>() <span class="hljs-type">const</span>&#123;<span class="hljs-comment">// 获取键函数实现</span><br>    <span class="hljs-keyword">return</span> key;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K,<span class="hljs-keyword">typename</span> V&gt;<br>V Node&lt;K,V&gt;::<span class="hljs-built_in">get_value</span>() <span class="hljs-type">const</span>&#123;<span class="hljs-comment">// 获取键值函数实现</span><br>    <span class="hljs-keyword">return</span> value;<br>&#125;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-type">void</span> Node&lt;K, V&gt;::<span class="hljs-built_in">set_value</span>(V value) &#123;<span class="hljs-comment">// 这里不用加const！编译没通过，原因？</span><br>    <span class="hljs-keyword">this</span>-&gt;value = value;<br>&#125;;<br><span class="hljs-comment">// 跳表类定义</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SkipList</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SkipList</span>(<span class="hljs-type">int</span>);  <span class="hljs-comment">// 构造函数</span><br>    ~<span class="hljs-built_in">SkipList</span>();  <span class="hljs-comment">// 析构函数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_random_level</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 生成随机层级</span><br>    <span class="hljs-function">Node&lt;K,V&gt; *<span class="hljs-title">create_node</span><span class="hljs-params">(K, V, <span class="hljs-type">int</span>)</span></span>;  <span class="hljs-comment">// 创建新节点</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">insert_element</span><span class="hljs-params">(K, V)</span></span>;  <span class="hljs-comment">// 插入元素</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">search_element</span><span class="hljs-params">(K)</span></span>;  <span class="hljs-comment">// 搜索元素</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">delete_element</span><span class="hljs-params">(K)</span></span>;<span class="hljs-comment">//删除元素</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display_list</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 跳表展示</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dump_file</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//文件落盘</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">load_file</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//加载文件到跳表</span><br>    <span class="hljs-comment">//递归删除节点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(Node&lt;K,V&gt;*)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 获取跳表大小（节点数量）</span><br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_key_value_from_string</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; str, std::string* key, std::string* value)</span></span>;<span class="hljs-comment">//将字符串分割为键值</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_valid_string</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; str)</span></span>;<span class="hljs-comment">// 判断字符是否有效</span><br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> _max_level;  <span class="hljs-comment">// 最大层级</span><br>    <span class="hljs-type">int</span> _skip_list_level;  <span class="hljs-comment">// 当前层级</span><br>    Node&lt;K,V&gt; *_header;  <span class="hljs-comment">// 头节点</span><br>    <span class="hljs-type">int</span> _element_count;  <span class="hljs-comment">// 节点数量</span><br>    <span class="hljs-comment">// 文件操作</span><br>    std::ofstream _file_writer;<br>    std::ifstream _file_reader;<br>&#125;;<br><br><span class="hljs-comment">// 跳表的构造函数：设置最大层级、初始化成员变量、创建头结点</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K,<span class="hljs-keyword">typename</span> V&gt;<br>SkipList&lt;K,V&gt;::<span class="hljs-built_in">SkipList</span>(<span class="hljs-type">int</span> max_level)&#123;<br>    <span class="hljs-keyword">this</span>-&gt;_max_level = max_level;<span class="hljs-comment">//设置最大层级等于传进来的预设值</span><br>    <span class="hljs-keyword">this</span>-&gt;_skip_list_level = <span class="hljs-number">0</span>;<span class="hljs-comment">//初始化当前层级为0</span><br>    <span class="hljs-keyword">this</span>-&gt;_element_count = <span class="hljs-number">0</span>;<span class="hljs-comment">//初始化节点数量为0</span><br>    K k;<span class="hljs-comment">//默认键</span><br>    V v;<span class="hljs-comment">// 默认键值</span><br>    <span class="hljs-comment">//创建头结点，并初始化为默认值</span><br>    <span class="hljs-keyword">this</span>-&gt;_header = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>&lt;K,V&gt; (k,v,_max_level);<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt; <br>SkipList&lt;K, V&gt;::~<span class="hljs-built_in">SkipList</span>() &#123;<span class="hljs-comment">//析构函数</span><br><br>    <span class="hljs-keyword">if</span> (_file_writer.<span class="hljs-built_in">is_open</span>()) &#123;<br>        _file_writer.<span class="hljs-built_in">close</span>();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (_file_reader.<span class="hljs-built_in">is_open</span>()) &#123;<br>        _file_reader.<span class="hljs-built_in">close</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//递归删除跳表链条</span><br>    <span class="hljs-keyword">if</span>(_header-&gt;forward[<span class="hljs-number">0</span>]!=<span class="hljs-literal">nullptr</span>)&#123;<br>        <span class="hljs-built_in">clear</span>(_header-&gt;forward[<span class="hljs-number">0</span>]);<br>    &#125;<br>    <span class="hljs-built_in">delete</span>(_header);<br>    <br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-type">void</span> SkipList&lt;K, V&gt;::<span class="hljs-built_in">clear</span>(Node&lt;K, V&gt; * cur)<br>&#123;<br>    <span class="hljs-keyword">if</span>(cur-&gt;forward[<span class="hljs-number">0</span>]!=<span class="hljs-literal">nullptr</span>)&#123;<br>        <span class="hljs-built_in">clear</span>(cur-&gt;forward[<span class="hljs-number">0</span>]);<br>    &#125;<br>    <span class="hljs-built_in">delete</span>(cur);<br>&#125;<br><span class="hljs-comment">// 获取跳表的随机层数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-type">int</span> SkipList&lt;K, V&gt;::<span class="hljs-built_in">get_random_level</span>() &#123;<br>   <span class="hljs-comment">// 初始化层级：每个节点至少出现在第一层。</span><br>   <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<br>   <span class="hljs-comment">// 随机层级增加：使用 rand() % 2 实现抛硬币效果，决定是否升层。</span><br>   <span class="hljs-keyword">while</span> (<span class="hljs-built_in">rand</span>() % <span class="hljs-number">2</span>) &#123;<br>      k++;<br>   &#125;<br>   <span class="hljs-comment">// 层级限制：确保节点层级不超过最大值 _max_level。</span><br>   k = (k &lt; _max_level) ? k : _max_level;<br>   <span class="hljs-comment">// 返回层级：返回确定的层级值，决定节点插入的层。</span><br>   <span class="hljs-keyword">return</span> k;<br>&#125;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K,<span class="hljs-keyword">typename</span> V&gt;<br>Node&lt;K,V&gt; *SkipList&lt;K,V&gt;::<span class="hljs-built_in">create_node</span>(<span class="hljs-type">const</span> K k,<span class="hljs-type">const</span> V v,<span class="hljs-type">int</span> level)&#123;<br>    Node&lt;K,V&gt; *n = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>&lt;K,V&gt;(k,v,level);<span class="hljs-comment">// 实例化新节点，并为其分配指定的键、值、和层级</span><br>    <span class="hljs-keyword">return</span> n;<span class="hljs-comment">//返回创建的新节点</span><br>&#125;<br><span class="hljs-comment">//实现搜索节点功能</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K,<span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-type">bool</span> SkipList&lt;K,V&gt;::<span class="hljs-built_in">search_element</span>(K key)&#123;<span class="hljs-comment">//返回的bool值提供判断</span><br>    <span class="hljs-comment">//定义一个指针current，初始化为跳表的头结点_header</span><br>    Node&lt;K,V&gt; *current = _header;<br>    <span class="hljs-comment">// 从跳表的最高层开始搜素</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = _skip_list_level;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-comment">//遍历当前层级，直到下一个节点的键值大于或等于待查找的键值</span><br>        <span class="hljs-keyword">while</span>(current-&gt;forward[i] &amp;&amp; current-&gt;forward[i]-&gt;<span class="hljs-built_in">get_key</span>() &lt; key)&#123;<br>           <span class="hljs-comment">// 移动到当前层的下一个节点</span><br>           current = current-&gt;forward[i];<br>        &#125;<br>        <span class="hljs-comment">//当前节点的下一个节点的键值大于待查找的键值时，进行下沉到下一层</span><br>        <span class="hljs-comment">// 下沉的操作通过循环i--实现</span><br>    &#125;<br>    <span class="hljs-comment">// 检查当前层（最底层）的下一个节点的键值是否为待查找的键值</span><br>    current = current-&gt;forward[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">if</span>(current &amp;&amp; current-&gt;<span class="hljs-built_in">get_key</span>() == key)&#123;<br>        <span class="hljs-comment">//如果找到匹配的键值，返回 true</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>     <span class="hljs-comment">// 如果没有找到匹配的键值，返回 false</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-type">int</span> SkipList&lt;K, V&gt;::<span class="hljs-built_in">insert_element</span>(<span class="hljs-type">const</span> K key, <span class="hljs-type">const</span> V value) &#123;<br>    mtx.<span class="hljs-built_in">lock</span>();<span class="hljs-comment">// 加互斥锁，防止多线程访问导致数据不一致</span><br>    Node&lt;K, V&gt; *current = <span class="hljs-keyword">this</span>-&gt;_header;<br>    <span class="hljs-comment">// 用于在各层更新指针的数组</span><br>    Node&lt;K, V&gt; *update[_max_level + <span class="hljs-number">1</span>];  <span class="hljs-comment">// 用于记录每层中待更新指针的节点</span><br>    <span class="hljs-built_in">memset</span>(update, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(Node&lt;K, V&gt; *) * (_max_level + <span class="hljs-number">1</span>));<br><br>    <span class="hljs-comment">// 从最高层向下搜索插入位置</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = _skip_list_level; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// 寻找当前层中最接近且小于 key 的节点</span><br>        <span class="hljs-keyword">while</span> (current-&gt;forward[i] != <span class="hljs-literal">NULL</span> &amp;&amp; current-&gt;forward[i]-&gt;<span class="hljs-built_in">get_key</span>() &lt; key) &#123;<br>            current = current-&gt;forward[i]; <span class="hljs-comment">// 移动到下一节点</span><br>        &#125;<span class="hljs-comment">// 一旦大于key值，跳出循环，此时current就是待插入节点的前置节点</span><br>        <span class="hljs-comment">// 保存每层中该节点，以便后续插入时更新指针</span><br>        update[i] = current;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 移动到最底层的下一节点，准备插入操作</span><br>    current = current-&gt;forward[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">// 检查待插入的键是否已存在</span><br>    <span class="hljs-keyword">if</span> (current != <span class="hljs-literal">NULL</span> &amp;&amp; current-&gt;<span class="hljs-built_in">get_key</span>() == key) &#123;<br>        <span class="hljs-comment">// 键已存在，取消插入</span><br>        mtx.<span class="hljs-built_in">unlock</span>();<span class="hljs-comment">//在return前提前解锁，释放互斥锁</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">// 判断==1标识插入失败，键已存在。</span><br>    &#125;<br>    <span class="hljs-comment">// 检查待插入的键是否已存在于跳表中</span><br>    <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">NULL</span> || current-&gt;<span class="hljs-built_in">get_key</span>() != key) &#123;<br>        <span class="hljs-comment">// 通过随机函数决定新节点的层级高度</span><br>        <span class="hljs-type">int</span> random_level = <span class="hljs-built_in">get_random_level</span>();<br>        <span class="hljs-comment">// 如果新节点的层级超出了跳表的当前最高层级</span><br>        <span class="hljs-keyword">if</span> (random_level &gt; _skip_list_level) &#123;<br>            <span class="hljs-comment">// 对所有新的更高层级，将头节点设置为它们的前驱节点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = _skip_list_level + <span class="hljs-number">1</span>; i &lt;= random_level; i++) &#123;<br>                update[i] = _header;<br>            &#125;<br>            <span class="hljs-comment">// 更新跳表的当前最高层级为新节点的层级</span><br>            _skip_list_level = random_level;<br>            <span class="hljs-comment">// 原来是在这里更新了跳表的当前最高层级，初始化的时候是0</span><br>        &#125;<span class="hljs-comment">//--插入节点的核心逻辑。</span><br>        <br>        Node&lt;K, V&gt; *inserted_node = <span class="hljs-built_in">create_node</span>(key, value, random_level);<br>        <span class="hljs-comment">// 在各层插入新节点，同时更新前驱节点的 forward 指针</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= random_level; i++) &#123;<br>            <span class="hljs-comment">// 新节点指向当前节点的下一个节点</span><br>            inserted_node-&gt;forward[i] = update[i]-&gt;forward[i];<br>            <span class="hljs-comment">// 当前节点的下一个节点更新为新节点</span><br>            update[i]-&gt;forward[i] = inserted_node;<br>        &#125;<br>        _element_count++;<br>    &#125;<br>    mtx.<span class="hljs-built_in">unlock</span>();<span class="hljs-comment">//释放互斥锁</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-type">void</span> SkipList&lt;K, V&gt;::<span class="hljs-built_in">delete_element</span>(K key) &#123;<br>    mtx.<span class="hljs-built_in">lock</span>();<span class="hljs-comment">// 加互斥锁，防止多线程访问导致数据不一致</span><br>    Node&lt;K, V&gt; *current = <span class="hljs-keyword">this</span>-&gt;_header;<br>    Node&lt;K, V&gt; *update[_max_level + <span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">memset</span>(update, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(Node&lt;K, V&gt; *) * (_max_level + <span class="hljs-number">1</span>));<br><br>    <span class="hljs-comment">// 从最高层开始向下搜索待删除节点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = _skip_list_level; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">while</span> (current-&gt;forward[i] != <span class="hljs-literal">NULL</span> &amp;&amp; current-&gt;forward[i]-&gt;<span class="hljs-built_in">get_key</span>() &lt; key) &#123;<br>            current = current-&gt;forward[i];<br>        &#125;<br>        update[i] = current; <span class="hljs-comment">// 记录每层待删除节点的前驱</span><br>    &#125;<br><br>    current = current-&gt;forward[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">// 确认找到了待删除的节点</span><br>    <span class="hljs-keyword">if</span> (current != <span class="hljs-literal">NULL</span> &amp;&amp; current-&gt;<span class="hljs-built_in">get_key</span>() == key) &#123;<br>        <span class="hljs-comment">// 逐层更新指针，移除节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= _skip_list_level; i++) &#123;<br>            <span class="hljs-keyword">if</span> (update[i]-&gt;forward[i] != current) <span class="hljs-keyword">break</span>;<br>            update[i]-&gt;forward[i] = current-&gt;forward[i];<br>        &#125;<br>        <span class="hljs-comment">// 调整跳表的层级</span><br>        <span class="hljs-keyword">while</span> (_skip_list_level &gt; <span class="hljs-number">0</span> &amp;&amp; _header-&gt;forward[_skip_list_level] == <span class="hljs-literal">NULL</span>) &#123;<br>            _skip_list_level--;<br>        &#125;<span class="hljs-comment">// while循环里的判断条件是什么含义：你逐级删除某个key，你的最大层的头结点指向空，因为层级减少了。</span><br>        <span class="hljs-keyword">delete</span> current; <span class="hljs-comment">// 释放节点占用的内存</span><br>        _element_count--; <span class="hljs-comment">// 节点计数减一</span><br>    &#125;<br>    mtx.<span class="hljs-built_in">unlock</span>();<span class="hljs-comment">// 释放锁</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-type">void</span> SkipList&lt;K, V&gt;::<span class="hljs-built_in">dump_file</span>() &#123;<span class="hljs-comment">// 文件落盘</span><br>    _file_writer.<span class="hljs-built_in">open</span>(STORE_FILE); <span class="hljs-comment">// 打开文件</span><br>    Node&lt;K, V&gt;* node = <span class="hljs-keyword">this</span>-&gt;_header-&gt;forward[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 从头节点开始遍历</span><br><br>    <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>        _file_writer &lt;&lt; node-&gt;<span class="hljs-built_in">get_key</span>() &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; node-&gt;<span class="hljs-built_in">get_value</span>() &lt;&lt; <span class="hljs-string">&quot;;\n&quot;</span>; <span class="hljs-comment">// 写入键值对</span><br>        node = node-&gt;forward[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 移动到下一个节点</span><br>    &#125;<br><br>    _file_writer.<span class="hljs-built_in">flush</span>(); <span class="hljs-comment">// 刷新缓冲区，确保数据完全写入</span><br>    _file_writer.<span class="hljs-built_in">close</span>(); <span class="hljs-comment">// 关闭文件</span><br>    <span class="hljs-keyword">return</span>；<br>&#125;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt; <br><span class="hljs-type">int</span> SkipList&lt;K, V&gt;::<span class="hljs-built_in">size</span>() &#123; <br>    <span class="hljs-keyword">return</span> _element_count;<br>&#125;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-type">void</span> SkipList&lt;K, V&gt;::<span class="hljs-built_in">get_key_value_from_string</span>(<span class="hljs-type">const</span> std::string&amp; str, std::string* key, std::string* value) &#123;<br><br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">is_valid_string</span>(str)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    *key = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, str.<span class="hljs-built_in">find</span>(delimiter));<br>    *value = str.<span class="hljs-built_in">substr</span>(str.<span class="hljs-built_in">find</span>(delimiter)+<span class="hljs-number">1</span>, str.<span class="hljs-built_in">length</span>());<br>&#125;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-type">bool</span> SkipList&lt;K, V&gt;::<span class="hljs-built_in">is_valid_string</span>(<span class="hljs-type">const</span> std::string&amp; str) &#123;<br><br>    <span class="hljs-keyword">if</span> (str.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (str.<span class="hljs-built_in">find</span>(delimiter) == std::string::npos) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">// Load data from disk</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-type">void</span> SkipList&lt;K, V&gt;::<span class="hljs-built_in">load_file</span>() &#123;<br>    _file_reader.<span class="hljs-built_in">open</span>(STORE_FILE);<br>    std::string line;<br>    std::string *key = <span class="hljs-keyword">new</span> std::<span class="hljs-built_in">string</span>();<br>    std::string *value = <span class="hljs-keyword">new</span> std::<span class="hljs-built_in">string</span>();<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(_file_reader, line)) &#123;<br>        <span class="hljs-built_in">get_key_value_from_string</span>(line, key, value);<br>        <span class="hljs-keyword">if</span> (key-&gt;<span class="hljs-built_in">empty</span>() || value-&gt;<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">// Define key as int type</span><br>        <span class="hljs-built_in">insert_element</span>(<span class="hljs-built_in">stoi</span>(*key), *value);<span class="hljs-comment">// 将key value转化成整形</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;key:&quot;</span> &lt;&lt; *key &lt;&lt; <span class="hljs-string">&quot;value:&quot;</span> &lt;&lt; *value &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">delete</span> key;<br>    <span class="hljs-keyword">delete</span> value;<br>    _file_reader.<span class="hljs-built_in">close</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h1><p>将 “模块合并” 章节创建的 skiplist.h 包含到当前压力测试程序中。</p><p>测试程序主要的内容为编写在随机读写下，测试项目每秒可处理写请求数，和每秒可处理读请求数</p><p>具体可以通过多线程(pthread)以及计时(chrono)来执行插入和检索操作。</p><p>压力测试文件的内容如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 引入必要的头文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span> <span class="hljs-comment">// 用于输入输出流</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span> <span class="hljs-comment">// 用于高精度时间测量</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span> <span class="hljs-comment">// 包含一些通用的工具函数，如随机数生成</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span> <span class="hljs-comment">// 用于多线程编程</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span> <span class="hljs-comment">// 用于时间处理函数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;./skiplist.h&quot;</span> <span class="hljs-comment">// 引入自定义的跳表实现</span></span><br><br><span class="hljs-comment">// 定义宏常量</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NUM_THREADS 1 <span class="hljs-comment">// 线程数量</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TEST_COUNT 100000 <span class="hljs-comment">// 测试用的数据量大小</span></span><br><span class="hljs-function">SkipList&lt;<span class="hljs-type">int</span>, std::string&gt; <span class="hljs-title">skipList</span><span class="hljs-params">(<span class="hljs-number">18</span>)</span></span>; <span class="hljs-comment">// 创建一个最大层级为18的跳表实例</span><br><br><span class="hljs-comment">// 插入元素的线程函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">insertElement</span><span class="hljs-params">(<span class="hljs-type">void</span>* threadid)</span> </span>&#123;<br>    <span class="hljs-type">long</span> tid; <span class="hljs-comment">// 线程ID</span><br>    tid = (<span class="hljs-type">long</span>)threadid; <span class="hljs-comment">// 将void*类型的线程ID转换为long型</span><br>    std::cout &lt;&lt; tid &lt;&lt; std::endl; <span class="hljs-comment">// 输出线程ID</span><br>    <span class="hljs-type">int</span> tmp = TEST_COUNT/NUM_THREADS; <span class="hljs-comment">// 计算每个线程应该插入的元素数量</span><br>    <span class="hljs-comment">// 循环插入元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=tid*tmp, count=<span class="hljs-number">0</span>; count&lt;tmp; i++) &#123;<br>        count++;<br>        skipList.<span class="hljs-built_in">insert_element</span>(<span class="hljs-built_in">rand</span>() % TEST_COUNT, <span class="hljs-string">&quot;a&quot;</span>); <span class="hljs-comment">// 随机生成一个键，并插入带有&quot;a&quot;的元素</span><br>    &#125;<br>    <span class="hljs-built_in">pthread_exit</span>(<span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 退出线程</span><br>&#125;<br><br><span class="hljs-comment">// 检索元素的线程函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">getElement</span><span class="hljs-params">(<span class="hljs-type">void</span>* threadid)</span> </span>&#123;<br>    <span class="hljs-type">long</span> tid; <span class="hljs-comment">// 线程ID</span><br>    tid = (<span class="hljs-type">long</span>)threadid; <span class="hljs-comment">// 将void*类型的线程ID转换为long型</span><br>    std::cout &lt;&lt; tid &lt;&lt; std::endl; <span class="hljs-comment">// 输出线程ID</span><br>    <span class="hljs-type">int</span> tmp = TEST_COUNT/NUM_THREADS; <span class="hljs-comment">// 计算每个线程应该检索的元素数量</span><br>    <span class="hljs-comment">// 循环检索元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=tid*tmp, count=<span class="hljs-number">0</span>; count&lt;tmp; i++) &#123;<br>        count++;<br>        skipList.<span class="hljs-built_in">search_element</span>(<span class="hljs-built_in">rand</span>() % TEST_COUNT); <span class="hljs-comment">// 随机生成一个键，并尝试检索</span><br>    &#125;<br>    <span class="hljs-built_in">pthread_exit</span>(<span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 退出线程</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>)); <span class="hljs-comment">// 初始化随机数生成器</span><br>    &#123;<br>        <span class="hljs-type">pthread_t</span> threads[NUM_THREADS]; <span class="hljs-comment">// 定义线程数组</span><br>        <span class="hljs-type">int</span> rc; <span class="hljs-comment">// 用于接收pthread_create的返回值</span><br>        <span class="hljs-type">int</span> i; <span class="hljs-comment">// 循环计数器</span><br><br>        <span class="hljs-keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>(); <span class="hljs-comment">// 开始计时</span><br><br>        <span class="hljs-comment">// 创建插入元素的线程</span><br>        <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>; i &lt; NUM_THREADS; i++ ) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;main() : creating thread, &quot;</span> &lt;&lt; i &lt;&lt; std::endl;<br>            rc = <span class="hljs-built_in">pthread_create</span>(&amp;threads[i], <span class="hljs-literal">NULL</span>, insertElement, (<span class="hljs-type">void</span> *)i); <span class="hljs-comment">// 创建线程</span><br><br>            <span class="hljs-keyword">if</span> (rc) &#123;<br>                std::cout &lt;&lt; <span class="hljs-string">&quot;Error:unable to create thread,&quot;</span> &lt;&lt; rc &lt;&lt; std::endl;<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>); <span class="hljs-comment">// 如果线程创建失败，退出程序</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">void</span> *ret; <span class="hljs-comment">// 用于接收pthread_join的返回值</span><br>        <span class="hljs-comment">// 等待所有插入线程完成</span><br>        <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>; i &lt; NUM_THREADS; i++ ) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_join</span>(threads[i], &amp;ret) != <span class="hljs-number">0</span> )  &#123;<br>                <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;pthread_create() error&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// 如果线程等待失败，退出程序</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">auto</span> finish = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>(); <span class="hljs-comment">// 结束计时</span><br>        std::chrono::duration&lt;<span class="hljs-type">double</span>&gt; elapsed = finish - start; <span class="hljs-comment">// 计算耗时</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;insert elapsed:&quot;</span> &lt;&lt; elapsed.<span class="hljs-built_in">count</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 输出插入操作耗时</span><br>    &#125;<br><br>    <span class="hljs-comment">// 下面的代码块与上面类似，用于创建并管理检索操作的线程</span><br>    &#123;<br>        <span class="hljs-type">pthread_t</span> threads[NUM_THREADS];<br>        <span class="hljs-type">int</span> rc;<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br><br>        <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>; i &lt; NUM_THREADS; i++ ) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;main() : creating thread, &quot;</span> &lt;&lt; i &lt;&lt; std::endl;<br>            rc = <span class="hljs-built_in">pthread_create</span>(&amp;threads[i], <span class="hljs-literal">NULL</span>, getElement, (<span class="hljs-type">void</span> *)i);<br><br>            <span class="hljs-keyword">if</span> (rc) &#123;<br>                std::cout &lt;&lt; <span class="hljs-string">&quot;Error:unable to create thread,&quot;</span> &lt;&lt; rc &lt;&lt; std::endl;<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">void</span> *ret;<br>        <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>; i &lt; NUM_THREADS; i++ ) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_join</span>(threads[i], &amp;ret) != <span class="hljs-number">0</span> )  &#123;<br>                <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;pthread_create() error&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">3</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">auto</span> finish = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>        std::chrono::duration&lt;<span class="hljs-type">double</span>&gt; elapsed = finish - start;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;get elapsed:&quot;</span> &lt;&lt; elapsed.<span class="hljs-built_in">count</span>() &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-built_in">pthread_exit</span>(<span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 主线程退出</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;skiplist.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FILE_PATH <span class="hljs-string">&quot;./store/dumpFile&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">// 键值中的key用int型，如果用其他类型，需要自定义比较函数</span><br>    <span class="hljs-comment">// 而且如果修改key的类型，同时需要修改skipList.load_file函数</span><br>    <span class="hljs-function">SkipList&lt;<span class="hljs-type">int</span>, std::string&gt; <span class="hljs-title">skipList</span><span class="hljs-params">(<span class="hljs-number">6</span>)</span></span>;<br>skipList.<span class="hljs-built_in">insert_element</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;KV&quot;</span>); <br>skipList.<span class="hljs-built_in">insert_element</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;存储&quot;</span>); <br>skipList.<span class="hljs-built_in">insert_element</span>(<span class="hljs-number">7</span>, <span class="hljs-string">&quot;项目&quot;</span>); <br>skipList.<span class="hljs-built_in">insert_element</span>(<span class="hljs-number">8</span>, <span class="hljs-string">&quot;代码测试&quot;</span>); <br>skipList.<span class="hljs-built_in">insert_element</span>(<span class="hljs-number">9</span>, <span class="hljs-string">&quot;使用&quot;</span>); <br>skipList.<span class="hljs-built_in">insert_element</span>(<span class="hljs-number">19</span>, <span class="hljs-string">&quot;简介&quot;</span>); <br>skipList.<span class="hljs-built_in">insert_element</span>(<span class="hljs-number">19</span>, <span class="hljs-string">&quot;主函数&quot;</span>); <br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;skipList size:&quot;</span> &lt;&lt; skipList.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl;<br><br>    skipList.<span class="hljs-built_in">dump_file</span>();<br><br>    <span class="hljs-comment">// skipList.load_file();</span><br><br>    skipList.<span class="hljs-built_in">search_element</span>(<span class="hljs-number">9</span>);<br>    skipList.<span class="hljs-built_in">search_element</span>(<span class="hljs-number">18</span>);<br><br><br>    skipList.<span class="hljs-built_in">display_list</span>();<br><br>    skipList.<span class="hljs-built_in">delete_element</span>(<span class="hljs-number">3</span>);<br>    skipList.<span class="hljs-built_in">delete_element</span>(<span class="hljs-number">7</span>);<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;skipList size:&quot;</span> &lt;&lt; skipList.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl;<br><br>    skipList.<span class="hljs-built_in">display_list</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="项目运行方式"><a href="#项目运行方式" class="headerlink" title="项目运行方式"></a>项目运行方式</h1><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">make            <span class="hljs-regexp">//</span> complie demo main.cpp<br>.<span class="hljs-regexp">/bin/m</span>ain      <span class="hljs-regexp">//</span> run <br></code></pre></td></tr></table></figure><p>如果想自己写程序使用这个kv存储引擎，只需要在你的CPP文件中include skiplist.h 就可以了。</p><p>可以运行如下脚本测试kv存储引擎的性能（当然你可以根据自己的需求进行修改）</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">sh </span>stress_test_start.<span class="hljs-keyword">sh </span><br></code></pre></td></tr></table></figure><h1 id="面试相关"><a href="#面试相关" class="headerlink" title="面试相关"></a>面试相关</h1><h2 id="1、跳表的原理和特点是什么？"><a href="#1、跳表的原理和特点是什么？" class="headerlink" title="1、跳表的原理和特点是什么？"></a>1、<strong>跳表的原理和特点是什么？</strong></h2><ul><li><strong>解答：</strong> 跳表是一种数据结构，类似于有序链表，但它通过在链表中添加多级索引来加速查找。每个节点包含多个指针，允许在不必遍历整个链表的情况下快速定位节点。跳表的特点包括高效的查找、插入和删除操作（平均情况下是 O(log n)），相比于平衡树，跳表的实现更简单，并且不需要像平衡树那样维护平衡性</li></ul><h2 id="2、你是如何实现跳表的插入、删除和查询操作的？"><a href="#2、你是如何实现跳表的插入、删除和查询操作的？" class="headerlink" title="2、你是如何实现跳表的插入、删除和查询操作的？"></a>2、<strong>你是如何实现跳表的插入、删除和查询操作的？</strong></h2><ul><li><strong>解答：</strong> 插入操作首先需要找到要插入的位置，然后在适当的层级添加新节点，并更新相关节点的指针。删除操作需要找到要删除的节点并重新连接相关节点的指针。查询操作从顶层开始，根据节点的值逐层向下移动，直到找到目标节点或确定目标节点不存在为止。</li><li>每个节点都维护一个 forward 数组，该数组记录了<strong>该节点在每一层的下一个节点的指针</strong>。基于这个结构，利用 _header 节点和 _skip_list_level（记录跳表实际最高层级的变量）作为起点，我们可以从跳表的最顶层开始进行搜索。</li></ul><h2 id="3、你是如何处理持久化和恢复数据的？"><a href="#3、你是如何处理持久化和恢复数据的？" class="headerlink" title="3、你是如何处理持久化和恢复数据的？"></a>3、<strong>你是如何处理持久化和恢复数据的？</strong></h2><ul><li><strong>解答：</strong> 持久化数据通常涉及将内存中的数据写入磁盘文件，可以通过序列化数据结构并将其写入文件来实现。恢复数据则需要读取磁盘文件，并将其反序列化为内存中的数据结构。在实现过程中，需要考虑数据的一致性和性能。</li></ul><h2 id="4、你是如何测试你的数据库的正确性和性能的？"><a href="#4、你是如何测试你的数据库的正确性和性能的？" class="headerlink" title="4、你是如何测试你的数据库的正确性和性能的？"></a>4、<strong>你是如何测试你的数据库的正确性和性能的？</strong></h2><ul><li><strong>解答：</strong> 测试是保证数据库正确性和性能的关键。你可以解释你使用的测试方法，包括单元测试、集成测试、性能测试和压力测试等，并且说明你如何设计测试用例来覆盖不同的情况和边界条件。</li></ul><h2 id="5、你的数据库是如何处理并发访问的？"><a href="#5、你的数据库是如何处理并发访问的？" class="headerlink" title="5、你的数据库是如何处理并发访问的？"></a>5、<strong>你的数据库是如何处理并发访问的？</strong></h2><ul><li><strong>解答：</strong> 跳表的并发访问可以通过加锁来实现，确保在修改数据结构时只有一个线程访问。也可以考虑使用无锁数据结构或者基于CAS（Compare and Swap）的并发控制技术来提高并发性能。</li></ul><h2 id="结合KV存储引擎到水下机器人岸基操作界面的软件中可以为系统增加很多优势和功能："><a href="#结合KV存储引擎到水下机器人岸基操作界面的软件中可以为系统增加很多优势和功能：" class="headerlink" title="结合KV存储引擎到水下机器人岸基操作界面的软件中可以为系统增加很多优势和功能："></a><strong>结合KV存储引擎到水下机器人岸基操作界面的软件中可以为系统增加很多优势和功能：</strong></h2><ol><li><strong>实时数据存储与查询：</strong> 使用KV存储引擎可以方便地存储水下机器人的实时数据，例如传感器数据、位置信息等。你可以将这些数据存储在KV数据库中，并在岸基界面软件中实现实时查询和展示功能，以便用户随时了解机器人的状态。</li><li><strong>配置参数管理：</strong> 将水下机器人的配置参数存储在KV数据库中，可以方便地进行管理和调整。用户可以通过岸基界面软件直接修改参数，并将其保存到KV数据库中，以便下次使用时快速加载。</li><li><strong>日志记录与分析：</strong> 使用KV数据库可以方便地记录水下机器人的运行日志和事件数据。你可以将日志数据存储在KV数据库中，并在岸基界面软件中实现日志查看和分析功能，以便用户了解机器人的历史运行情况和发生的事件。</li><li><strong>任务管理与调度：</strong> 将水下机器人的任务信息存储在KV数据库中，可以方便地进行任务管理和调度。你可以实现任务列表的增删改查功能，并在岸基界面软件中提供任务的可视化展示和调度功能，以便用户随时了解任务的状态和进度。</li><li><strong>数据备份与恢复：</strong> 使用KV数据库可以方便地实现数据的备份和恢复功能。你可以定期将数据库中的数据备份到文件中，并在岸基界面软件中提供数据恢复的功能，以确保数据的安全性和可靠性。</li></ol><p>综上所述，结合KV存储引擎到岸基操作界面软件中可以为水下机器人系统增加实时数据存储与查询、配置参数管理、日志记录与分析、任务管理与调度以及数据备份与恢复等功能，提升系统的可靠性、可用性和管理效率。</p><h2 id="对于上述功能，键值对类型的存储引擎是非常适用的。这是因为键值对存储引擎具有以下特点："><a href="#对于上述功能，键值对类型的存储引擎是非常适用的。这是因为键值对存储引擎具有以下特点：" class="headerlink" title="对于上述功能，键值对类型的存储引擎是非常适用的。这是因为键值对存储引擎具有以下特点："></a><strong>对于上述功能，键值对类型的存储引擎是非常适用的。这是因为键值对存储引擎具有以下特点：</strong></h2><ol><li><strong>灵活的数据结构：</strong> 键值对存储引擎通常以简单的键值对形式存储数据，这种结构非常灵活，可以存储各种类型的数据，包括实时数据、配置参数、日志记录、任务信息等。</li><li><strong>快速的数据存取：</strong> 键值对存储引擎提供了快速的数据存取能力，可以实现实时数据的存储和查询，用户可以通过键快速定位到对应的值，并进行读取、修改、删除等操作。</li><li><strong>高效的数据管理：</strong> 键值对存储引擎通常具有高效的数据管理功能，包括数据的增删改查、数据的备份与恢复等功能，可以方便地对数据进行管理和维护。</li><li><strong>适用于大规模数据：</strong> 键值对存储引擎通常能够处理大规模的数据，具有良好的扩展性和性能，可以满足水下机器人系统对大量数据的存储和处理需求。</li></ol><p>综上所述，键值对类型的存储引擎非常适用于实现水下机器人岸基操作界面软件中的实时数据存储与查询、配置参数管理、日志记录与分析、任务管理与调度以及数据备份与恢复等功能。它能够提供高效、灵活、可靠的数据存储和管理能力，帮助提升系统的性能和可用性。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>算法刷题</title>
    <link href="/2024/05/21/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    <url>/2024/05/21/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="单调栈刷题总结"><a href="#单调栈刷题总结" class="headerlink" title="单调栈刷题总结"></a>单调栈刷题总结</h1><h2 id="1、力扣题目"><a href="#1、力扣题目" class="headerlink" title="1、力扣题目"></a>1、力扣题目</h2><p>（每日温度）<a href="https://leetcode.cn/problems/daily-temperatures/">https://leetcode.cn/problems/daily-temperatures/</a></p><p>（下一个更大元素|）<a href="https://leetcode.cn/problems/next-greater-element-i/">https://leetcode.cn/problems/next-greater-element-i/</a></p><p>（下一个更大元素||）<a href="https://leetcode.cn/problems/next-greater-element-ii/">https://leetcode.cn/problems/next-greater-element-ii/</a></p><p>（接雨水）<a href="https://leetcode.cn/problems/trapping-rain-water/">https://leetcode.cn/problems/trapping-rain-water/</a></p><p>（最大矩形面积）<a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">https://leetcode.cn/problems/largest-rectangle-in-histogram/</a></p><h2 id="2、学习笔记"><a href="#2、学习笔记" class="headerlink" title="2、学习笔记"></a>2、学习笔记</h2><p>（1）什么是单调栈：利用一维数组模拟栈，按照从大到小或者从小到大的顺序，去记录遍历过的元素或者元素下标，利用空间换取时间的一种方式。</p><p>（2）什么时候适用单调栈解题：当需要寻找一个元素的左边或者右边第一个比自己大或者小的元素的时候，可以考虑使用单调栈。</p><p>（3）在使用单调栈的时候首先要明确如下几点：</p><ol><li>单调栈里存放的元素是什么？</li></ol><p>单调栈里只需要存放元素的下标i就可以了，如果需要使用对应的元素，直接T[i]就可以获取。</p><ol><li>单调栈里元素是递增呢？ 还是递减呢？</li></ol><p><strong>注意以下讲解中，顺序的描述为 从栈头到栈底的顺序</strong>，因为单纯的说从左到右或者从前到后，不说栈头朝哪个方向的话，大家一定比较懵。</p><p>这里我们要使用递增循序（再强调一下是指从栈头到栈底的顺序），因为只有递增的时候，栈里要加入一个元素i的时候，才知道栈顶元素在数组中右面第一个比栈顶元素大的元素是i。</p><p>即：如果求一个元素右边第一个更大元素，单调栈就是递增的，如果求一个元素右边第一个更小元素，单调栈就是递减的。</p><p>（4）使用单调栈主要有三个判断条件：</p><ul><li>当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况</li><li>当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况</li><li>当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况</li></ul><h2 id="3、刷题总结"><a href="#3、刷题总结" class="headerlink" title="3、刷题总结"></a>3、刷题总结</h2><h3 id="（1）每日温度："><a href="#（1）每日温度：" class="headerlink" title="（1）每日温度："></a>（1）每日温度：</h3><p>理清楚单调栈在递增情况下，三个判断条件对应的处理逻辑，本题求的是下一个比自己高的元素距离自己的距离，所以在收集结果的时候统计的是下标之间的差值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; T)</span> </span>&#123;<br>        <span class="hljs-comment">// 递增栈</span><br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(T.size(), <span class="hljs-number">0</span>)</span></span>;<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; T.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (T[i] &lt; T[st.<span class="hljs-built_in">top</span>()]) &#123;                       <span class="hljs-comment">// 情况一</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (T[i] == T[st.<span class="hljs-built_in">top</span>()]) &#123;               <span class="hljs-comment">// 情况二</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; T[i] &gt; T[st.<span class="hljs-built_in">top</span>()]) &#123; <span class="hljs-comment">// 情况三 收集结果是两个元素之间的距离</span><br>                    result[st.<span class="hljs-built_in">top</span>()] = i - st.<span class="hljs-built_in">top</span>();<br>                    st.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="（2）下一个更大元素-："><a href="#（2）下一个更大元素-：" class="headerlink" title="（2）下一个更大元素|："></a>（2）下一个更大元素|：</h3><p>相较于上面一道题目，讨论一个外壳，其本质还是单调栈的思路。不同的是，需要在nums2中找nums1中的元素的下一个比它大的值，可以看出顺序还是从小到大的单调栈。但是需要map做映射，方便判断nums2[i]是否在nums1中出现过。C++中，当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的。</p><p>接下来就要分析如下三种情况：</p><ol><li>情况一：当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况</li></ol><p>此时满足递增栈（栈头到栈底的顺序），所以直接入栈。</p><ol><li>情况二：当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况</li></ol><p>如果相等的话，依然直接入栈，因为我们要求的是右边第一个比自己大的元素，而不是大于等于！</p><ol><li>情况三：当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况</li></ol><p>此时如果入栈就不满足递增栈了，这也是找到右边第一个比自己大的元素的时候。</p><p>判断栈顶元素是否在nums1里出现过，（注意栈里的元素是nums2的元素），如果出现过，开始记录结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(nums1.size(), <span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-keyword">if</span> (nums1.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result;<br><br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; umap; <span class="hljs-comment">// key:下标元素，value：下标</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums1.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            umap[nums1[i]] = i;<br>        &#125;<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums2.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums2[i] &lt; nums2[st.<span class="hljs-built_in">top</span>()]) &#123;           <span class="hljs-comment">// 情况一</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums2[i] == nums2[st.<span class="hljs-built_in">top</span>()]) &#123;   <span class="hljs-comment">// 情况二</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">else</span> &#123;                                    <span class="hljs-comment">// 情况三</span><br>                <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; nums2[i] &gt; nums2[st.<span class="hljs-built_in">top</span>()]) &#123;<br>                    <span class="hljs-keyword">if</span> (umap.<span class="hljs-built_in">count</span>(nums2[st.<span class="hljs-built_in">top</span>()]) &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 看map里是否存在这个元素</span><br>                        <span class="hljs-type">int</span> index = umap[nums2[st.<span class="hljs-built_in">top</span>()]]; <span class="hljs-comment">// 根据map找到nums2[st.top()] 在 nums1中的下标。记录结果这块逻辑有一点小绕，要清楚，此时栈顶元素在nums2数组中右面第一个大的元素是nums2[i]（即当前遍历元素</span><br>                        result[index] = nums2[i];<br>                    &#125;<br>                    st.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="（3）下一个更大元素"><a href="#（3）下一个更大元素" class="headerlink" title="（3）下一个更大元素||"></a>（3）下一个更大元素||</h3><p>对比上一题，数组变成环形了，需要模拟走了两边数组来解题，（1 2  1 1 2 1）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElements</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(nums.size(), <span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>() * <span class="hljs-number">2</span>; i++) &#123; <br>            <span class="hljs-comment">// 模拟遍历两边nums，注意一下都是用i % nums.size()来操作 防止遍历越界</span><br>            <span class="hljs-keyword">if</span> (nums[i % nums.<span class="hljs-built_in">size</span>()] &lt; nums[st.<span class="hljs-built_in">top</span>()]) st.<span class="hljs-built_in">push</span>(i % nums.<span class="hljs-built_in">size</span>());<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i % nums.<span class="hljs-built_in">size</span>()] == nums[st.<span class="hljs-built_in">top</span>()]) st.<span class="hljs-built_in">push</span>(i % nums.<span class="hljs-built_in">size</span>()); <br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i % nums.<span class="hljs-built_in">size</span>()] &gt; nums[st.<span class="hljs-built_in">top</span>()]) &#123;<br>                    result[st.<span class="hljs-built_in">top</span>()] = nums[i % nums.<span class="hljs-built_in">size</span>()];<br>                    st.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>                st.<span class="hljs-built_in">push</span>(i % nums.<span class="hljs-built_in">size</span>());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="（4）接雨水"><a href="#（4）接雨水" class="headerlink" title="（4）接雨水"></a>（4）接雨水</h3><img src="C:\Users\zhangdengsheng\AppData\Roaming\Typora\typora-user-images\image-20240509151300969.png" style="zoom:50%;" /><p>处理逻辑同单调栈的从小到大顺序相同，在收获结果的时候，要注意计算方式。</p><p>当当前元素大于栈顶元素了，取栈顶元素，将栈顶元素弹出，这个就是凹槽的底部，也就是中间位置，下标记为mid，对应的高度为height[mid]。</p><p>此时的栈顶元素st.top()，就是凹槽的左边位置，下标为st.top()，对应的高度为height[st.top()]。</p><p>当前遍历的元素i，就是凹槽右边的位置，下标为i，对应的高度为height[i]。</p><p>此时大家应该可以发现其实就是<strong>栈顶和栈顶的下一个元素以及要入栈的元素，三个元素来接水！</strong></p><p>那么雨水高度是 min(凹槽左边高度, 凹槽右边高度) - 凹槽底部高度，代码为：<code>int h = min(height[st.top()], height[i]) - height[mid];</code></p><p>雨水的宽度是 凹槽右边的下标 - 凹槽左边的下标 - 1（因为只求中间宽度），代码为：<code>int w = i - st.top() - 1 ;</code></p><p>当前凹槽雨水的体积就是：<code>h * w</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (height.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 可以不加</span><br>        stack&lt;<span class="hljs-type">int</span>&gt; st; <span class="hljs-comment">// 存着下标，计算的时候用下标对应的柱子高度</span><br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; height.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (height[i] &lt; height[st.<span class="hljs-built_in">top</span>()]) &#123;     <span class="hljs-comment">// 情况一</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">if</span> (height[i] == height[st.<span class="hljs-built_in">top</span>()]) &#123;  <span class="hljs-comment">// 情况二</span><br>                st.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 其实这一句可以不加，效果是一样的，但处理相同的情况的思路却变了。</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">else</span> &#123;                                <span class="hljs-comment">// 情况三</span><br>                <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; height[i] &gt; height[st.<span class="hljs-built_in">top</span>()]) &#123; <span class="hljs-comment">// 注意这里是while</span><br>                    <span class="hljs-type">int</span> mid = st.<span class="hljs-built_in">top</span>();<br>                    st.<span class="hljs-built_in">pop</span>();<br>                    <span class="hljs-keyword">if</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>                        <span class="hljs-type">int</span> h = <span class="hljs-built_in">min</span>(height[st.<span class="hljs-built_in">top</span>()], height[i]) - height[mid];<br>                        <span class="hljs-type">int</span> w = i - st.<span class="hljs-built_in">top</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意减一，只求中间宽度</span><br>                        sum += h * w;<br>                    &#125;<br>                &#125;<br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="（5）矩形柱子的最大面积"><a href="#（5）矩形柱子的最大面积" class="headerlink" title="（5）矩形柱子的最大面积"></a>（5）矩形柱子的最大面积</h3><p>本题将单调栈的顺序变成了从大到小，处理逻辑也要取反。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; heights)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        heights.<span class="hljs-built_in">insert</span>(heights.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">0</span>); <span class="hljs-comment">// 数组头部加入元素0</span><br>        heights.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 数组尾部加入元素0</span><br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">// 第一个元素已经入栈，从下标1开始</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; heights.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (heights[i] &gt; heights[st.<span class="hljs-built_in">top</span>()]) &#123; <span class="hljs-comment">// 情况一</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (heights[i] == heights[st.<span class="hljs-built_in">top</span>()]) &#123; <span class="hljs-comment">// 情况二</span><br>                st.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 这个可以加，可以不加，效果一样，思路不同</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 情况三</span><br>                <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; heights[i] &lt; heights[st.<span class="hljs-built_in">top</span>()]) &#123; <span class="hljs-comment">// 注意是while</span><br>                    <span class="hljs-type">int</span> mid = st.<span class="hljs-built_in">top</span>();<br>                    st.<span class="hljs-built_in">pop</span>();<br>                    <span class="hljs-keyword">if</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>                        <span class="hljs-type">int</span> left = st.<span class="hljs-built_in">top</span>();<br>                        <span class="hljs-type">int</span> right = i;<br>                        <span class="hljs-type">int</span> w = right - left - <span class="hljs-number">1</span>;<br>                        <span class="hljs-type">int</span> h = heights[mid];<br>                        result = <span class="hljs-built_in">max</span>(result, w * h);<br>                    &#125;<br>                &#125;<br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="动态规划刷题总结"><a href="#动态规划刷题总结" class="headerlink" title="动态规划刷题总结"></a>动态规划刷题总结</h1><p>DP（动态规划）当前状态是由上一时刻的状态推导而来的。</p><p>动态规划五部曲：</p><p>1、确定dp数组以及其下标的含义</p><p>2、确定递推公式（状态转移公式）</p><p>3、dp数组如何初始化</p><p>4、确定遍历顺序</p><p>5、打印出dp数组，判断问题出在哪。</p><h2 id="1、斐波那契数列"><a href="#1、斐波那契数列" class="headerlink" title="1、斐波那契数列"></a>1、斐波那契数列</h2><p><a href="https://leetcode.cn/problems/fibonacci-number/">https://leetcode.cn/problems/fibonacci-number/</a></p><p>入门级别的动态规划，重点在于动态规划五部曲的使用，方法论的实现。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">// 方法一：动规五部曲</span><br>    <span class="hljs-comment">//     if(n &lt;= 1) return n;</span><br>    <span class="hljs-comment">//     vector&lt;int&gt; dp(n+1);// 1、确定dp数组即下标含义：下标为i的元素的斐波那契数列的值</span><br>    <span class="hljs-comment">//     dp[0] = 0;</span><br>    <span class="hljs-comment">//     dp[1] = 1; // 3、dp数组初始化</span><br>    <span class="hljs-comment">//     for(int i=2;i&lt;=n;i++)&#123;// 4、确定遍历顺序</span><br>    <span class="hljs-comment">//         dp[i] = dp[i-1] + dp[i-2];// 2、确定递推公式</span><br>    <span class="hljs-comment">//     &#125;</span><br>    <span class="hljs-comment">//     return dp[n];</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// 方法二：用两个数组维护就可以实现，节约空间</span><br>    <span class="hljs-keyword">if</span>(n &lt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;<br>    <span class="hljs-type">int</span> dp[<span class="hljs-number">2</span>];<span class="hljs-comment">// 确定dp数组</span><br>    dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    dp[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-comment">//dp数组初始化</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-type">int</span> sum = dp[<span class="hljs-number">0</span>]+dp[<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>]= dp[<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">1</span>]=sum; <span class="hljs-comment">// 变相实现递推公式：dp[i] = dp[i-1]+dp[i-2];</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、爬楼梯"><a href="#2、爬楼梯" class="headerlink" title="2、爬楼梯"></a>2、爬楼梯</h2><p><a href="https://leetcode.cn/problems/climbing-stairs/">https://leetcode.cn/problems/climbing-stairs/</a></p><p>动规五部曲：</p><p>定义一个一维数组来记录不同楼层的状态</p><p>1、确定dp数组以及下标的含义</p><p>dp[i]： <strong>爬到第i层楼梯，有dp[i]种方法</strong></p><p>2、确定递推公式</p><p>如何可以推出dp[i]呢？</p><p>从dp[i]的定义可以看出，dp[i] 可以有两个方向推出来。</p><p>首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。（题目中可以每次只跳一步）</p><p>还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么。（题目中可以每次跳两步）</p><p>那么dp[i]就是 dp[i - 1]与dp[i - 2]之和！</p><p>所以dp[i] &#x3D; dp[i - 1] + dp[i - 2] 。</p><p>在推导dp[i]的时候，一定要时刻想着dp[i]的定义，否则容易跑偏。这体现出确定dp数组以及下标的含义的重要性！</p><p>3、dp数组的初始化</p><p>本题中n是正整数，所以不用去定义dp[0]的含义，我们可以直接从dp[1]开始定义</p><p>那么初始化dp[1]&#x3D;1,dp[2]&#x3D;2;遍历的时候从3开始即可。</p><p>PS dp[0]&#x3D;1认为什么都不干也是一种方法。</p><p>4、确定遍历顺序</p><p>由递推公式可以看出遍历顺序一定是从前往后</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n; <span class="hljs-comment">// 因为下面直接对dp[2]操作了，防止空指针</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-comment">// dp数组</span><br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;/ dp数组初始化<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++) &#123; <span class="hljs-comment">// 注意i是从3开始的 ，遍历顺序</span><br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<span class="hljs-comment">// 递推公式</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>爬楼梯拓展</strong>：如果每次你可以爬至多m (1 &lt;&#x3D; m &lt; n)个台阶。你有多少种不同的方法可以爬到楼顶呢？–变成一个完全背包问题了。1阶，2阶，…. m阶就是物品，楼顶就是背包。每一阶可以重复使用，例如跳了1阶，还可以继续跳1阶。问跳到楼顶有几种方法其实就是问装满背包有几种方法。（求排列数）</p><p>1、确定dp数组以及下标的含义</p><p><strong>dp[i]：爬到有i个台阶的楼顶，有dp[i]种方法</strong>。</p><p>2、确定递推公式</p><p>本题呢，dp[i]有几种来源，dp[i - 1]，dp[i - 2]，dp[i - 3] 等等，即：dp[i - j]那么递推公式为：dp[i] +&#x3D; dp[i - j]</p><p>3、dp数组如何初始化</p><p>既然递归公式是 dp[i] +&#x3D; dp[i - j]，那么dp[0] 一定为1，dp[0]是递归中一切数值的基础所在，如果dp[0]是0的话，其他数值都是0了。下标非0的dp[i]初始化为0，因为dp[i]是靠dp[i-j]累计上来的，dp[i]本身为0这样才不会影响结果</p><p>4、确定遍历顺序</p><p>这是背包里求排列问题，即：<strong>1、2 步 和 2、1 步都是上三个台阶，但是这两种方法不一样！</strong>所以需将target放在外循环，将nums放在内循环。每一步可以走多次，这是完全背包，内循环需要从前向后遍历。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<span class="hljs-comment">// 1、确定dp数组</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<span class="hljs-comment">// 3、dp数组初始化，装满容量为0的背包由1种方法（什么都不放）</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-comment">//4、确定遍历顺序，因为求的是排列数（1、2和2,1是两种方法）外层循环遍历背包，内层遍历物品，且从前向后遍历，确保物品可以重复选取</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123; <br>                <span class="hljs-keyword">if</span> (i - j &gt;= <span class="hljs-number">0</span>) dp[i] += dp[i - j];<span class="hljs-comment">// 2、确定递推公式</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="3、使用最小花费爬楼梯"><a href="#3、使用最小花费爬楼梯" class="headerlink" title="3、使用最小花费爬楼梯"></a>3、使用最小花费爬楼梯</h2><p><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">https://leetcode.cn/problems/min-cost-climbing-stairs/</a></p><p>1、确定dp数组以及下标的含义</p><p>**dp[i]的定义：到达第i台阶所花费的最少体力为dp[i]**。</p><p>2、确定递推公式</p><p>**可以有两个途径得到dp[i]，一个是dp[i-1] 一个是dp[i-2]**。</p><p>dp[i - 1] 跳到 dp[i] 需要花费 dp[i - 1] + cost[i - 1]。</p><p>dp[i - 2] 跳到 dp[i] 需要花费 dp[i - 2] + cost[i - 2]。</p><p>那么究竟是选从dp[i - 1]跳还是从dp[i - 2]跳呢？</p><p>一定是选最小的，所以dp[i] &#x3D; min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);</p><p>3、dp数组如何初始化</p><p>根据dp数组的定义，到达第0台阶所花费的最小体力为dp[0]，那么有同学可能想，那dp[0] 应该是 cost[0]，例如 cost &#x3D; [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] 的话，dp[0] 就是 cost[0] 应该是1。</p><p>题目描述中明确说了 “你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。” 也就是说 到达 第 0 个台阶是不花费的，但从 第0 个台阶 往上跳的话，需要花费 cost[0]。</p><p>所以初始化 dp[0] &#x3D; 0，dp[1] &#x3D; 0;</p><p>4、确定遍历顺序</p><p>因为是模拟台阶，而且dp[i]由dp[i-1]dp[i-2]推出，所以是从前到后遍历cost数组就可以。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(cost.size() + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 默认第一步都是不花费体力的</span><br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= cost.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            dp[i] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>] + cost[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + cost[i - <span class="hljs-number">2</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[cost.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="4、不同路径"><a href="#4、不同路径" class="headerlink" title="4、不同路径"></a>4、不同路径</h2><p><a href="https://leetcode.cn/problems/unique-paths/">https://leetcode.cn/problems/unique-paths/</a></p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<span class="hljs-comment">// 1、[i][j]的定义：从（0,0）到（n-1，m-1）有dp[i][j]种方法</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<span class="hljs-comment">// 建立dp数组（二维数组的定义）</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<span class="hljs-comment">// 3、dp数组初始化（横着走、竖着走只有一种方法）</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<span class="hljs-comment">// 4、遍历顺序，从左往右依次遍历即可</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<span class="hljs-comment">// 2、递推公式</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="5、不同路径"><a href="#5、不同路径" class="headerlink" title="5、不同路径||"></a>5、不同路径||</h2><p>如果路径上有了障碍物，如何计算有几种方式到达目标位置呢？</p><p>如果遇到障碍，其实就把对应的dp数组置为0就可以了（这条路径上有障碍，就到不了目的地了）。</p><p>所以，当（i，j）位置有障碍物，dp数组要重置为0，所以初始化的部分要考虑障碍物情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n &amp;&amp; obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>; j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<span class="hljs-comment">// 数组初始化</span><br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;<span class="hljs-comment">// 带障碍物的网格</span><br>        <span class="hljs-type">int</span> m = obstacleGrid.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//行数</span><br>        <span class="hljs-type">int</span> n = obstacleGrid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<span class="hljs-comment">//列数</span><br><span class="hljs-keyword">if</span> (obstacleGrid[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span> || obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) <span class="hljs-comment">//如果在起点或终点出现了障碍，直接返回0</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<span class="hljs-comment">// 定义dp数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n &amp;&amp; obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>; j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<span class="hljs-comment">// 初始化</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<span class="hljs-comment">//初始化的部分，很容易忽略了障碍之后应该都是0的情况。</span><br></code></pre></td></tr></table></figure><h2 id="6、背包理论基础1"><a href="#6、背包理论基础1" class="headerlink" title="6、背包理论基础1"></a>6、背包理论基础1</h2><p>1、01背包</p><p>有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p>（1）确定dp数组及其含义</p><p>第一种写法， 是使用二维数组，即dp[i] [j]表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。</p><p>（2）确定递推公式</p><p>dp[i] [j]可以由两种方式推导出来：</p><ul><li><p>不放物品：由dp[i-1] [j]表示，背包容量为j，不放物品的最大价值，则dp[i-1] [j] &#x3D; dp[i] [j]（物品重量大于背包容量）包里不放物品时候的价值</p></li><li><p>放物品：由dp[i-1] [j-weight]表示，背包容量为j-weight，不放物品的最大价值，则dp[i] [j] &#x3D; dp[i-1] [j-weight] + value[i]</p></li></ul><p>则递推公式为 dp[i] [j] &#x3D; max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]);</p><p>（3）dp数组的初始化</p><p>首先从dp[i] [j]的定义出发，如果背包容量j为0的话，即dp[i] [0]，无论是选取哪些物品，背包价值总和一定为0；</p><p>由状态转移方程 dp[i] [j] &#x3D; max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]); 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。</p><p>dp[0] [j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。那么很明显当 j &lt; weight[0]的时候，dp[0] [j] 应该是 0，因为背包容量比编号0的物品重量还小。当j &gt;&#x3D; weight[0]时，dp[0] [j] 应该是value[0]，因为背包容量放足够放编号0物品。</p><p>dp[0] [j] 和 dp[i] [0] 都已经初始化了，那么其他下标应该初始化多少呢？</p><p>其实从递归公式： dp[i] [ j] &#x3D; max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]); 可以看出dp[i] [j] 是由左上方数值推导出来了，那么 其他下标初始为什么数值都可以，因为都会被覆盖。</p><p>（4）确定遍历顺序</p><p>对于二维数组的01背包问题，先遍历物品再遍历背包和先遍历背包再遍历物品都可以。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//二维dp数组实现</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, bagweight;<span class="hljs-comment">// bagweight代表行李箱空间</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">weight</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 存储每件物品所占空间</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">value</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;  <span class="hljs-comment">// 存储每件物品价值</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        cin &gt;&gt; weight[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>        cin &gt;&gt; value[j];<br>    &#125;<br>    <span class="hljs-comment">// dp数组, dp[i][j]代表行李箱空间为j的情况下,从下标为[0, i]的物品里面任意取,能达到的最大价值</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(weight.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(bagweight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><br>    <span class="hljs-comment">// 初始化, 因为需要用到dp[i - 1]的值</span><br>    <span class="hljs-comment">// j &lt; weight[0]已在上方被初始化为0</span><br>    <span class="hljs-comment">// j &gt;= weight[0]的值就初始化为value[0]</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = weight[<span class="hljs-number">0</span>]; j &lt;= bagweight; j++) &#123;<br>        dp[<span class="hljs-number">0</span>][j] = value[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历科研物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagweight; j++) &#123; <span class="hljs-comment">// 遍历行李箱容量</span><br>            <span class="hljs-comment">// 如果装不下这个物品,那么就继承dp[i - 1][j]的值</span><br>            <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>            <span class="hljs-comment">// 如果能装下,就将值更新为 不装这个物品的最大值 和 装这个物品的最大值 中的 最大值</span><br>            <span class="hljs-comment">// 装这个物品的最大值由容量为j - weight[i]的包任意放入序号为[0, i - 1]的最大值 + 该物品的价值构成</span><br>            <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; dp[weight.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][bagweight] &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; n &gt;&gt; bagweight) &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7、背包理论基础2"><a href="#7、背包理论基础2" class="headerlink" title="7、背包理论基础2"></a>7、背包理论基础2</h2><p>考虑用一维数组（滚动数组的形式）</p><p>1、确定dp数组的定义</p><p>在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。</p><p>2、一维dp数组的递推公式</p><p>dp[j]为 容量为j的背包所背的最大价值，那么如何推导dp[j]呢？</p><p>dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。</p><p>dp[j - weight[i]] + value[i] 表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）</p><p>此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1] [j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值，</p><p>所以递归公式为：dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);</p><p>3、dp数组的初始化</p><p><strong>关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱</strong>。</p><p>dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。</p><p>那么dp数组除了下标0的位置，初始为0，其他下标应该初始化多少呢？</p><p>看一下递归公式：dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);</p><p>dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。</p><p><strong>这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了</strong>。</p><p>那么我假设物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了。</p><p>4、遍历顺序</p><p>为了保证物品只被使用一次，需要倒序遍历背包容量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>这里大家发现和二维dp的写法中，遍历背包的顺序是不一样的！</strong></p><p>二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。</p><p>为什么呢？</p><p><strong>倒序遍历是为了保证物品i只被放入一次！</strong>。但如果一旦正序遍历了，那么物品0就会被重复加入多次！</p><p>举一个例子：物品0的重量weight[0] &#x3D; 1，价值value[0] &#x3D; 15</p><p>如果正序遍历</p><p>dp[1] &#x3D; dp[1 - weight[0]] + value[0] &#x3D; 15</p><p>dp[2] &#x3D; dp[2 - weight[0]] + value[0] &#x3D; 30</p><p>此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。</p><p>为什么倒序遍历，就可以保证物品只放入一次呢？</p><p>倒序就是先算dp[2]</p><p>dp[2] &#x3D; dp[2 - weight[0]] + value[0] &#x3D; 15 （dp数组已经都初始化为0）</p><p>dp[1] &#x3D; dp[1 - weight[0]] + value[0] &#x3D; 15</p><p>所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_1_wei_bag_problem</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; weight = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>    vector&lt;<span class="hljs-type">int</span>&gt; value = &#123;<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;;<br>    <span class="hljs-type">int</span> bagWeight = <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(bagWeight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test_1_wei_bag_problem</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8、分割等和子集"><a href="#8、分割等和子集" class="headerlink" title="8、分割等和子集"></a>8、分割等和子集</h2><p><a href="https://leetcode.cn/problems/partition-equal-subset-sum/">https://leetcode.cn/problems/partition-equal-subset-sum/</a></p><p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。根据题目描述，可以抽象成01背包问题，如果几个元素的和加起来能等于和的一半，即sum&#x2F;2，那就说明可以拆成两个子集。即背包容量为sum&#x2F;2，每个物品的重量为其大小，即nums[i]。</p><p>1、确定dp数组的含义：</p><p><strong>dp[j]表示 背包总容量（所能装的总重量）是j，放进物品后，背的最大重量为dp[j]</strong></p><p>如果背包容量为target， dp[target]就是装满 背包之后的重量，所以 当 dp[target] &#x3D;&#x3D; target 的时候，背包就装满了。</p><p>2、确定递推公式</p><p>01背包的递推公式为：dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);</p><p>本题，相当于背包里放入数值，那么物品i的重量是nums[i]，其价值也是nums[i]。</p><p>所以递推公式：dp[j] &#x3D; max(dp[j], dp[j - nums[i]] + nums[i]);</p><p>3、dp数组初始化</p><p>本题题目中 只包含正整数的非空数组，所以非0下标的元素初始化为0就可以。</p><p>4、确定遍历顺序</p><p>背包容量倒序遍历</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// dp[i]中的i表示背包内总和</span><br>        <span class="hljs-comment">// 题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200</span><br>        <span class="hljs-comment">// 总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以了</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">10001</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            sum += nums[i];<br>        &#125;<br>        <span class="hljs-comment">// 也可以使用库函数一步求和</span><br>        <span class="hljs-comment">// int sum = accumulate(nums.begin(), nums.end(), 0);</span><br>        <span class="hljs-keyword">if</span> (sum % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> target = sum / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-comment">// 开始 01背包</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = target; j &gt;= nums[i]; j--) &#123; <span class="hljs-comment">// 每一个元素一定是不可重复放入，所以从大到小遍历</span><br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - nums[i]] + nums[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 集合中的元素正好可以凑成总和target</span><br>        <span class="hljs-keyword">if</span> (dp[target] == target) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>9、最后一块石头的重量2</p><p><a href="https://leetcode.cn/problems/last-stone-weight-ii/">https://leetcode.cn/problems/last-stone-weight-ii/</a></p><p>有一堆石头，每块石头的重量都是正整数。</p><p>每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;&#x3D; y。那么粉碎的可能结果如下：</p><p>如果 x &#x3D;&#x3D; y，那么两块石头都会被完全粉碎；</p><p>如果 x !&#x3D; y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。</p><p>最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。</p><p>原理等同上一台的分割等和子集，也把石头分成两堆，背包容量为target（总石头重量的一半），dp[target]表示装满一半石头最大有多少，那剩下的一堆就是sum - dp[target]。两者相减就是剩余的最小值。</p><p>1、确定dp数组以及下标的含义</p><p>**dp[j]表示容量（这里说容量更形象，其实就是重量）为j的背包，最多可以背最大重量为dp[j]**。</p><p>可以回忆一下01背包中，dp[j]的含义，容量为j的背包，最多可以装的价值为 dp[j]。</p><p>相对于 01背包，本题中，石头的重量是 stones[i]，石头的价值也是 stones[i] ，可以 “最多可以装的价值为 dp[j]” &#x3D;&#x3D; “最多可以背的重量为dp[j]”</p><p>2、确定递推公式</p><p>01背包的递推公式为：dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);</p><p>本题则是：<strong>dp[j] &#x3D; max(dp[j], dp[j - stones[i]] + stones[i]);</strong></p><p>3、dp数组如何初始化</p><p>既然 dp[j]中的j表示容量，那么最大容量（重量）是多少呢，就是所有石头的重量和。</p><p>因为提示中给出1 &lt;&#x3D; stones.length &lt;&#x3D; 30，1 &lt;&#x3D; stones[i] &lt;&#x3D; 1000，所以最大重量就是30 * 1000 。</p><p>而我们要求的target其实只是最大重量的一半，所以dp数组开到15000大小就可以了。</p><p>当然也可以把石头遍历一遍，计算出石头总重量 然后除2，得到dp数组的大小。</p><p>我这里就直接用15000了。</p><p>接下来就是如何初始化dp[j]呢，因为重量都不会是负数，所以dp[j]都初始化为0就可以了，这样在递归公式dp[j] &#x3D; max(dp[j], dp[j - stones[i]] + stones[i]);中dp[j]才不会初始值所覆盖。</p><p>4、遍历顺序</p><p>外层遍历石头，内存倒序遍历容量。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lastStoneWeightII</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; stones)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">15001</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; stones.<span class="hljs-built_in">size</span>(); i++) sum += stones[i];<br>        <span class="hljs-type">int</span> target = sum / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; stones.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = target; j &gt;= stones[i]; j--) &#123; <span class="hljs-comment">// 遍历背包</span><br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - stones[i]] + stones[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum - dp[target] - dp[target];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="9、目标和"><a href="#9、目标和" class="headerlink" title="9、目标和"></a>9、目标和</h2><p><a href="https://leetcode.cn/problems/target-sum/">https://leetcode.cn/problems/target-sum/</a></p><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p><p>既然目标值为target，那么就一定有：加法组合 - 减法组合 &#x3D; target。</p><p>加法组合 + 减法组合&#x3D; sum，而sum是固定的。减法组合&#x3D; sum - 加法组合</p><p>公式来了， 加法组合- (sum - 加法组合) &#x3D; target 推导出 加法组合&#x3D; (target + sum)&#x2F;2 。</p><p>target是固定的，sum是固定的，加法组合就可以求出来。</p><p>此时问题就是在集合nums中找出值为(target + sum)&#x2F;2的加法组合。—转化为01背包问题（元素不能重复使用）</p><p>假设加法的总和为x，那么减法对应的总和就是sum - x。</p><p>所以我们要求的是 x - (sum - x) &#x3D; target</p><p>x &#x3D; (target + sum) &#x2F; 2–&gt;x即为背包容量–&gt;<strong>转化为求装满背包容量为x的背包一共有几种方法</strong>。</p><p><strong>注意：</strong></p><p>这里的背包容量是一个取整的表达式，例如sum 是5，S是2的话其实就是无解的，所以</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> ((S + sum) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 此时没有方案</span><br></code></pre></td></tr></table></figure><p>同时如果 S的绝对值已经大于sum，那么也是没有方案的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(S) &gt; sum) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 此时没有方案</span><br></code></pre></td></tr></table></figure><p>1、确定dp数组及其含义：</p><p>dp[j]表示装满容量为j的背包一共有dp[j]种方法。</p><p>2、推导递推公式</p><p>有哪些来源可以推出dp[j]呢？</p><p>只要搞到nums[i]，凑成dp[j]就有dp[j - nums[i]] 种方法。注意这里说的是装满背包的方法总数，</p><p>例如：dp[j]，j 为5，</p><ul><li>已经有一个1（nums[i]） 的话，有 dp[4]种方法 凑成 容量为5的背包。背包里已经有一个1了，对于容量为5的背包来说，装满它有dp[5-1]种方法，即dp[4]种方法。下述同理。</li><li>已经有一个2（nums[i]） 的话，有 dp[3]种方法 凑成 容量为5的背包。</li><li>已经有一个3（nums[i]） 的话，有 dp[2]中方法 凑成 容量为5的背包</li><li>已经有一个4（nums[i]） 的话，有 dp[1]中方法 凑成 容量为5的背包</li><li>已经有一个5 （nums[i]）的话，有 dp[0]中方法 凑成 容量为5的背包</li></ul><p>那么凑整dp[5]有多少方法呢，也就是把 所有的 dp[j - nums[i]] 累加起来。</p><p>递推公式为：dp[j] &#x3D; dp[j] + dp[j-nums[i]]</p><p>3、dp数组初始化</p><p>如果数组[0] ，target &#x3D; 0，那么 bagSize &#x3D; (target + sum) &#x2F; 2 &#x3D; 0。 dp[0]也应该是1， 也就是说给数组里的元素 0 前面无论放加法还是减法，都是 1 种方法。</p><p>所以本题我们应该初始化 dp[0] 为 1。装满容量为0的背包有1种方法，—什么都不放。</p><p>4、确定遍历顺序</p><p>外层遍历物品，内层倒序遍历背包容量（确保每个物品只被使用一次）</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++) sum += nums[i]; <span class="hljs-comment">// 求和</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(target) &gt; sum) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//目标和的绝对值大于总和，没有解决方案</span><br>    <span class="hljs-keyword">if</span>((target+sum)%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 向下取整 没有解决方案</span><br>    <span class="hljs-comment">// 转化为01背包问题</span><br>    <span class="hljs-type">int</span> bagsize = (target+sum)/<span class="hljs-number">2</span>;<span class="hljs-comment">//背包容量</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(bagsize+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<span class="hljs-comment">//定义dp数组</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<span class="hljs-comment">//初始化，不取任何数，背包容量为0，算一种方案；</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<span class="hljs-comment">// 先遍历物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j =bagsize;j&gt;=nums[i];j--)&#123;<span class="hljs-comment">// 倒序遍历背包容量，防止物品重复使用</span><br>            dp[j] = dp[j] +dp[j-nums[i]];<span class="hljs-comment">// 求装满背包有几种方法的递推公式。</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[bagsize];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="10、一和零"><a href="#10、一和零" class="headerlink" title="10、一和零"></a>10、一和零</h2><p><a href="https://leetcode.cn/problems/ones-and-zeroes/">https://leetcode.cn/problems/ones-and-zeroes/</a></p><p>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。</p><p>请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。</p><p>本题的本质其实是01背包问题：这个背包容量有两个纬度m和n，不同长度的字符串就是不同大小的物品</p><p>一个字符串由x个0和y个1组成（重量）x要满足m，y要满足n。</p><p>1、确定dp数值及其含义</p><p>dp[i] [j] 表示最多含有i个0和j个1的strs的最大子集的大小（元素个数)为dp[i] [j]。</p><p>2、确定递推公式：</p><p>还是分为拿还是不拿</p><p>不拿：dp[i] [j] </p><p>拿：dp[i-zeronum] [j-onenum] + 1 </p><p>dp[i] [j]是可以由前一个strs推导出来的，如果字符串strs里有一个元素有x个o和y个1，那么dp[i] [j] &#x3D; dp[i-x] [j-y]  +1</p><p>去的是dp[i] [j] 的最大值</p><p>所以dp[i] [j] &#x3D; max(dp[i] [j], dp[i - zeronum] [j - onenum] + 1);</p><p>字符串的zeronum和onenum相当于物品的重量（weight[i]），字符串本身的个数相当于物品的价值（value[i]）。</p><p>3、dp数组初始化</p><p>物品价值是非负的，初始化为0即可，保证会被递推公式覆盖。</p><p>4、确定遍历顺序</p><p>物品就是strs里的字符串，背包容量就是m和n。先遍历物品再遍历背包，且倒序遍历背包容量。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMaxForm</span><span class="hljs-params">(vector&lt;string&gt;&amp; strs, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<span class="hljs-comment">//   默认初始化为0；</span><br>        <span class="hljs-keyword">for</span>(string str:strs)&#123;<br>            <span class="hljs-type">int</span> zeronum = <span class="hljs-number">0</span>,onenum =<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c :str)&#123;<span class="hljs-comment">// 字符串只由0和1组成</span><br>            <span class="hljs-keyword">if</span>( c == <span class="hljs-string">&#x27;0&#x27;</span>)zeronum++;<br>            <span class="hljs-keyword">else</span> onenum++;<br>            &#125;<span class="hljs-comment">//遍历物品，统计每个物品（字符串）所包含的0和1的个数（重量）</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =m;i&gt;=zeronum;i--)&#123;<span class="hljs-comment">// 倒序遍历背包容量</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=n;j&gt;=onenum;j--)&#123;<span class="hljs-comment">// 倒序遍历背包容量</span><br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j],dp[i-zeronum][j-onenum]+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>            <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="11、完全背包理论基础"><a href="#11、完全背包理论基础" class="headerlink" title="11、完全背包理论基础"></a>11、完全背包理论基础</h2><p>有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品都有无限个（也就是可以放入背包多次）</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p>可以看到，对于完全背包来说，每件物品的数量不受限制，可以重复使用同一件物品。由此体现出遍历顺序的区别上，对于01背包，首先，<strong>for循环的顺序可以发生变化了</strong>，先遍历物品再遍历背包或者先遍历背包再遍历物品都可以，因为都能保证下标j之前的dp[j]都是遍历过的值，能有效覆盖，其次，对于<strong>遍历背包容量，不用再从大到小遍历</strong>，使得物品只能被添加一次了，因为完全背包问题中，每件物品可以使用无限次。</p><p>以上讨论是针对纯完全背包问题的，当题目要求发生变化，对于两层循环的遍历顺序就有了要求，针对不同的变体形式，主要体现在遍历顺序的不同。</p><h2 id="12、零钱兑换"><a href="#12、零钱兑换" class="headerlink" title="12、零钱兑换||"></a>12、零钱兑换||</h2><p><a href="https://leetcode.cn/problems/coin-change-ii/">https://leetcode.cn/problems/coin-change-ii/</a></p><p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币<strong>组合数</strong>。假设每一种面额的硬币有无限个。</p><p>根据题目描述可以看出，每种面额的硬币都有无限个，可以抽象成完全背包问题。</p><p>但本题和纯完全背包不一样，<strong>纯完全背包是凑成背包最大价值是多少，而本题是要求凑成总金额的物品组合个数！</strong></p><p>注意题目描述中是凑成总金额的硬币组合数，为什么强调是组合数呢？</p><p>例如示例一：</p><p>5 &#x3D; 2 + 2 + 1</p><p>5 &#x3D; 2 + 1 + 2</p><p>这是一种组合，都是 2 2 1。</p><p>如果问的是排列数，那么上面就是两种排列了。</p><p><strong>组合不强调元素之间的顺序，排列强调元素之间的顺序</strong></p><p>1、确定dp数组以及下标的含义</p><p>dp[j]：凑成总金额j的货币组合数为dp[j]（方法数）</p><p>2、确定递推公式</p><p>dp[j] 就是所有的dp[j - coins[i]]（考虑coins[i]的情况）相加。</p><p>所以递推公式：dp[j] +&#x3D; dp[j - coins[i]];</p><p><strong>这个递推公式大家应该不陌生了，我在讲解01背包题目的时候在9、目标和中就讲解了，求装满背包有几种方法，公式都是：dp[j] +&#x3D; dp[j - nums[i]];</strong></p><p>3、dp数组初始化</p><p>dp[0] &#x3D;1;凑成金额为0有1种方法，什么都不拿。</p><p>4、遍历顺序有讲究！</p><p>纯完全背包求得装满背包的最大价值是多少，和凑成总和的元素有没有顺序没关系，即：有顺序也行，没有顺序也行！而本题要求凑成总和的组合数，元素之间明确要求没有顺序。所以纯完全背包是能凑成总和就行，不用管怎么凑的。本题是求凑出来的方案个数，且每个方案个数是为组合数。那么本题，两个for循环的先后顺序可就有说法了。</p><p>我们先来看 外层for循环遍历物品（钱币），内层for遍历背包（金钱总额）的情况。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; coins.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = coins[i]; j &lt;= amount; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] += dp[j - coins[i]];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>假设：coins[0] &#x3D; 1，coins[1] &#x3D; 5。</p><p>那么就是先把1加入计算，然后再把5加入计算，得到的方法数量只有{1, 5}这种情况。而不会出现{5, 1}的情况。</p><p><strong>所以这种遍历顺序中dp[j]里计算的是组合数！</strong></p><p>如果把两个for交换顺序，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= amount; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; coins.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>        <span class="hljs-keyword">if</span> (j - coins[i] &gt;= <span class="hljs-number">0</span>) dp[j] += dp[j - coins[i]];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>背包容量的每一个值，都是经过 1 和 5 的计算，包含了{1, 5} 和 {5, 1}两种情况。</p><p><strong>此时dp[j]里算出来的就是排列数！</strong></p><p>本题求得是组合数，为此，先遍历物品，再遍历背包容量。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> amount, vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; coins.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = coins[i]; j &lt;= amount; j++) &#123; <span class="hljs-comment">// 遍历背包</span><br>                dp[j] += dp[j - coins[i]];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[amount];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="13、组合总和4"><a href="#13、组合总和4" class="headerlink" title="13、组合总和4"></a>13、组合总和4</h2><p><a href="https://leetcode.cn/problems/combination-sum-iv/">https://leetcode.cn/problems/combination-sum-iv/</a></p><p>给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。</p><p>示例:</p><ul><li>nums &#x3D; [1, 2, 3]</li><li>target &#x3D; 4</li></ul><p>所有可能的组合为： (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1)</p><p>请注意，<strong>顺序不同的序列</strong>被视作不同的组合。</p><p>由题可知，求的是排列数！</p><p>其余推导和上面的零钱兑换||一致，给出代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">combinationSum4</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(target+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<span class="hljs-comment">//dp数组初始化，凑成和为0有1种方法，就是不取任何数</span><br>        <span class="hljs-comment">// 求排列数，考虑顺序，所以先遍历背包，再遍历物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;=target;i++)&#123;<span class="hljs-comment">//先遍历背包</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;nums.<span class="hljs-built_in">size</span>();j++)&#123;<span class="hljs-comment">//再遍历物品</span><br>            <span class="hljs-keyword">if</span> (i - nums[j] &gt;= <span class="hljs-number">0</span> &amp;&amp; dp[i] &lt; INT_MAX - dp[i - nums[j]]) &#123;<br>                    dp[i] = dp[i] +dp[i-nums[j]];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[target];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>C++测试用例有两个数相加超过int的数据，所以需要在if里加上dp[i] &lt; INT_MAX - dp[i - num]。</p><p>14、零钱兑换</p><p><a href="https://leetcode.cn/problems/coin-change/">https://leetcode.cn/problems/coin-change/</a></p><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p>你可以认为每种硬币的数量是无限的。</p><p>1、确定dp数组以及下标的含义</p><p><strong>dp[j]：凑足总额为j所需钱币的最少个数为dp[j]</strong></p><p>2、确定递推公式</p><p>凑足总额为j - coins[i]的最少个数为dp[j - coins[i]]，那么只需要加上一个钱币coins[i]即dp[j - coins[i]] + 1就是dp[j]（考虑coins[i]）</p><p>所以dp[j] 要取所有 dp[j - coins[i]] + 1 中最小的。</p><p>递推公式：dp[j] &#x3D; min(dp[j - coins[i]] + 1, dp[j]);</p><p>3、dp数组如何初始化</p><p>首先凑足总金额为0所需钱币的个数一定是0，那么dp[0] &#x3D; 0;</p><p>其他下标对应的数值呢？</p><p>考虑到递推公式的特性，dp[j]必须初始化为一个最大的数，否则就会在min(dp[j - coins[i]] + 1, dp[j])比较的过程中被初始值覆盖。</p><p>所以下标非0的元素都是应该是最大值。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>, INT_MAX)</span></span>;<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>4、确定遍历顺序</p><p>本题求钱币最小个数，<strong>那么钱币有顺序和没有顺序都可以，都不影响钱币的最小个数</strong>。</p><p>所以本题并不强调集合是组合还是排列。</p><p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p><p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p><p><strong>所以本题的两个for循环的关系是：外层for循环遍历物品，内层for遍历背包或者外层for遍历背包，内层for循环遍历物品都是可以的！</strong></p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins, <span class="hljs-type">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>, INT_MAX)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; coins.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = coins[i]; j &lt;= amount; j++) &#123; <span class="hljs-comment">// 遍历背包</span><br>                <span class="hljs-keyword">if</span> (dp[j - coins[i]] != INT_MAX) &#123; <span class="hljs-comment">// 如果dp[j - coins[i]]是初始值则跳过</span><br>                    dp[j] = <span class="hljs-built_in">min</span>(dp[j - coins[i]] + <span class="hljs-number">1</span>, dp[j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (dp[amount] == INT_MAX) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> dp[amount];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="14、零钱兑换"><a href="#14、零钱兑换" class="headerlink" title="14、零钱兑换"></a>14、零钱兑换</h2><p><a href="https://leetcode.cn/problems/coin-change/">https://leetcode.cn/problems/coin-change/</a></p><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p>你可以认为每种硬币的数量是无限的。</p><p>1、确定dp数组以及下标的含义</p><p><strong>dp[j]：凑足总额为j所需钱币的最少个数为dp[j]</strong></p><p>2、确定递推公式</p><p>凑足总额为j - coins[i]的最少个数为dp[j - coins[i]]，那么只需要加上一个钱币coins[i]即dp[j - coins[i]] + 1就是dp[j]（考虑coins[i]）</p><p>所以dp[j] 要取所有 dp[j - coins[i]] + 1 中最小的。</p><p>递推公式：dp[j] &#x3D; min(dp[j - coins[i]] + 1, dp[j]);</p><p>3、dp数组如何初始化</p><p>首先凑足总金额为0所需钱币的个数一定是0，那么dp[0] &#x3D; 0;</p><p>其他下标对应的数值呢？</p><p>考虑到递推公式的特性，dp[j]必须初始化为一个最大的数，否则就会在min(dp[j - coins[i]] + 1, dp[j])比较的过程中被初始值覆盖。</p><p>所以下标非0的元素都是应该是最大值。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>, INT_MAX)</span></span>;<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>4、确定遍历顺序</p><p>本题求钱币最小个数，<strong>那么钱币有顺序和没有顺序都可以，都不影响钱币的最小个数</strong>。</p><p>所以本题并不强调集合是组合还是排列。</p><p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p><p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p><p><strong>所以本题的两个for循环的关系是：外层for循环遍历物品，内层for遍历背包或者外层for遍历背包，内层for循环遍历物品都是可以的！</strong></p><p>那么我采用coins放在外循环，target在内循环的方式。</p><p>本题钱币数量可以无限使用，那么是完全背包。所以遍历的内循环是正序</p><p>综上所述，遍历顺序为：coins（物品）放在外循环，target（背包）在内循环。且内循环正序。</p><p>代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins, <span class="hljs-type">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>, INT_MAX)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; coins.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = coins[i]; j &lt;= amount; j++) &#123; <span class="hljs-comment">// 遍历背包</span><br>                <span class="hljs-keyword">if</span> (dp[j - coins[i]] != INT_MAX) &#123; <span class="hljs-comment">// 如果dp[j - coins[i]]是初始值则跳过</span><br>                    dp[j] = <span class="hljs-built_in">min</span>(dp[j - coins[i]] + <span class="hljs-number">1</span>, dp[j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (dp[amount] == INT_MAX) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> dp[amount];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="15、完全平方数"><a href="#15、完全平方数" class="headerlink" title="15、完全平方数"></a>15、完全平方数</h2><p><a href="https://leetcode.cn/problems/perfect-squares/">https://leetcode.cn/problems/perfect-squares/</a></p><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p><p>给你一个整数 n ，返回和为 n 的完全平方数的 最少数量</p><p>1、确定dp数组（dp table）以及下标的含义</p><p><strong>dp[j]：和为j的完全平方数的最少数量为dp[j]</strong></p><p>2、确定递推公式</p><p>dp[j] 可以由dp[j - i * i]推出， dp[j - i * i] + 1 便可以凑成dp[j]。</p><p>此时我们要选择最小的dp[j]，所以递推公式：dp[j] &#x3D; min(dp[j - i * i] + 1, dp[j]);</p><p>3、dp数组如何初始化</p><p>dp[0]表示 和为0的完全平方数的最小数量，那么dp[0]一定是0。</p><p>有同学问题，那0 * 0 也算是一种啊，为啥dp[0] 就是 0呢？</p><p>看题目描述，找到若干个完全平方数（比如 1, 4, 9, 16, …），题目描述中可没说要从0开始，dp[0]&#x3D;0完全是为了递推公式。</p><p>非0下标的dp[j]应该是多少呢？</p><p>从递归公式dp[j] &#x3D; min(dp[j - i * i] + 1, dp[j]);中可以看出每次dp[j]都要选最小的，<strong>所以非0下标的dp[j]一定要初始为最大值，这样dp[j]在递推的时候才不会被初始值覆盖</strong>。</p><p>4、确定遍历顺序</p><p>我们知道这是完全背包，</p><p>如果求组合数就是外层for循环遍历物品，内层for遍历背包。</p><p>如果求排列数就是外层for遍历背包，内层for循环遍历物品。</p><p><strong>所以本题外层for遍历背包，内层for遍历物品，还是外层for遍历物品，内层for遍历背包，都是可以的</strong></p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, INT_MAX)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i * i &lt;= n; i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i * i; j &lt;= n; j++) &#123; <span class="hljs-comment">// 遍历背包</span><br>                dp[j] = <span class="hljs-built_in">min</span>(dp[j - i * i] + <span class="hljs-number">1</span>, dp[j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="16、单词拆分"><a href="#16、单词拆分" class="headerlink" title="16、单词拆分"></a>16、单词拆分</h2><p><a href="https://leetcode.cn/problems/word-break/">https://leetcode.cn/problems/word-break/</a></p><p>单词就是物品，字符串s就是背包，单词能否组成字符串s，就是问物品能不能把背包装满。</p><p>拆分时可以重复使用字典中的单词，说明就是一个完全背包！</p><p>动规五部曲分析如下：</p><p>1、确定dp数组以及下标的含义</p><p><strong>dp[i] : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词</strong>。</p><p>2、确定递推公式</p><p>如果确定dp[j] 是true，且 [j, i] 这个区间的子串出现在字典里，那么dp[i]一定是true。（j &lt; i ）。</p><p>所以递推公式是 if([j, i] 这个区间的子串出现在字典里 &amp;&amp; dp[j]是true) 那么 dp[i] &#x3D; true。</p><p>3、dp数组如何初始化</p><p>从递推公式中可以看出，dp[i] 的状态依靠 dp[j]是否为true，那么dp[0]就是递推的根基，dp[0]一定要为true，否则递推下去后面都都是false了。</p><p>那么dp[0]有没有意义呢？</p><p>dp[0]表示如果字符串为空的话，说明出现在字典里。</p><p>但题目中说了“给定一个非空字符串 s” 所以测试数据中不会出现i为0的情况，那么dp[0]初始为true完全就是为了推导公式。</p><p>下标非0的dp[i]初始化为false，只要没有被覆盖说明都是不可拆分为一个或多个在字典中出现的单词。</p><p>4、确定遍历顺序</p><p>题目中说是拆分为一个或多个在字典中出现的单词，所以这是完全背包。</p><p>而本题其实我们求的是<strong>排列数</strong>，为什么呢。 拿 s &#x3D; “applepenapple”, wordDict &#x3D; [“apple”, “pen”] 举例。</p><p>“apple”, “pen” 是物品，那么我们要求 物品的组合一定是 “apple” + “pen” + “apple” 才能组成 “applepenapple”。</p><p>“apple” + “apple” + “pen” 或者 “pen” + “apple” + “apple” 是不可以的，那么我们就是<strong>强调物品之间顺序</strong>。</p><p>所以说，本题一定是 先遍历 背包，再遍历物品。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;<br>        <span class="hljs-function">unordered_set&lt;string&gt; <span class="hljs-title">wordSet</span><span class="hljs-params">(wordDict.begin(), wordDict.end())</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(s.size() + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= s.<span class="hljs-built_in">size</span>(); i++) &#123;   <span class="hljs-comment">// 遍历背包</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;       <span class="hljs-comment">// 遍历物品</span><br>                string word = s.<span class="hljs-built_in">substr</span>(j, i - j); <span class="hljs-comment">//substr(起始位置，截取的个数)</span><br>                <span class="hljs-keyword">if</span> (wordSet.<span class="hljs-built_in">find</span>(word) != wordSet.<span class="hljs-built_in">end</span>() &amp;&amp; dp[j]) &#123;<br>                    dp[i] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[s.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="背包问题总结"><a href="#背包问题总结" class="headerlink" title="背包问题总结"></a>背包问题总结</h2><p>关于递推公式</p><p>问能否能装满背包（或者最多装多少）：dp[j] &#x3D; max(dp[j], dp[j - nums[i]] + nums[i]); </p><p>问装满背包有几种方法：dp[j] &#x3D; dp[j] + dp[j - nums[i]]</p><p>问背包装满最大价值：dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]); </p><p>问装满背包所有物品的最小个数：dp[j] &#x3D; min(dp[j - coins[i]] + 1, dp[j]);</p><p>关于遍历顺序</p><p>01背包：解二维dp数组01背包先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。一维dp数组01背包只能先遍历物品再遍历背包容量，且第二层for循环是从大到小遍历。</p><p>完全背包：完全背包的一维dp数组实现，先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。</p><p>但是仅仅是纯完全背包的遍历顺序是这样的，题目稍有变化，两个for循环的先后顺序就不一样了。</p><p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p><p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p><h2 id="17、打家劫舍"><a href="#17、打家劫舍" class="headerlink" title="17、打家劫舍"></a>17、打家劫舍</h2><p><a href="https://leetcode.cn/problems/house-robber/">https://leetcode.cn/problems/house-robber/</a></p><p>1、确定dp数组（dp table）以及下标的含义</p><p>**dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]**。</p><p>2、确定递推公式</p><p>决定dp[i]的因素就是第i房间偷还是不偷。</p><p>如果偷第i房间，那么dp[i] &#x3D; dp[i - 2] + nums[i] ，即：第i-1房一定是不考虑的，找出 下标i-2（包括i-2）以内的房屋，最多可以偷窃的金额为dp[i-2] 加上第i房间偷到的钱。</p><p>如果不偷第i房间，那么dp[i] &#x3D; dp[i - 1]，即考 虑i-1房，（<strong>注意这里是考虑，并不是一定要偷i-1房，这是很多同学容易混淆的点</strong>）</p><p>然后dp[i]取最大值，即dp[i] &#x3D; max(dp[i - 2] + nums[i], dp[i - 1]);</p><p>3、dp数组如何初始化</p><p>从递推公式dp[i] &#x3D; max(dp[i - 2] + nums[i], dp[i - 1]);可以看出，递推公式的基础就是dp[0] 和 dp[1]</p><p>从dp[i]的定义上来讲，dp[0] 一定是 nums[0]，dp[1]就是nums[0]和nums[1]的最大值即：dp[1] &#x3D; max(nums[0], nums[1]);</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size())</span></span>;<br>dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br></code></pre></td></tr></table></figure><p>4、确定遍历顺序</p><p>dp[i] 是根据dp[i - 2] 和 dp[i - 1] 推导出来的，那么一定是从前到后遍历！</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">2</span>] + nums[i], dp[i - <span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><p>代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//没有元素，偷不到，返回零</span><br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 只有一个元素，下标零就是最大值</span><br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">dp</span>(nums.<span class="hljs-built_in">size</span>());<span class="hljs-comment">// dp数组</span><br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>],nums[<span class="hljs-number">1</span>]);<span class="hljs-comment">// dp数组的初始化</span><br>        <span class="hljs-comment">// 遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>],dp[i<span class="hljs-number">-2</span>]+nums[i]);<span class="hljs-comment">// 递推公式，偷当前家还是不偷当前家，取最大值</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="18、打家劫舍"><a href="#18、打家劫舍" class="headerlink" title="18、打家劫舍||"></a>18、打家劫舍||</h2><p><a href="https://leetcode.cn/problems/house-robber-ii/">https://leetcode.cn/problems/house-robber-ii/</a></p><p>对比上一题，房屋成环了，也是相邻的不能偷，因此需要分类讨论了。</p><p>情况1：考虑不包含首位元素</p><p>情况2：考虑不包含尾元素</p><p>情况3：考虑不包含首元素</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 注意注释中的情况二情况三，以及把198.打家劫舍的代码抽离出来了</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> result1 = <span class="hljs-built_in">robRange</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>); <span class="hljs-comment">// 情况二</span><br>        <span class="hljs-type">int</span> result2 = <span class="hljs-built_in">robRange</span>(nums, <span class="hljs-number">1</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>); <span class="hljs-comment">// 情况三</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(result1, result2);<br>    &#125;<br>    <span class="hljs-comment">// 198.打家劫舍的逻辑</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">robRange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (end == start) <span class="hljs-keyword">return</span> nums[start];<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size())</span></span>;<br>        dp[start] = nums[start];<br>        dp[start + <span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[start], nums[start + <span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start + <span class="hljs-number">2</span>; i &lt;= end; i++) &#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">2</span>] + nums[i], dp[i - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[end];<br>    &#125;<br>&#125;;<span class="hljs-comment">// 情况2、3包含了情况1，故不必单独写情况1的处理逻辑了。</span><br></code></pre></td></tr></table></figure><h2 id="19、打家劫舍"><a href="#19、打家劫舍" class="headerlink" title="19、打家劫舍|||"></a>19、打家劫舍|||</h2><p><a href="https://leetcode.cn/problems/house-robber-iii/">https://leetcode.cn/problems/house-robber-iii/</a></p><p><strong>树形dp</strong></p><p>所有房屋以二叉树的结构排列，相邻节点不能偷。</p><p>1、确定递归函数的参数和返回值</p><p>这里我们要求一个节点 偷与不偷的两个状态所得到的金钱，那么返回值就是一个长度为2的数组。</p><p>参数为当前节点，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">robTree</span><span class="hljs-params">(TreeNode* cur)</span> </span>&#123;<br></code></pre></td></tr></table></figure><p>其实这里的返回数组就是dp数组。</p><p>所以dp数组（dp table）以及下标的含义：dp[0] 表示下标为0记录不偷该节点所得到的的最大金钱，dp[1]表示下标为1记录偷该节点所得到的的最大金钱。</p><p><strong>所以本题dp数组就是一个长度为2的数组！</strong></p><p>那么有同学可能疑惑，长度为2的数组怎么标记树中每个节点的状态呢？</p><p><strong>别忘了在递归的过程中，系统栈会保存每一层递归的参数</strong>。</p><p>2、确定终止条件</p><p>在遍历的过程中，如果遇到空节点的话，很明显，无论偷还是不偷都是0，所以就返回</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br></code></pre></td></tr></table></figure><p>这也相当于dp数组的初始化</p><p>3、确定遍历顺序</p><p>首先明确的是使用后序遍历。 因为要通过递归函数的返回值来做下一步计算。</p><p>通过递归左节点，得到左节点偷与不偷的金钱。</p><p>通过递归右节点，得到右节点偷与不偷的金钱。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 下标0：不偷，下标1：偷</span><br>vector&lt;<span class="hljs-type">int</span>&gt; left = <span class="hljs-built_in">robTree</span>(cur-&gt;left); <span class="hljs-comment">// 左</span><br>vector&lt;<span class="hljs-type">int</span>&gt; right = <span class="hljs-built_in">robTree</span>(cur-&gt;right); <span class="hljs-comment">// 右</span><br><span class="hljs-comment">// 中</span><br></code></pre></td></tr></table></figure><p>4、确定单层递归的逻辑</p><p>如果是偷当前节点，那么左右孩子就不能偷，val1 &#x3D; cur-&gt;val + left[0] + right[0]; （<strong>如果对下标含义不理解就再回顾一下dp数组的含义</strong>）</p><p>如果不偷当前节点，那么左右孩子就可以偷，至于到底偷不偷一定是选一个最大的，所以：val2 &#x3D; max(left[0], left[1]) + max(right[0], right[1]);</p><p>最后当前节点的状态就是{val2, val1}; 即：{不偷当前节点得到的最大金钱，偷当前节点得到的最大金钱}</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; left = <span class="hljs-built_in">robTree</span>(cur-&gt;left); <span class="hljs-comment">// 左</span><br>vector&lt;<span class="hljs-type">int</span>&gt; right = <span class="hljs-built_in">robTree</span>(cur-&gt;right); <span class="hljs-comment">// 右</span><br><span class="hljs-comment">// 偷cur</span><br><span class="hljs-type">int</span> val1 = cur-&gt;val + left[<span class="hljs-number">0</span>] + right[<span class="hljs-number">0</span>];<br><span class="hljs-comment">// 不偷cur</span><br><span class="hljs-type">int</span> val2 = <span class="hljs-built_in">max</span>(left[<span class="hljs-number">0</span>], left[<span class="hljs-number">1</span>]) + <span class="hljs-built_in">max</span>(right[<span class="hljs-number">0</span>], right[<span class="hljs-number">1</span>]);<br><span class="hljs-keyword">return</span> &#123;val2, val1&#125;;<br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result = <span class="hljs-built_in">robTree</span>(root);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(result[<span class="hljs-number">0</span>],result[<span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">robTree</span><span class="hljs-params">(TreeNode *cur)</span></span>&#123; <span class="hljs-comment">// 二叉树的后序遍历 返回的是dp数组，0代表不偷，1代表偷 // 1、确定返回值和参数</span><br><span class="hljs-comment">// 2、确定终止条件</span><br>    <span class="hljs-keyword">if</span>(cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br><span class="hljs-comment">// 3、确定单层递归的逻辑</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; left = <span class="hljs-built_in">robTree</span>(cur-&gt;left);<span class="hljs-comment">//左，统计左孩偷与不偷的钱币</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; right = <span class="hljs-built_in">robTree</span>(cur-&gt;right);<span class="hljs-comment">// 右，统计右孩子偷与不偷的钱币</span><br>    <span class="hljs-type">int</span> val1 = cur-&gt;val + left[<span class="hljs-number">0</span>] +right[<span class="hljs-number">0</span>];<span class="hljs-comment">//偷当前节点，左右孩子都不能偷 中</span><br>    <span class="hljs-type">int</span> val2 = <span class="hljs-built_in">max</span>(left[<span class="hljs-number">0</span>],left[<span class="hljs-number">1</span>]) + <span class="hljs-built_in">max</span>(right[<span class="hljs-number">0</span>],right[<span class="hljs-number">1</span>]);<span class="hljs-comment">//不偷当前节点，选择孩子偷与不偷的最大钱币数量 中</span><br>    <span class="hljs-keyword">return</span> &#123;val2,val1&#125;;<span class="hljs-comment">// 返回的就是传入的节点不偷与偷的最大金币</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="20、买卖股票的最佳时机"><a href="#20、买卖股票的最佳时机" class="headerlink" title="20、买卖股票的最佳时机"></a>20、买卖股票的最佳时机</h2><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/</a></p><p>只允许买卖一次</p><p>1、确定dp数组（dp table）以及下标的含义</p><p>dp[i] [0] 表示第i天持有股票所得最多利润 ，<strong>这里可能有同学疑惑，本题中只能买卖一次，持有股票之后哪还有现金呢？</strong>–说成利润就好理解了</p><p>其实一开始利润是0，那么加入第i天买入股票利润就是 -prices[i]， 这是一个负数。</p><p>dp[i] [1] 表示第i天不持有股票所得最多利润</p><p><strong>注意这里说的是“持有”，“持有”不代表就是当天“买入”！也有可能是昨天就买入了，今天保持持有的状态</strong></p><p>很多同学把“持有”和“买入”没区分清楚。</p><p>2、确定递推公式</p><p>如果第i天持有股票即dp[i] [0]， 那么可以由两个状态推出来</p><ul><li>第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1] [0]</li><li>第i天买入股票，所得现金就是买入今天的股票后所得利润即：-prices[i]</li></ul><p>那么dp[i] [0]应该选所得现金最大的，所以<strong>dp[i] [0] &#x3D; max(dp[i - 1] [0], -prices[i]);</strong></p><p>如果第i天不持有股票即dp[i] [1]， 也可以由两个状态推出来</p><ul><li>第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1] [1]</li><li>第i天卖出股票，所得现金就是按照今天股票价格卖出后所得利润即：prices[i] + dp[i - 1] [0]</li></ul><p>同样dp[i] [1]取最大的，dp[i] [1] &#x3D; max(dp[i - 1] [1], prices[i] + dp[i - 1] [0]);</p><p>3、dp数组如何初始化</p><p>由递推公式 dp[i] [0] &#x3D; max(dp[i - 1] [0], -prices[i]); 和 dp[i] [1] &#x3D; max(dp[i - 1] [1], prices[i] + dp[i - 1] [0]);可以看出</p><p>其基础都是要从dp[0] [0]和dp[0] [1]推导出来。</p><p>那么dp[0] [0]表示第0天持有股票，此时的持有股票就一定是买入股票了，因为不可能有前一天推出来，所以dp[0] [0] -&#x3D; prices[0];</p><p>dp[0] [1]表示第0天不持有股票，不持有股票那么利润就是0，所以dp[0] [1] &#x3D; 0;</p><p>4、确定遍历顺序</p><p>从递推公式可以看出dp[i]都是由dp[i - 1]推导出来的，那么一定是从前向后遍历。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len = prices.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(len,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] -= prices[<span class="hljs-number">0</span>];<span class="hljs-comment">// dp数组初始化，第0天持有，等于当天买入，所得收益为-prices[0]；</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">// 第0天不持有，收益就是0</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">1</span>; i&lt;len;i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],-prices[i]);<span class="hljs-comment">//当天买入，利润为-prices[0]</span><br>            dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>],prices[i]+dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]);<span class="hljs-comment">// 前一天不持有，和前一天持有今天卖出取最大值</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[len<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;; <span class="hljs-comment">// 为什么最后结果是dp[len-1][1]而不是dp[len-1][0]:因为不持有股票（卖出）一定比持有利润高--只卖买一次。</span><br></code></pre></td></tr></table></figure><h2 id="21、买卖股票的最佳时机"><a href="#21、买卖股票的最佳时机" class="headerlink" title="21、买卖股票的最佳时机||"></a>21、买卖股票的最佳时机||</h2><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/</a></p><p>可以买卖无数次。</p><p>因为一只股票可以买卖多次，所以当第i天买入股票的时候，所持有的现金可能有之前买卖过的利润，<strong>即i-1天有利润。</strong></p><p>所以区别在于递推公式不同，dp[i] [0] &#x3D; max(dp[i - 1] [0], <strong>dp[i - 1] [1] - prices[i]</strong>); 第i天持有股票的利润发生了变化，可以在买入时有之前卖出的利润。</p><p>代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>    <span class="hljs-comment">// 贪心算法</span><br>    <span class="hljs-comment">//     int result = 0;</span><br>    <span class="hljs-comment">//     for(int i = 1;i &lt; prices.size();i++)&#123;</span><br>    <span class="hljs-comment">//         result += max(prices[i]-prices[i-1],0);// 只收集每天的正利润，局部最优得到全局最优</span><br>    <span class="hljs-comment">//     &#125;</span><br>    <span class="hljs-comment">//     return result;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// 动态规划</span><br>    <span class="hljs-type">int</span> len = prices.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(len,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>));<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">1</span>;i&lt;len;i++)&#123;<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]-prices[i]);<span class="hljs-comment">// 要考虑i-1天持有，第i天卖出的收益（因为可以多次买卖，所以第i-1天有收益）</span><br>        dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>],prices[i]+dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[len<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="22、买卖股票的最佳时机"><a href="#22、买卖股票的最佳时机" class="headerlink" title="22、买卖股票的最佳时机|||"></a>22、买卖股票的最佳时机|||</h2><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/</a></p><p>最多买卖两次</p><p>有了多种状态加以区分。</p><p>1、确定dp数组以及下标的含义</p><p>一天一共就有五个状态，</p><ol><li>没有操作 （其实我们也可以不设置这个状态） 0</li><li>第一次持有股票 1</li><li>第一次不持有股票 2</li><li>第二次持有股票 3</li><li>第二次不持有股票 4</li></ol><p>dp[i] [j]中 i表示第i天，j为 [0 - 4] 五个状态，dp[i] [j]表示第i天状态j的收益。</p><p>需要注意：dp[i] [1]，<strong>表示的是第i天，持有股票的状态，并不是说一定要第i天买入股票，这是很多同学容易陷入的误区</strong>。</p><p>例如 dp[i] [1] ，并不是说 第i天一定买入股票，有可能 第 i-1天 就买入了，那么 dp[i] [1] 延续持有股票的这个状态。</p><p>2、确定递推公式</p><p>达到dp[i] [1]状态，有两个具体操作：</p><ul><li>操作一：第i天买入股票了，那么dp[i] [ 1] &#x3D; dp[i-1] [0] - prices[i]</li><li>操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i] [1] &#x3D; dp[i - 1] [1]</li></ul><p>那么dp[i] [1]究竟选 dp[i-1] [0] - prices[i]，还是dp[i - 1] [ 1]呢？</p><p>一定是选最大的，所以 dp[i] [1] &#x3D; max(dp[i-1] [0] - prices[i], dp[i - 1] [1]);</p><p>同理dp[i] [2]也有两个操作：</p><ul><li>操作一：第i天卖出股票了，那么dp[i] [2] &#x3D; dp[i - 1] [1] + prices[i]</li><li>操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp[i] [2] &#x3D; dp[i - 1] [2]</li></ul><p>所以dp[i] [2] &#x3D; max(dp[i - 1] [1] + prices[i], dp[i - 1] [2])</p><p>同理可推出剩下状态部分：</p><p>dp[i] [3] &#x3D; max(dp[i - 1] [3], dp[i - 1] [2] - prices[i]);</p><p>dp[i] [4] &#x3D; max(dp[i - 1] [4], dp[i - 1] [3] + prices[i]);</p><p>3、数组初始化</p><p>0天没有操作，这个最容易想到，就是0，即：dp[0] [0] &#x3D; 0;</p><p>第0天做第一次买入的操作，dp[0] [1] &#x3D; -prices[0];</p><p>第0天做第一次卖出的操作，这个初始值应该是多少呢？</p><p>此时还没有买入，怎么就卖出呢？ 其实大家可以理解当天买入，当天卖出，收益不变，所以dp[0] [2] &#x3D; 0;</p><p>第0天第二次买入操作，初始值应该是多少呢？应该不少同学疑惑，第一次还没买入呢，怎么初始化第二次买入呢？</p><p>第二次买入依赖于第一次卖出的状态，其实相当于第0天第一次买入了，第一次卖出了，然后再买入一次（第二次买入），那么现在手头上没有收益，只要买入，现金就做相应的减少。</p><p>所以第二次买入操作，初始化为：dp[0] [3] &#x3D; -prices[0];</p><p>同理第二次卖出初始化dp[0] [4] &#x3D; 0;当天买入当天卖出</p><p>4、确定遍历顺序</p><p>从递归公式其实已经可以看出，一定是从前向后遍历，因为dp[i]，依靠dp[i - 1]的数值。</p><p>代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (prices.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(prices.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">5</span>, <span class="hljs-number">0</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>            dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);<br>            dp[i][<span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);<br>            dp[i][<span class="hljs-number">3</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>] - prices[i]);<br>            dp[i][<span class="hljs-number">4</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">4</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>] + prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[prices.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][<span class="hljs-number">4</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="23、买卖股票的最佳时机IV"><a href="#23、买卖股票的最佳时机IV" class="headerlink" title="23、买卖股票的最佳时机IV"></a>23、买卖股票的最佳时机IV</h2><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/</a></p><p>最多可以有k次买卖，奇数次是买入，偶数次是卖出</p><p>1、确定dp数组以及下标的含义</p><p>在上一题中，我们定义了一个二维dp数组，本题其实依然可以用一个二维dp数组。</p><p>使用二维数组 dp[i] [j] ：第i天的状态为j，所剩下的最大利润是dp[i] [j]</p><p>j的状态表示为：</p><ul><li>0 表示不操作</li><li>1 第一次买入</li><li>2 第一次卖出</li><li>3 第二次买入</li><li>4 第二次卖出</li><li>…..</li></ul><p><strong>大家应该发现规律了吧 ，除了0以外，偶数就是卖出，奇数就是买入</strong>。</p><p>题目要求是至多有K笔交易，那么j的范围就定义为 2 * k + 1 就可以了。</p><p>所以二维dp数组的C++定义为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(prices.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br></code></pre></td></tr></table></figure><p>2、确定递推公式</p><p>达到dp[i] [1]状态，有两个具体操作：</p><ul><li>操作一：第i天买入股票了，那么dp[i] [1] &#x3D; dp[i - 1] [0] - prices[i]</li><li>操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i] [1] &#x3D; dp[i - 1] [1]</li></ul><p>选最大的，所以 dp[i] [1] &#x3D; max(dp[i - 1] [0] - prices[i], dp[i - 1] [1]);</p><p>同理dp[i] [2]也有两个操作：</p><ul><li>操作一：第i天卖出股票了，那么dp[i] [2] &#x3D; dp[i - 1] [1] + prices[i]</li><li>操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp[i] [2] &#x3D; dp[i - 1] [2]</li></ul><p>所以dp[i] [2] &#x3D; max(dp[i - 1] [1] + prices[i], dp[i - 1] [2])</p><p>同理可以类比剩下的状态，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span> * k - <span class="hljs-number">1</span>; j += <span class="hljs-number">2</span>) &#123;<br>    dp[i][j + <span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j] - prices[i]);<br>    dp[i][j + <span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">2</span>], dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] + prices[i]);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>本题和上一题的最大的区别就是这里要类比j为奇数是买，偶数是卖的状态</strong>。</p><p>3、dp数组如何初始化</p><p>第0天没有操作，这个最容易想到，就是0，即：dp[0] [0] &#x3D; 0;</p><p>第0天做第一次买入的操作，dp[0] [1] &#x3D; -prices[0];</p><p>第0天做第一次卖出的操作，这个初始值应该是多少呢？</p><p>此时还没有买入，怎么就卖出呢？ 其实大家可以理解<strong>当天买入，当天卖出</strong>，所以dp[0] [2] &#x3D; 0;</p><p>第0天第二次买入操作，初始值应该是多少呢？应该不少同学疑惑，第一次还没买入呢，怎么初始化第二次买入呢？</p><p>第二次买入依赖于第一次卖出的状态，其实相当于第0天第一次买入了，第一次卖出了，然后在买入一次（第二次买入），那么现在手头上没有现金，只要买入，现金就做相应的减少。</p><p>所以第二次买入操作，初始化为：dp[0] [3] &#x3D; -prices[0];</p><p>第二次卖出初始化dp[0] [4] &#x3D; 0;</p><p><strong>所以同理可以推出dp[0] [j]当j为奇数的时候都初始化为 -prices[0]</strong></p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">2</span> * k; j += <span class="hljs-number">2</span>) &#123;<br>    dp[<span class="hljs-number">0</span>][j] = -prices[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>4、确定遍历顺序</p><p>从递归公式其实已经可以看出，一定是从前向后遍历，因为dp[i]，依靠dp[i - 1]的数值。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span> k, vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span> (prices.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(prices.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<span class="hljs-comment">// 定义dp数组的大小</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">2</span> * k; j += <span class="hljs-number">2</span>) &#123;<span class="hljs-comment">// dp数组初始化 奇数次是买入，只要是买入 利润均为-prices[0]</span><br>            dp[<span class="hljs-number">0</span>][j] = -prices[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; prices.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span> * k - <span class="hljs-number">1</span>; j += <span class="hljs-number">2</span>) &#123;<br>                dp[i][j + <span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j] - prices[i]);<br>                dp[i][j + <span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">2</span>], dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] + prices[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[prices.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][<span class="hljs-number">2</span> * k];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>24、买卖股票的最佳时机含冷冻期、</p><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/</a></p><ul><li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li></ul><p>1、确定dp数组以及下标的含义</p><p>dp[i] [j]，第i天状态为j，收益为dp[i] [j]。</p><ul><li>状态一：持有股票状态（今天买入股票，或者是之前就买入了股票然后没有操作，一直持有）</li><li>不持有股票状态，这里就有两种卖出股票状态<ul><li>状态二：保持卖出股票的状态（两天前就卖出了股票，度过一天冷冻期。或者是前一天就是卖出股票状态，一直没操作）</li><li>状态三：今天卖出股票</li></ul></li><li>状态四：今天为冷冻期状态，但冷冻期状态不可持续，只有一天</li></ul><p>买卖股票最佳时机 1，2，3，4 的题目讲解中，今天卖出股票」我是没有单独列出一个状态的归类为「不持有股票的状态」，而本题为什么要单独列出「今天卖出股票」 一个状态呢？</p><p>因为本题我们有<strong>冷冻期</strong>，而冷冻期的前一天，只能是 「今天卖出股票」状态，如果是 「不持有股票状态」那么就很模糊，因为不一定是 卖出股票的操作。</p><p>2、确定递推公式</p><p><strong>达到买入股票状态</strong>（状态一）即：dp[i] [0]，有两个具体操作：</p><ul><li>操作一：前一天就是持有股票状态（状态一），<strong>dp[i] [0] &#x3D; dp[i - 1] [0]</strong></li><li>操作二：今天买入了，有两种情况<ul><li>前一天是冷冻期（状态四），dp[i - 1] [3] - prices[i]</li><li>前一天是保持卖出股票的状态（状态二），dp[i - 1] [1] - prices[i]</li></ul></li></ul><p>那么dp[i] [0] &#x3D; max(dp[i - 1] [0], dp[i - 1] [3] - prices[i], dp[i - 1] [1] - prices[i]);</p><p><strong>达到保持卖出股票状态</strong>（状态二）即：dp[i] [1]，有两个具体操作：</p><ul><li>操作一：前一天就是状态二  dp[i] [1] &#x3D; <strong>dp[i-1] [1]</strong></li><li>操作二：前一天是冷冻期（状态四）dp[i] [1] &#x3D;  <strong>dp[i-1] [3]</strong></li></ul><p>dp[i] [1] &#x3D; max(dp[i - 1] [1], dp[i - 1] [3]);</p><p><strong>达到今天就卖出股票状态</strong>（状态三），即：dp[i] [2] ，只有一个操作：</p><p>昨天一定是持有股票状态（状态一），今天卖出</p><p>即：dp[i] [2] &#x3D; <strong>dp[i - 1] [0] + prices[i];</strong></p><p><strong>达到冷冻期状态</strong>（状态四），即：dp[i] [3]，只有一个操作：</p><p>昨天卖出了股票（状态三）</p><p><strong>dp[i] [3] &#x3D; dp[i - 1] [2];</strong></p><p>综上分析，递推代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) - prices[i]);<span class="hljs-comment">//状态1，保持买入状态：前一天冷冻期，今天买入或者前一天是卖出状态。</span><br>dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>]);<span class="hljs-comment">// 状态2，保持卖出状态：前一天就卖出了，或者前一天冷冻期，今天没操作</span><br>dp[i][<span class="hljs-number">2</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i];<span class="hljs-comment">// 状态3，今天卖出股票：前一天持有股票，今天卖出</span><br>dp[i][<span class="hljs-number">3</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]; <span class="hljs-comment">// 状态4 ，处于冷冻期：则昨天卖出了股票</span><br></code></pre></td></tr></table></figure><p>3、dp数组如何初始化</p><p>dp[0] [0] &#x3D; -prices[0] ：当天买入，收益就是-prices[0]。</p><p>dp[0] [1] &#x3D; 0：当天买入当天卖出，收益不变，为0。</p><p>同理，dp[0] [2] 、dp[0] [3] 都初始化为0.</p><p>4、确定遍历顺序</p><p>从递归公式上可以看出，dp[i] 依赖于 dp[i-1]，所以是从前向后遍历。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = prices.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">4</span>, <span class="hljs-number">0</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] -= prices[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 持股票</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>] - prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] - prices[i]));<br>            dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>]);<br>            dp[i][<span class="hljs-number">2</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i];<br>            dp[i][<span class="hljs-number">3</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>], <span class="hljs-built_in">max</span>(dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]));<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>最后结果是取 状态二，状态三，和状态四的最大值，不少同学会把状态四忘了，状态四是冷冻期，最后一天如果是冷冻期也可能是最大值。</strong></p><h2 id="24、买卖股票的最佳时机含手续费"><a href="#24、买卖股票的最佳时机含手续费" class="headerlink" title="24、买卖股票的最佳时机含手续费"></a>24、买卖股票的最佳时机含手续费</h2><p>每次交易需支付一次手续费，无限次交易。</p><p>对比买卖股票的最佳时机||，只是在卖出操作时计算手续费即可，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices, <span class="hljs-type">int</span> fee)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = prices.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] -= prices[<span class="hljs-number">0</span>]; <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] - prices[i]);<br>            dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i] - fee);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="25、最长上升子序列"><a href="#25、最长上升子序列" class="headerlink" title="25、最长上升子序列"></a>25、最长上升子序列</h2><p><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">https://leetcode.cn/problems/longest-increasing-subsequence/</a></p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p>当前下标i的递增子序列长度，其实和i之前的下表j的子序列长度有关系，那又是什么样的关系呢。</p><p>1、dp[i]的定义</p><p>本题中，正确定义dp数组的含义十分重要。</p><p><strong>dp[i]表示i之前包括i的以nums[i]结尾的最长递增子序列的长度</strong></p><p>为什么一定表示 “以nums[i]结尾的最长递增子序” ，因为我们在做“递增比较”的时候，如果比较 nums[j] 和 nums[i] 的大小，那么两个递增子序列一定分别以nums[j]为结尾 和 nums[i]为结尾， 要不然这个比较就没有意义了，不是尾部元素的比较那么 如何算递增呢。</p><p>2、状态转移方程（递推公式）</p><p>位置i的最长升序子序列等于<strong>j从0到i-1各个位置的最长升序子序列</strong> + 1 的最大值。</p><p>i因此：if (nums[i] &gt; nums[j]) dp[i] &#x3D; max(dp[i], dp[j] + 1);</p><p>3、dp[i]的初始化</p><p>每一个i，对应的dp[i]（即最长递增子序列）起始大小至少都是1.</p><p>4、确定遍历顺序</p><p>dp[i] 是有0到i-1各个位置的最长递增子序列 推导而来，那么遍历i一定是从前向后遍历。</p><p>j其实就是遍历0到i-1，那么是从前到后，还是从后到前遍历都无所谓，只要吧 0 到 i-1 的元素都遍历了就行了。 所以默认习惯 从前向后遍历。</p><p>遍历i的循环在外层，遍历j则在内层，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &gt; nums[j]) dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dp[i] &gt; result) result = dp[i]; <span class="hljs-comment">// 取长的子序列</span><br>&#125;<br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size(), <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] &gt; nums[j]) dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (dp[i] &gt; result) result = dp[i]; <span class="hljs-comment">// 取长的子序列</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="26、最长连续递增序列"><a href="#26、最长连续递增序列" class="headerlink" title="26、最长连续递增序列"></a>26、最长连续递增序列</h2><p><a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">https://leetcode.cn/problems/longest-continuous-increasing-subsequence/</a></p><p>本题与上题的区别在于连续。</p><p>1、确定dp数组（dp table）以及下标的含义</p><p>**dp[i]：以下标i为结尾的连续递增的子序列长度为dp[i]**。</p><p>注意这里的定义，一定是以下标i为结尾，并不是说一定以下标0为起始位置。</p><p>2、确定递推公式</p><p>如果 nums[i] &gt; nums[i - 1]，那么以 i 为结尾的连续递增的子序列长度 一定等于 以i - 1为结尾的连续递增的子序列长度 + 1 </p><p>即：<strong>dp[i] &#x3D; dp[i - 1] + 1</strong>;</p><p><strong>注意这里就体现出和上一道题目的区别！</strong></p><p>因为本题要求连续递增子序列，所以就只要比较nums[i]与nums[i - 1]，而不用去比较nums[j]与nums[i] （j是在0到i之间遍历）。</p><p>3、dp数组如何初始化</p><p>以下标i为结尾的连续递增的子序列长度最少也应该是1，即就是nums[i]这一个元素。</p><p>所以dp[i]应该初始1;</p><p>4、遍历顺序</p><p>从递推公式上可以看出， dp[i + 1]依赖dp[i]，所以一定是从前向后遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    <span class="hljs-keyword">if</span> (nums[i] &gt; nums[i - <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 连续记录</span><br>        dp[i] = dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLengthOfLCIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">1</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size() ,<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[i - <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 连续记录</span><br>                dp[i] = dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (dp[i] &gt; result) result = dp[i];<span class="hljs-comment">//取最大的值。</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="27、最长重复子数组"><a href="#27、最长重复子数组" class="headerlink" title="27、最长重复子数组"></a>27、最长重复子数组</h2><p><a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">https://leetcode.cn/problems/maximum-length-of-repeated-subarray/</a></p><p>给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度，其实就是最长公共子序列。</p><p>1、确定dp数组（dp table）以及下标的含义</p><p>dp[i] [j] ：以下标i - 1为结尾的<strong>A</strong>，和以下标j - 1为结尾的<strong>B</strong>，最长重复子数组长度为dp[i] [j]。 （<strong>特别注意</strong>： “以下标i - 1为结尾的A” 标明一定是 以A[i-1]为结尾的字符串 ）</p><p>dp[i] [j]的定义也就决定着，我们在遍历dp[i] [j]的时候i 和 j都要从1开始。为什么要从i-1和j-1开始，是为了初始化方便。</p><p>2、确定递推公式</p><p>根据dp[i] [j]的定义，dp[i] [j]的状态只能由dp[i - 1] [j - 1]推导出来。</p><p>即当A[i - 1] 和B[j - 1]相等的时候，dp[i] [j] &#x3D; dp[i - 1] [j - 1] + 1;</p><p>根据递推公式可以看出，遍历i 和 j 要从1开始！</p><p>3、dp数组如何初始化</p><p>根据dp[i] [j]的定义，dp[i] [0] 和dp[0] [j]其实都是没有意义的！</p><p>但dp[i] [0] 和dp[0] [j]要初始值，因为 为了方便递归公式dp[i] [j] &#x3D; dp[i - 1] [j - 1] + 1;</p><p>所以dp[i] [0] 和dp[0] [j]初始化为0。</p><p>举个例子A[0]如果和B[0]相同的话，dp[1] [1] &#x3D; dp[0] [0] + 1，只有dp[0] [0]初始为0，正好符合递推公式逐步累加起来。</p><p>4、确定遍历顺序</p><p>外层for循环遍历A，内层for循环遍历B。</p><p>那又有同学问了，外层for循环遍历B，内层for循环遍历A。不行么？</p><p>也行，一样的，我这里就用外层for循环遍历A，内层for循环遍历B了。</p><p>同时题目要求长度最长的子数组的长度。所以在遍历的时候顺便把dp[i] [j]的最大值记录下来。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">dp</span>(nums1.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(nums2.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<span class="hljs-comment">// dp数组的定义以及初始化，这里取num.size()+1,是因为dp数组下标的含义是到[i-1]和[j-1]结尾的最长重复子数组</span><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<span class="hljs-comment">// 记录结果，这里初始化为0，是因为后面会被覆盖。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">1</span>;i&lt;=nums1.<span class="hljs-built_in">size</span>();i++)&#123;<span class="hljs-comment">// &lt;=是因为下标含义是到[i-1]结尾</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=nums2.<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums1[i<span class="hljs-number">-1</span>] == nums2[j<span class="hljs-number">-1</span>])&#123;<br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br>                &#125; <br>                <span class="hljs-keyword">if</span>(dp[i][j] &gt; result) result =dp[i][j];<span class="hljs-comment">//要求长度最长的子数组的长度。所以在遍历的时候顺便把dp[i][j]的最大值记录下来</span><br>            &#125; <br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="28、最长公共子序列"><a href="#28、最长公共子序列" class="headerlink" title="28、最长公共子序列"></a>28、最长公共子序列</h2><p><a href="https://leetcode.cn/problems/longest-common-subsequence/">https://leetcode.cn/problems/longest-common-subsequence/</a></p><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</p><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列</p><p>1、确定dp数组（dp table）以及下标的含义</p><p>dp[i] [j]：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列的<strong>长度</strong>（个数）为dp[i] [j]。这么定义下标是为了初始化方便。</p><p>2、确定递推公式</p><p>主要就是两大情况： text1[i - 1] 与 text2[j - 1]相同，text1[i - 1] 与 text2[j - 1]不相同</p><p>如果text1[i - 1] 与 text2[j - 1]相同，那么找到了一个公共元素，所以dp[i] [j] &#x3D; dp[i - 1] [j - 1] + 1;</p><p>如果text1[i - 1] 与 text2[j - 1]不相同，那就看看text1[0, i - 2]与text2[0, j - 1]的最长公共子序列 和 text1[0, i - 1]与text2[0, j - 2]的最长公共子序列，取最大的。</p><p>即：dp[i] [j] &#x3D; max(dp[i - 1] [j], dp[i] [j - 1]);</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (text1[i - <span class="hljs-number">1</span>] == text2[j - <span class="hljs-number">1</span>]) &#123;<br>    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><p>3、dp数组如何初始化</p><p>先看看dp[i] [0]应该是多少呢？</p><p>test1[0, i-1]和空串的最长公共子序列自然是0，所以dp[i] [0] &#x3D; 0;</p><p>同理dp[0] [j]也是0。</p><p>其他下标都是随着递推公式逐步覆盖，初始为多少都可以，那么就统一初始为0。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(text1.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(text2.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br></code></pre></td></tr></table></figure><p>4、遍历顺序</p><p>从递推公式，可以看出，有三个方向可以推出dp[i] [j]，那么为了在递推的过程中，这三个方向都是经过计算的数值，所以要从前向后，从上到下来遍历这个矩阵。</p><p>代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(text1.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(text2.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= text1.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= text2.<span class="hljs-built_in">size</span>(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (text1[i - <span class="hljs-number">1</span>] == text2[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[text1.<span class="hljs-built_in">size</span>()][text2.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="29、不相交的线"><a href="#29、不相交的线" class="headerlink" title="29、不相交的线"></a>29、不相交的线</h2><p><a href="https://leetcode.cn/problems/uncrossed-lines/">https://leetcode.cn/problems/uncrossed-lines/</a></p><p>绘制一些连接两个数字 A[i] 和 B[j] 的直线，只要 A[i] &#x3D;&#x3D; B[j]，且直线不能相交！</p><p>直线不能相交，这就是说明在字符串A中 找到一个与字符串B相同的子序列，且这个子序列不能改变相对顺序，只要相对顺序不改变，链接相同数字的直线就不会相交。其实也就是说A和B的最长公共子序列是[1,4]，长度为2。 这个公共子序列指的是相对顺序不变（即数字4在字符串A中数字1的后面，那么数字4也应该在字符串B数字1的后面）</p><p>这么分析完之后，大家可以发现：<strong>本题说是求绘制的最大连线数，其实就是求两个字符串的最长公共子序列的长度！</strong></p><p>所以代码跟上一题一样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxUncrossedLines</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; A, vector&lt;<span class="hljs-type">int</span>&gt;&amp; B)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(A.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(B.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= A.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= B.<span class="hljs-built_in">size</span>(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (A[i - <span class="hljs-number">1</span>] == B[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[A.<span class="hljs-built_in">size</span>()][B.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="30、最大子序和"><a href="#30、最大子序和" class="headerlink" title="30、最大子序和"></a>30、最大子序和</h2><p><a href="https://leetcode.cn/problems/maximum-subarray/">https://leetcode.cn/problems/maximum-subarray/</a></p><p>1、确定dp数组（dp table）以及下标的含义</p><p>**dp[i]：包括下标i（以nums[i]为结尾）的最大连续子序列和为dp[i]**。</p><p>2、确定递推公式</p><p>dp[i]只有两个方向可以推出来：</p><ul><li>dp[i - 1] + nums[i]，即：nums[i]加入当前连续子序列和</li><li>nums[i]，即：从头开始计算当前连续子序列和</li></ul><p>一定是取最大的，所以dp[i] &#x3D; max(dp[i - 1] + nums[i], nums[i]);</p><p>3、dp数组如何初始化</p><p>从递推公式可以看出来dp[i]是依赖于dp[i - 1]的状态，dp[0]就是递推公式的基础。</p><p>dp[0]应该是多少呢?</p><p>根据dp[i]的定义，很明显dp[0]应为nums[0]即dp[0] &#x3D; nums[0]。</p><p>4、确定遍历顺序</p><p>递推公式中dp[i]依赖于dp[i - 1]的状态，需要从前向后遍历。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size())</span></span>;<span class="hljs-comment">//定义dp数组，并初始化大小</span><br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<span class="hljs-comment">// 初始化数组</span><br>        <span class="hljs-type">int</span> result = dp[<span class="hljs-number">0</span>];<span class="hljs-comment">// 用来记录结果</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>] + nums[i], nums[i]); <span class="hljs-comment">// 状态转移公式</span><br>            <span class="hljs-keyword">if</span> (dp[i] &gt; result) result = dp[i]; <span class="hljs-comment">// result 保存dp[i]的最大值</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="31、判断子序列"><a href="#31、判断子序列" class="headerlink" title="31、判断子序列"></a>31、判断子序列</h2><p><a href="https://leetcode.cn/problems/is-subsequence/">https://leetcode.cn/problems/is-subsequence/</a></p><p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p><p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p><p>这里s是t的子串，t的长度肯定大于s，所以要删除也是删除t中的元素。</p><p>1、确定dp数组（dp table）以及下标的含义</p><p>**dp[i] [j] 表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为dp[i] [j]**。</p><p>注意这里是判断s是否为t的子序列。即t的长度是大于等于s的。</p><p>2、确定递推公式</p><p>在确定递推公式的时候，首先要考虑如下两种操作，整理如下：</p><ul><li>if (s[i - 1] &#x3D;&#x3D; t[j - 1])<ul><li>t中找到了一个字符在s中也出现了</li></ul></li><li>if (s[i - 1] !&#x3D; t[j - 1])<ul><li>相当于t要删除元素，继续匹配</li></ul></li></ul><p>if (s[i - 1] &#x3D;&#x3D; t[j - 1])，那么dp[i] [j] &#x3D; dp[i - 1] [j - 1] + 1;，因为找到了一个相同的字符，相同子序列长度自然要在dp[i-1] [j-1]的基础上加1</p><p>if (s[i - 1] !&#x3D; t[j - 1])，此时相当于t要删除元素，t如果把当前元素t[j - 1]删除，那么dp[i] [j] 的数值就是 看s[i - 1]与 t[j - 2]的比较结果了，即：dp[i] [j] &#x3D; dp[i] [j - 1];</p><p>3、dp数组如何初始化</p><p>从递推公式可以看出dp[i] [j]都是依赖于dp[i - 1] [j - 1] 和 dp[i] [j - 1]，所以dp[0] [0]和dp[i] [0]是一定要初始化的。同理dp[0] [j]也要初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(s.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(t.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br></code></pre></td></tr></table></figure><p>4、确定遍历顺序</p><p>同理从递推公式可以看出dp[i] [j]都是依赖于dp[i - 1] [j - 1] 和 dp[i] [ j - 1]，那么遍历顺序也应该是从上到下，从左到右。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSubsequence</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(s.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(t.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<span class="hljs-comment">//定义dp数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-comment">//&lt;= 是因为表示i-1/j-1</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= t.<span class="hljs-built_in">size</span>(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (s[i - <span class="hljs-number">1</span>] == t[j - <span class="hljs-number">1</span>])<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> dp[i][j] = dp[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (dp[s.<span class="hljs-built_in">size</span>()][t.<span class="hljs-built_in">size</span>()] == s.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>dp[i] [j]表示以下标i-1为结尾的字符串s和以下标j-1为结尾的字符串t 相同子序列的长度，所以如果dp[s.size()] [t.size()] 与 字符串s的长度相同说明：s与t的最长相同子序列就是s，那么s 就是 t 的子序列。</p><h2 id="32、不同的子序列"><a href="#32、不同的子序列" class="headerlink" title="32、不同的子序列"></a>32、不同的子序列</h2><p><a href="https://leetcode.cn/problems/distinct-subsequences/">https://leetcode.cn/problems/distinct-subsequences/</a></p><p>给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</p><p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p><p>1、确定dp数组（dp table）以及下标的含义</p><p>dp[i] [j]：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i] [j]。</p><p>记住dp数组的定义，为了理解递推公式的含义，至于为什么用i-1、j-1结尾，是为了初始化方便而已，交给递推公式就可以了。</p><p>2、确定递推公式</p><p>这一类问题，基本是要分析两种情况</p><ul><li>s[i - 1] 与 t[j - 1]相等</li><li>s[i - 1] 与 t[j - 1] 不相等</li></ul><p>当s[i - 1] 与 t[j - 1]相等时，dp[i] [j]可以有两部分组成。</p><p>一部分是用s[i - 1]来匹配，那么个数为dp[i - 1] [j - 1]。即不需要考虑当前s子串和t子串的最后一位字母，所以只需要 dp[i-1] [j-1]。</p><p>一部分是不用s[i - 1]来匹配，个数为dp[i - 1] [j]。用s[i-2]取匹配。例如： s： bagg 和 t： bag ，s[3] 和 t[2]是相同的，但是字符串s也可以不用s[3]来匹配，即用s[0]s[1]s[2]组成的bag。当然也可以用s[3]来匹配，即：s[0]s[1]s[3]组成的bag。</p><p>所以当s[i - 1] 与 t[j - 1]相等时，dp[i] [j] &#x3D; dp[i - 1] [j - 1] + dp[i - 1] [j];</p><p>当s[i - 1] 与 t[j - 1]不相等时，dp[i] [j]只有一部分组成，不用s[i - 1]来匹配（就是模拟在s中删除这个元素），即：dp[i - 1] [j]</p><p>所以递推公式为：dp[i] [j] &#x3D; dp[i - 1] [j]; &#x2F;&#x2F; 即模拟在s中删除一位来匹配。</p><p><strong>为什么只考虑 “不用s[i - 1]来匹配” 这种情况， 不考虑 “不用t[j - 1]来匹配” 的情况呢。这里大家要明确，我们求的是 s 中有多少个 t，而不是 求t中有多少个s，所以只考虑 s中删除元素的情况，即 不用s[i - 1]来匹配 的情况。</strong></p><p>3、dp数组如何初始化</p><p>从递推公式dp[i] [j] &#x3D; dp[i - 1] [j - 1] + dp[i - 1] [j]; 和 dp[i] [j] &#x3D; dp[i - 1] [j]; 中可以看出dp[i] [j] 是从上方和左上方推导而来，如图：，那么 dp[i] [0] 和dp[0] [j]是一定要初始化的。</p><p>dp[i] [0] 表示：以i-1为结尾的s可以随便删除元素，出现空字符串的个数。</p><p>那么dp[i] [0]一定都是1，因为也就是把以i-1为结尾的s，删除所有元素，出现空字符串的个数就是1。</p><p>再来看dp[0] [j]，dp[0] [j]：空字符串s可以随便删除元素，出现以j-1为结尾的字符串t的个数。</p><p>那么dp[0] [j]一定都是0，s如论如何也变成不了t。</p><p>dp[0] [0]应该是1，空字符串s，可以删除0个元素，变成空字符串t。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt;&gt; <span class="hljs-built_in">dp</span>(s.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt;(t.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= s.<span class="hljs-built_in">size</span>(); i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= t.<span class="hljs-built_in">size</span>(); j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 其实这行代码可以和dp数组初始化的时候放在一起，但我为了凸显初始化的逻辑，所以还是加上了。</span><br></code></pre></td></tr></table></figure><p>4、确定遍历顺序</p><p>从递推公式dp[i] [j] &#x3D; dp[i - 1] [j - 1] + dp[i - 1] [j]; 和 dp[i] [j] &#x3D; dp[i - 1] [j]; 中可以看出dp[i] [j]都是根据左上方和正上方推出来的。所以遍历的时候一定是从上到下，从左到右，这样保证dp[i] [j]可以根据之前计算出来的数值进行计算。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numDistinct</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">uint64_t</span>&gt;&gt; <span class="hljs-built_in">dp</span>(s.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">uint64_t</span>&gt;(t.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; t.<span class="hljs-built_in">size</span>(); j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= t.<span class="hljs-built_in">size</span>(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (s[i - <span class="hljs-number">1</span>] == t[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">1</span>][j];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<span class="hljs-comment">//模拟删s</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[s.<span class="hljs-built_in">size</span>()][t.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="33、两个字符串的删除操作"><a href="#33、两个字符串的删除操作" class="headerlink" title="33、两个字符串的删除操作"></a>33、两个字符串的删除操作</h2><p><a href="https://leetcode.cn/problems/delete-operation-for-two-strings/">https://leetcode.cn/problems/delete-operation-for-two-strings/</a></p><p>对比上一道题，不同点在于两个字符串都可以删除，而不是只能删除其中一个字符串。</p><p>1、确定dp数组（dp table）以及下标的含义</p><p>dp[i] [j]：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数为dp[i] [j]。–记住定义</p><p>2、确定递推公式</p><ul><li>当word1[i - 1] 与 word2[j - 1]相同的时候</li><li>当word1[i - 1] 与 word2[j - 1]不相同的时候</li></ul><p><strong>当word1[i - 1] 与 word2[j - 1]相同的时候，dp[i] [j] &#x3D; dp[i - 1] [j - 1];</strong></p><p>当word1[i - 1] 与 word2[j - 1]不相同的时候，有三种情况：</p><p><strong>情况一</strong>：删word1[i - 1]，最少操作次数为dp[i - 1] [j] + 1</p><p><strong>情况二</strong>：删word2[j - 1]，最少操作次数为dp[i] [j - 1] + 1</p><p>情况三：同时删word1[i - 1]和word2[j - 1]，操作的最少次数为dp[i - 1] [j - 1] + 2</p><p>那最后当然是取最小值，所以当word1[i - 1] 与 word2[j - 1]不相同的时候，递推公式：dp[i] [j] &#x3D; min({dp[i - 1] [j - 1] + 2, dp[i - 1] [j] + 1, dp[i] [j - 1] + 1});</p><p>因为 dp[i] [j - 1] + 1 &#x3D; dp[i - 1] [j - 1] + 2，所以递推公式可简化为：dp[i] [j] &#x3D; min(dp[i - 1] [j] + 1, dp[i] [j - 1] + 1);</p><p>这里可能不少录友有点迷糊，从字面上理解 就是 当 同时删word1[i - 1]和word2[j - 1]，dp[i] [j-1] 本来就不考虑 word2[j - 1]了，那么我在删 word1[i - 1]，是不是就达到两个元素都删除的效果，即 dp[i] [j-1] + 1。</p><p>3、dp数组如何初始化</p><p>从递推公式中，可以看出来，dp[i] [0] 和 dp[0] [j]是一定要初始化的。</p><p>dp[i] [0]：word2为空字符串，以i-1为结尾的字符串word1要删除多少个元素，才能和word2相同呢，很明显dp[i] [0] &#x3D; i。</p><p>dp[0] [j]的话同理，所以代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(word1.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(word2.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= word1.<span class="hljs-built_in">size</span>(); i++) dp[i][<span class="hljs-number">0</span>] = i;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= word2.<span class="hljs-built_in">size</span>(); j++) dp[<span class="hljs-number">0</span>][j] = j;<br></code></pre></td></tr></table></figure><p>4、确定遍历顺序</p><p>从递推公式 dp[i] [j] &#x3D; min(dp[i - 1] [j - 1] + 2, min(dp[i - 1] [j], dp[i] [j - 1]) + 1); 和dp[i] [j] &#x3D; dp[i - 1] [j - 1]可以看出dp[i] [j]都是根据左上方、正上方、正左方推出来的。</p><p>所以遍历的时候一定是从上到下，从左到右，这样保证dp[i] [j]可以根据之前计算出来的数值进行计算。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(string word1, string word2)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(word1.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(word2.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= word1.<span class="hljs-built_in">size</span>(); i++) dp[i][<span class="hljs-number">0</span>] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= word2.<span class="hljs-built_in">size</span>(); j++) dp[<span class="hljs-number">0</span>][j] = j;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= word1.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= word2.<span class="hljs-built_in">size</span>(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (word1[i - <span class="hljs-number">1</span>] == word2[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>, dp[i][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[word1.<span class="hljs-built_in">size</span>()][word2.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="33、编辑距离"><a href="#33、编辑距离" class="headerlink" title="33、编辑距离"></a>33、编辑距离</h2><p><a href="https://leetcode.cn/problems/edit-distance/">https://leetcode.cn/problems/edit-distance/</a></p><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p>对比前两题，所涉及的字符串个数变成了两个，支持的操作变成了三种，由浅入深，本题是采用动态规划解决的经典问题。</p><p>1、确定dp数组及其下标的含义</p><p>**dp[i] [j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i] [j]**。（最少的编辑次数为 dp[i] [j],使得两个字符串相等)</p><p>2、确定递推公式</p><p>在确定递推公式的时候，首先要考虑清楚编辑的几种操作，整理如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (word1[i - <span class="hljs-number">1</span>] == word2[j - <span class="hljs-number">1</span>])<br>    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br><span class="hljs-keyword">if</span> (word1[i - <span class="hljs-number">1</span>] != word2[j - <span class="hljs-number">1</span>])<br>    增 <span class="hljs-number">1</span>删除等于<span class="hljs-number">2</span>添加，操作数量一样。考虑删除就可以了<br>    删 dp[i][j] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j] +<span class="hljs-number">1</span> ,dp[i][j<span class="hljs-number">-1</span>] +<span class="hljs-number">1</span>);<br><span class="hljs-comment">//rose--&gt;ros  ros  rose</span><br>    换 dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] +<span class="hljs-number">1</span>;<br><span class="hljs-comment">// ab ac </span><br>    取最小的：dp[i][j] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] +<span class="hljs-number">1</span>,dp[i<span class="hljs-number">-1</span>][j] +<span class="hljs-number">1</span> ,dp[i][j<span class="hljs-number">-1</span>] +<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>3、dp数组初始化</p><p>再回顾一下dp[i] [j]的定义：</p><p>**dp[i] [j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i] [j]**。</p><p>那么dp[i] [0] 和 dp[0] [j] 表示什么呢？</p><p>dp[i] [0] ：以下标i-1为结尾的字符串word1，和空字符串word2，最近编辑距离为dp[i] [0]。</p><p>那么dp[i] [0]就应该是i，对word1里的元素全部做删除操作，即：dp[i] [0] &#x3D; i;</p><p>同理dp[0] [j] &#x3D; j;</p><p>所以C++代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= word1.<span class="hljs-built_in">size</span>(); i++) dp[i][<span class="hljs-number">0</span>] = i;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= word2.<span class="hljs-built_in">size</span>(); j++) dp[<span class="hljs-number">0</span>][j] = j;<br></code></pre></td></tr></table></figure><p>4、遍历顺序</p><p>在dp矩阵中一定是从左到右从上到下去遍历</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(string word1, string word2)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(word1.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(word2.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= word1.<span class="hljs-built_in">size</span>(); i++) dp[i][<span class="hljs-number">0</span>] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= word2.<span class="hljs-built_in">size</span>(); j++) dp[<span class="hljs-number">0</span>][j] = j;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= word1.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= word2.<span class="hljs-built_in">size</span>(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (word1[i - <span class="hljs-number">1</span>] == word2[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = <span class="hljs-built_in">min</span>(&#123;dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]&#125;) + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[word1.<span class="hljs-built_in">size</span>()][word2.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="34、回文子串"><a href="#34、回文子串" class="headerlink" title="34、回文子串"></a>34、回文子串</h2><p><a href="https://leetcode.cn/problems/palindromic-substrings/">https://leetcode.cn/problems/palindromic-substrings/</a></p><p>1、确定dp数组（dp table）以及下标的含义</p><p>布尔类型的dp[i] [j]：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是dp[i] [j]为true，否则为false。</p><p>2、确定递推公式</p><p>在确定递推公式时，就要分析如下几种情况。</p><p>整体上是两种，就是s[i]与s[j]相等，s[i]与s[j]不相等这两种。</p><p>当s[i]与s[j]不相等，那没啥好说的了，dp[i] [j]一定是false。</p><p>当s[i]与s[j]相等时，这就复杂一些了，有如下三种情况</p><ul><li>情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串</li><li>情况二：下标i 与 j相差为1，例如aa，也是回文子串</li><li>情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看dp[i + 1] [j - 1]是否为true。</li></ul><p>以上三种情况分析完了，那么递归公式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (s[i] == s[j]) &#123;<br>    <span class="hljs-keyword">if</span> (j - i &lt;= <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 情况一 和 情况二</span><br>        result++;<br>        dp[i][j] = <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 情况三</span><br>        result++;<br>        dp[i][j] = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的result是统计回文子串的数量。</p><p>3、确定遍历顺序</p><p>如果这矩阵是从上到下，从左到右遍历，那么会用到没有计算过的dp[i + 1] [j - 1]，也就是根据不确定是不是回文的区间[i+1,j-1]，来判断了[i,j]是不是回文，那结果一定是不对的。</p><p><strong>所以一定要从下到上，从左到右遍历，这样保证dp[i + 1] [j - 1]都是经过计算的</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;  <span class="hljs-comment">// 注意遍历顺序</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; s.<span class="hljs-built_in">size</span>(); j++) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] == s[j]) &#123;<br>            <span class="hljs-keyword">if</span> (j - i &lt;= <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 情况一 和 情况二</span><br>                result++;<br>                dp[i][j] = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 情况三</span><br>                result++;<br>                dp[i][j] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>整体代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">dp</span>(s.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(s.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">false</span>));<span class="hljs-comment">// 初始化为false</span><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;  <span class="hljs-comment">// 注意遍历顺序</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; s.<span class="hljs-built_in">size</span>(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (s[i] == s[j]) &#123;<br>                    <span class="hljs-keyword">if</span> (j - i &lt;= <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 情况一 和 情况二</span><br>                        result++;<br>                        dp[i][j] = <span class="hljs-literal">true</span>;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 情况三</span><br>                        result++;<br>                        dp[i][j] = <span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="35、最长回文子序列（的长度）"><a href="#35、最长回文子序列（的长度）" class="headerlink" title="35、最长回文子序列（的长度）"></a>35、最长回文子序列（的长度）</h2><p><a href="https://leetcode.cn/problems/longest-palindromic-subsequence/">https://leetcode.cn/problems/longest-palindromic-subsequence/</a></p><p>1、确定dp数组（dp table）以及下标的含义</p><p>**dp[i] [j]：字符串s在[i, j]范围内最长的回文子序列的长度为dp[i] [j]**。</p><p>2、确定递推公式</p><p>在判断回文子串的题目中，关键逻辑就是看s[i]与s[j]是否相同。</p><p>如果s[i]与s[j]相同，那么dp[i] ] &#x3D; dp[i + 1] [j - 1] + 2;（dp数组的含义代表的是长度，前后加上两个字符，所以是+2）</p><p>如果s[i]与s[j]不相同，说明s[i]和s[j]的同时加入 并不能增加[i,j]区间回文子序列的长度，那么分别加入s[i]、s[j]看看哪一个可以组成最长的回文子序列。</p><p>加入s[j]的回文子序列长度为dp[i + 1] [j]。–去掉头字符，加上尾字符</p><p>加入s[i]的回文子序列长度为dp[i] [j - 1]。–去掉尾字符，加上头字符</p><p>那么dp[i] [j]一定是取最大的，即：dp[i] [j] &#x3D; max(dp[i + 1] [j], dp[i] [j - 1]);</p><p>3、dp数组初始化</p><p>首先要考虑当i 和j 相同的情况，从递推公式：dp[i] [j] &#x3D; dp[i + 1] [ j - 1] + 2; 可以看出 递推公式是计算不到 i 和j相同时候的情况。</p><p>所以需要手动初始化一下，当i与j相同，那么dp[i] [j]一定是等于1的，即：一个字符的回文子序列长度就是1。</p><p>其他情况dp[i] [j]初始为0就行，这样递推公式：dp[i] [j] &#x3D; max(dp[i + 1] [j], dp[i] [j - 1]); 中dp[i] [j]才不会被初始值覆盖。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(s.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(s.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) dp[i][i] = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>4、确定遍历顺序</p><p>从递归公式中，可以看出，dp[i] [j] 依赖于 dp[i + 1] [j - 1] ，dp[i + 1] [j] 和 dp[i] [j - 1]，<strong>所以遍历i的时候一定要从下到上遍历，这样才能保证下一行的数据是经过计算的</strong>。j的话，可以正常从左向右遍历</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestPalindromeSubseq</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(s.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(s.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) dp[i][i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; s.<span class="hljs-built_in">size</span>(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (s[i] == s[j]) &#123;<br>                    dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i + <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="回溯算法刷题总结"><a href="#回溯算法刷题总结" class="headerlink" title="回溯算法刷题总结"></a>回溯算法刷题总结</h1><h2 id="1、回溯算法理论基础"><a href="#1、回溯算法理论基础" class="headerlink" title="1、回溯算法理论基础"></a>1、回溯算法理论基础</h2><p>回溯算法也叫回溯搜索法，是一种暴力搜索方式，它是递归的副产品，有递归就会有回溯。</p><p>回溯法的性能如何呢，这里要和大家说清楚了，<strong>虽然回溯法很难，很不好理解，但是回溯法并不是什么高效的算法</strong>。</p><p><strong>因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案</strong>，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。</p><p>那么既然回溯法并不高效为什么还要用它呢？</p><p>因为没得选，一些问题能暴力搜出来就不错了，撑死了再剪枝一下，还没有更高效的解法。</p><p>回溯法，一般可以解决如下几种问题：</p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独等等</li></ul><p>回溯算法模板框架如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">void backtracking(参数) &#123;<br>    if (终止条件) &#123;<br>        存放结果;<br>        return;<br>    &#125;<br><br>    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        backtracking(路径，选择列表); // 递归<br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（1）确定返回值和参数，返回值一般是void，但回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。</p><p>（2）确定回溯函数的终止条件</p><p>（3）确定单层回溯搜索的逻辑</p><h2 id="2、组合问题"><a href="#2、组合问题" class="headerlink" title="2、组合问题"></a>2、组合问题</h2><p><a href="https://leetcode.cn/problems/combinations/">https://leetcode.cn/problems/combinations/</a></p><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p><p>示例: 输入: n &#x3D; 4, k &#x3D; 2 输出: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ]</p><p>k&#x3D;2可以通过两层for循环暴力搜索出来，当n&#x3D;100，k&#x3D;50的情况呢？连暴力搜素都无从下手，所以考虑回溯算法。</p><p>我们把组合问题抽象成树形结构来理解：</p><p><img src="C:\Users\zhangdengsheng\AppData\Roaming\Typora\typora-user-images\image-20240527141917546.png" alt="image-20240527141917546"></p><p><strong>每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围</strong>。</p><p><strong>图中可以发现n相当于树的宽度，k相当于树的深度</strong>。</p><p>1、确定返回值以及参数</p><p>我们需要定义两个全局变量来收集结果，一个用来收集单层符合条件的结果，一个用来收集最后汇总的结果集合。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result; <span class="hljs-comment">// 存放符合条件结果的集合</span><br>vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 用来存放单层符合条件结果</span><br></code></pre></td></tr></table></figure><p>函数里面需要有以下参数：题目要求的n和k，这是必须的两个参数，即在n个数里找n个数的组合。为了确保每次取完一个元素，下一轮就不能在取了，需要一个参数startIndex来控制每一层取的数不会重复。具体实现看代码就明白了。</p><p>所以函数的参数及返回值如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> startIndex)</span></span><br></code></pre></td></tr></table></figure><p>2、确定回溯的终止条件</p><p>数组的大小path跟k相等了，说明找到了一个子集大小为k的组合了，就满足单层终止条件了。此时用result二维数组，把path保存起来，并终止本层递归。</p><p>所以终止条件为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() == k) &#123;<span class="hljs-comment">// path数组大小等于题目要求的子集包含的个数</span><br>    result.<span class="hljs-built_in">push_back</span>(path);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、单层搜索的过程</p><p>回溯法的搜索过程就是一个树型结构的遍历过程，在如下图中，可以看出for循环用来横向遍历，递归的过程是纵向遍历。</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201123195242899.png" alt="77.组合1"></p><p>for循环每次从startIndex开始遍历，然后用path保存取到的节点i。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt;= n; i++) &#123; <span class="hljs-comment">// 控制树的横向遍历</span><br>    path.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 处理节点</span><br>    <span class="hljs-built_in">backtracking</span>(n, k, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 递归：控制树的纵向遍历，注意下一层搜索要从i+1开始</span><br>    path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯，撤销处理的节点</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出backtracking（递归函数）通过不断调用自己一直往深处遍历，总会遇到叶子节点，遇到了叶子节点就要返回。</p><p>backtracking的下面部分就是回溯的操作了，撤销本次处理的结果。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-comment">// 1、确定参数和返回值</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result; <span class="hljs-comment">// 用来保存最终结果</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 用来保存单一符合条件的结果</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> startIndex)</span></span>&#123;<br><span class="hljs-comment">// 2、确定终止条件（找到结果就保存，返回）</span><br>    <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == k)&#123;<br>        result.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><span class="hljs-comment">// 3、回溯和递归的逻辑</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex;i&lt;=n;i++)&#123; <span class="hljs-comment">// 横向遍历</span><br>        path.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 处理节点</span><br>        <span class="hljs-built_in">backtracking</span>(n,k,i+<span class="hljs-number">1</span>); <span class="hljs-comment">// 递归，此时startIndex要更新，防止重复遍历（纵向遍历）</span><br>        path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯，撤销处理的节点</span><br>    &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-built_in">backtracking</span>(n,k,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>本题可以剪枝优化的，<strong>如果for循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索了</strong>。</p><p>注意代码中i，就是for循环里选择的起始位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt;= n; i++) &#123;<br></code></pre></td></tr></table></figure><p>接下来看一下优化过程如下：</p><ol><li>已经选择的元素个数：path.size();</li><li>所需需要的元素个数为: k - path.size();</li><li>列表中剩余元素（n-i） &gt;&#x3D; 所需需要的元素个数（k - path.size()）</li><li>在集合n中至多要从该起始位置 : i &lt;&#x3D; n - (k - path.size()) + 1，开始遍历</li></ol><p>为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。</p><p>举个例子，n &#x3D; 4，k &#x3D; 3， 目前已经选取的元素为0（path.size为0），n - (k - 0) + 1 即 4 - ( 3 - 0) + 1 &#x3D; 2。</p><p>从2开始搜索都是合理的，可以是组合[2, 3, 4]。也就是说后面元素个数都不够凑出你要求的集合个数了，就没必要遍历了。</p><p>优化后的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> startIndex)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() == k) &#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt;= n - (k - path.<span class="hljs-built_in">size</span>()) + <span class="hljs-number">1</span>; i++) &#123; <span class="hljs-comment">// 优化的地方</span><br>            path.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 处理节点</span><br>            <span class="hljs-built_in">backtracking</span>(n, k, i + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯，撤销处理的节点</span><br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-built_in">backtracking</span>(n, k, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="3、组合总和"><a href="#3、组合总和" class="headerlink" title="3、组合总和|||"></a>3、组合总和|||</h2><p><a href="https://leetcode.cn/problems/combination-sum-iii/">https://leetcode.cn/problems/combination-sum-iii/</a></p><p>找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p><p>说明：</p><ul><li>所有数字都是正整数。</li><li>解集不能包含重复的组合。</li></ul><p>示例 1: 输入: k &#x3D; 3, n &#x3D; 7 输出: [[1,2,4]]</p><p>示例 2: 输入: k &#x3D; 3, n &#x3D; 9 输出: [[1,2,6], [1,3,5], [2,3,4]]</p><p>本题与上题相比，控制了组合里总共的元素个数，增加了和为n的条件。k是控制每个子集的元素个数。</p><p>1、确定回溯函数的参数（返回值为void）</p><p>同上到题目一样，依然需要path和result，分别用来收集满足单层条件的结果以及最后总的结果。</p><p>还需要以下参数：</p><p>targetSum：满足条件的子集的总和，即题目要求的n。</p><p>k：题目要求的子集的元素个数</p><p>sum：已经收集的元素的和，即path里的元素之和。</p><p>startIndex：下一层循环的起始位置</p><p>所以代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>vector&lt;<span class="hljs-type">int</span>&gt; path;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> targetSum, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startIndex)</span></span><br></code></pre></td></tr></table></figure><p>2、确定终止条件</p><p>当path里收集的元素个数等于题目要求的子集元素个数k，就可以终止搜索了，此时再判断path里元素的总和（sum）是否满足targetSum（即题目要求的n）</p><p>终止代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() == k) &#123;<br>    <span class="hljs-keyword">if</span> (sum == targetSum) result.<span class="hljs-built_in">push_back</span>(path);<br>    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 如果path.size() == k 但sum != targetSum 直接返回</span><br>&#125;<br></code></pre></td></tr></table></figure><p>3、单层搜索过程</p><p>组合里元素总数为9，for循环固定i&lt;&#x3D;9;</p><p>处理过程就是 path收集每次选取的元素，相当于树型结构里的边，sum来统计path里元素的总和。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt;= <span class="hljs-number">9</span>; i++) &#123;<br>    sum += i;<br>    path.<span class="hljs-built_in">push_back</span>(i);<br>    <span class="hljs-built_in">backtracking</span>(targetSum, k, sum, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 注意i+1调整startIndex</span><br>    sum -= i; <span class="hljs-comment">// 回溯</span><br>    path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>别忘了处理过程 和 回溯过程是一一对应的，处理有加，回溯就要有减！</strong></p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br><span class="hljs-comment">// targetSum:目标和n； k集合中元素个数；sum：已经手机的元素和；startIndex ：下一层for循环搜索的起始位置</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backTracking</span><span class="hljs-params">(<span class="hljs-type">int</span> targetSum,<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> sum,<span class="hljs-type">int</span> startIndex)</span></span>&#123;<span class="hljs-comment">// 1、确定返回值和传入的参数</span><br>    <span class="hljs-comment">// 2、确定终止条件</span><br>    <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == k)&#123;<br>        <span class="hljs-keyword">if</span>(sum == targetSum) result.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 如果path.size() == k，但是sum ！= targetSum，直接返回</span><br>    &#125;<br>    <span class="hljs-comment">// 3、单层处理逻辑</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex;i&lt;=<span class="hljs-number">9</span>;i++)&#123;<span class="hljs-comment">// 横向</span><br>        sum += i;<br>        path.<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-built_in">backTracking</span>(targetSum,k,sum,i+<span class="hljs-number">1</span>); <span class="hljs-comment">// i+1是调整startIndex的 纵向</span><br>        sum -= i;<span class="hljs-comment">// 回溯</span><br>        path.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum3</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-built_in">backTracking</span>(n,k,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>本题也可以考虑剪枝操作：当sum已经大于targetSum了，再往后遍历也找不到满足条件的子集了，所以在回溯函数之前加个判断：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (sum &gt; targetSum) &#123; <span class="hljs-comment">// 剪枝操作</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>同时，关于元素个数的限制，同上一题：for (int i &#x3D; startIndex; i &lt;&#x3D; 9 - (k - path.size()) + 1; i++) { &#x2F;&#x2F; 剪枝</p><p>剪枝后的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result; <span class="hljs-comment">// 存放结果集</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 符合单层条件的结果</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> targetSum, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startIndex)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sum &gt; targetSum) &#123; <span class="hljs-comment">// 剪枝操作</span><br>            <span class="hljs-keyword">return</span>; <br>        &#125;<br>        <span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() == k) &#123;<br>            <span class="hljs-keyword">if</span> (sum == targetSum) result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 如果path.size() == k 但sum != targetSum 直接返回</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt;= <span class="hljs-number">9</span> - (k - path.<span class="hljs-built_in">size</span>()) + <span class="hljs-number">1</span>; i++) &#123; <span class="hljs-comment">// 剪枝</span><br>            sum += i; <span class="hljs-comment">// 处理</span><br>            path.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 处理</span><br>            <span class="hljs-built_in">backtracking</span>(targetSum, k, sum, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 注意i+1调整startIndex</span><br>            sum -= i; <span class="hljs-comment">// 回溯</span><br>            path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯</span><br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum3</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n) &#123;<br>        result.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">// 可以不加</span><br>        path.<span class="hljs-built_in">clear</span>();   <span class="hljs-comment">// 可以不加</span><br>        <span class="hljs-built_in">backtracking</span>(n, k, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="4、组合总和"><a href="#4、组合总和" class="headerlink" title="4、组合总和"></a>4、组合总和</h2><p><a href="https://leetcode.cn/problems/combination-sum/">https://leetcode.cn/problems/combination-sum/</a></p><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的数字可以无限制重复被选取。</p><p>与上一题相比，本题没有数量要求了，每个元素可以重复选取，但有总和的限制，间接的有了个数的限制。</p><p>1、确定递归（回溯）的参数</p><p>定义两个全局变量，result用来收集最终结果，path用来收集单层符合条件的结果。</p><p>然后题目中给的数组candidates和目标和target，另外需要定义一个sum来收集符合条件的path里的元素的和与target进行比较。本题依然需要startIndex来控制for循环的起始位置。</p><p>综上所述：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>vector&lt;<span class="hljs-type">int</span>&gt; path;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startIndex)</span></span><br></code></pre></td></tr></table></figure><p>2、递归的终止条件</p><p>当sum&#x3D;&#x3D;target的时候，收集结果。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (sum &gt; target) &#123;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (sum == target) &#123;<br>    result.<span class="hljs-built_in">push_back</span>(path);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、单层搜索的逻辑</p><p>依然是从startIndex开始搜索，但本题的元素可以重复选取，不用控制下一层从i+1开始了，因此在递归的时候传入的startIndex不用再+1了。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; candidates.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    sum += candidates[i];<span class="hljs-comment">//计算path里的元素和</span><br>    path.<span class="hljs-built_in">push_back</span>(candidates[i]);<span class="hljs-comment">//收集元素</span><br>    <span class="hljs-built_in">backtracking</span>(candidates, target, sum, i); <span class="hljs-comment">// 关键点:不用i+1了，表示可以重复读取当前的数</span><br>    sum -= candidates[i];   <span class="hljs-comment">// 回溯，回退到加上元素之前的和</span><br>    path.<span class="hljs-built_in">pop_back</span>();        <span class="hljs-comment">// 回溯，元素出栈</span><br>&#125;<br></code></pre></td></tr></table></figure><p>最后的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result; <span class="hljs-comment">// 收集结果</span><br>    vector&lt;<span class="hljs-type">int</span>&gt;path; <span class="hljs-comment">// 单次符合条件的结果</span><br>    <span class="hljs-comment">// 1、确定返回值和参数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target,<span class="hljs-type">int</span> sum,<span class="hljs-type">int</span> startIndex)</span></span>&#123;<br>    <span class="hljs-comment">// 2、确定终止条件</span><br>        <span class="hljs-keyword">if</span>(sum &gt; target)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum == target)&#123;<br>            result.<span class="hljs-built_in">push_back</span>(path); <span class="hljs-comment">// 收集结果</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    <span class="hljs-comment">// 3、单层搜索条件</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i&lt;candidates.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            sum += candidates[i];<br>            path.<span class="hljs-built_in">push_back</span>(candidates[i]);<span class="hljs-comment">//处理节点</span><br>            <span class="hljs-built_in">backtracking</span>(candidates,target,sum,i);<span class="hljs-comment">// 此处i不用加1了，因为元素可以重复</span><br>            sum -= candidates[i];<br>            path.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">// 回溯</span><br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracking</span>(candidates,target,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>5、组合总和||</p><p><a href="https://leetcode.cn/problems/combination-sum-ii/">https://leetcode.cn/problems/combination-sum-ii/</a></p><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中只能使用一次。</p><p>本题同上面一题的区别是，元素只能使用一次了，并且数组中有重复的元素，且解集不能包含重复的组合。</p><p>这就涉及到了组合问题的去重操作。</p><p>组合问题可以抽象为树形结构，那么“使用过”在这个树形结构上是有两个维度的，一个维度是同一树枝上使用过，一个维度是同一树层上使用过。<strong>没有理解这两个层面上的“使用过” 是造成大家没有彻底理解去重的根本原因。</strong></p><p>本题的要求是元素在同一个组合内是可以重复的，怎么重复都没事，但两个组合不能相同。</p><p><strong>所以我们要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重</strong>。</p><p>1、确定函数参数</p><p>其他参数同上题一样，但需要加入一个used数组，来记录同一树枝上元素的使用情况（用过1，没用过0）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result; <span class="hljs-comment">// 存放组合集合</span><br>vector&lt;<span class="hljs-type">int</span>&gt; path;           <span class="hljs-comment">// 符合条件的组合</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startIndex, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used)</span></span><br></code></pre></td></tr></table></figure><p>2、确定终止条件</p><p>同上题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (sum &gt; target) &#123;<span class="hljs-comment">// 如果有剪枝操作，这里可以省略</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (sum == target) &#123;<br>    result.<span class="hljs-built_in">push_back</span>(path);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、单层搜索的逻辑</p><p>这里要注重去重的操作，即根据used数组来判断元素是否在同一层使用过，或在同一树枝被使用过。</p><p>**如果<code>candidates[i] == candidates[i - 1]</code> 并且 <code>used[i - 1] == false</code>，就说明：前一个树枝，使用了candidates[i - 1]，也就是说同一树层使用过candidates[i - 1]**。此时在同一层上，有两个重复的元素candidates[i] </p><p>和candidates[i-1],这里就不能重复选取了，要跳过。</p><p>在candidates[i] &#x3D;&#x3D; candidates[i - 1]相同的情况下：</p><ul><li>used[i - 1] &#x3D;&#x3D; true，说明同一树枝candidates[i - 1]使用过</li><li>used[i - 1] &#x3D;&#x3D; false，说明同一树层candidates[i - 1]使用过</li></ul><p>因此单层搜索的逻辑代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target; i++) &#123;<br>    <span class="hljs-comment">// used[i - 1] == true，说明同一树枝candidates[i - 1]使用过</span><br>    <span class="hljs-comment">// used[i - 1] == false，说明同一树层candidates[i - 1]使用过</span><br>    <span class="hljs-comment">// 要对同一树层使用过的元素进行跳过</span><br>    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>] == <span class="hljs-literal">false</span>) &#123;<br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    sum += candidates[i];<br>    path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>    used[i] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-built_in">backtracking</span>(candidates, target, sum, i + <span class="hljs-number">1</span>, used); <span class="hljs-comment">// 和39.组合总和的区别1：这里是i+1，每个数字在每个组合中只能使用一次</span><br>    used[i] = <span class="hljs-literal">false</span>;<br>    sum -= candidates[i];<br>    path.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>sum + candidates[i] &lt;&#x3D; target为剪枝操作</strong>：即如果下一层的值加上当前总和已经大于目标值了，就没必要继续了。</p><p><strong>对总集合排序之后，如果下一层的sum（就是本层的 sum + candidates[i]）已经大于target，就可以结束本轮for循环的遍历</strong>。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startIndex, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sum == target) &#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target; i++) &#123;<br>            <span class="hljs-comment">// used[i - 1] == true，说明同一树枝candidates[i - 1]使用过</span><br>            <span class="hljs-comment">// used[i - 1] == false，说明同一树层candidates[i - 1]使用过</span><br>            <span class="hljs-comment">// 要对同一树层使用过的元素进行跳过</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>] == <span class="hljs-literal">false</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            sum += candidates[i];<br>            path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            used[i] = <span class="hljs-literal">true</span>;<span class="hljs-comment">//标记used数组</span><br>            <span class="hljs-built_in">backtracking</span>(candidates, target, sum, i + <span class="hljs-number">1</span>, used); <span class="hljs-comment">// 和组合总和的区别1，这里是i+1，每个数字在每个组合中只能使用一次</span><br>            used[i] = <span class="hljs-literal">false</span>;<span class="hljs-comment">//回溯，这里说明当uesd[i-1]=fales,其实是进行回溯，所以同一层有使用过。</span><br>            sum -= candidates[i];<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum2</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(candidates.size(), <span class="hljs-literal">false</span>)</span></span>;<br>        path.<span class="hljs-built_in">clear</span>();<br>        result.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-comment">// 首先把给candidates排序，让其相同的元素都挨在一起。</span><br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(), candidates.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">backtracking</span>(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, used);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>注意：去重操作需要对数组进行排序！</p><h2 id="5、分割回文串"><a href="#5、分割回文串" class="headerlink" title="5、分割回文串"></a>5、分割回文串</h2><p><a href="https://leetcode.cn/problems/palindrome-partitioning/">https://leetcode.cn/problems/palindrome-partitioning/</a></p><p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。</p><p>返回 s 所有可能的分割方案。</p><p>示例: 输入: “aab” 输出: [ [“aa”,”b”], [“a”,”a”,”b”] ]</p><p>切割问题类似于组合问题，</p><ul><li>组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中再选取第三个…..。</li><li>切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中再切割第三段…..。</li></ul><p>所以也可以用组合问题的思路来解决分割子串的问题，抽象成树形结构。</p><p>1、确定递归函数的参数</p><p>记录结果的result，收集单层切割结果的path，以及控制元素不重复的startIndex。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;string&gt;&gt; result;<br>vector&lt;string&gt; path; <span class="hljs-comment">// 放已经回文的子串</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> startIndex)</span></span><br></code></pre></td></tr></table></figure><p>2、确定终止条件</p><p>切割线切到子串的最后位置，切割完毕，startIndex就代表这条切割线。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> startIndex)</span> </span>&#123;<br>    <span class="hljs-comment">// 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了</span><br>    <span class="hljs-keyword">if</span> (startIndex &gt;= s.<span class="hljs-built_in">size</span>()) &#123;<br>        result.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、单层搜索逻辑</p><p>在<code>for (int i = startIndex; i &lt; s.size(); i++)</code>循环中，我们 定义了起始位置startIndex，那么 [startIndex, i] 就是要截取的子串，只要判断子串s[startIndex,i]是不是回文串，如果是，加入到单层结果中，不是则跳过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPalindrome</span>(s, startIndex, i)) &#123; <span class="hljs-comment">// 是回文子串</span><br>        <span class="hljs-comment">// 获取[startIndex,i]在s中的子串</span><br>        string str = s.<span class="hljs-built_in">substr</span>(startIndex, i - startIndex + <span class="hljs-number">1</span>);<br>        path.<span class="hljs-built_in">push_back</span>(str);<br>    &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 如果不是则直接跳过</span><br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-built_in">backtracking</span>(s, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 寻找i+1为起始位置的子串，因为切割过得元素（位置）不能重复切割。</span><br>    path.<span class="hljs-built_in">pop_back</span>();        <span class="hljs-comment">// 回溯过程，弹出本次已经添加的子串</span><br>&#125;<br></code></pre></td></tr></table></figure><p>那么如何判断是否为回文子串呢，可以使用双指针法，一个指针从前向后，一个指针从后向前，如果前后指针所指向的元素是相等的，就是回文字符串了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start, j = end; i &lt; j; i++, j--) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] != s[j]) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;string&gt;&gt; result;<br>    vector&lt;string&gt; path; <span class="hljs-comment">// 放已经回文的子串</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> startIndex)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了</span><br>        <span class="hljs-keyword">if</span> (startIndex &gt;= s.<span class="hljs-built_in">size</span>()) &#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPalindrome</span>(s, startIndex, i)) &#123;   <span class="hljs-comment">// 是回文子串</span><br>                <span class="hljs-comment">// 获取[startIndex,i]在s中的子串</span><br>                string str = s.<span class="hljs-built_in">substr</span>(startIndex, i - startIndex + <span class="hljs-number">1</span>);<br>                path.<span class="hljs-built_in">push_back</span>(str);<br>            &#125; <span class="hljs-keyword">else</span> &#123;                                <span class="hljs-comment">// 不是回文，跳过</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-built_in">backtracking</span>(s, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 寻找i+1为起始位置的子串</span><br>            path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯过程，弹出本次已经添加的子串</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start, j = end; i &lt; j; i++, j--) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] != s[j]) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">partition</span>(string s) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracking</span>(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>八股基础</title>
    <link href="/2024/05/10/%E5%85%AB%E8%82%A1%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/05/10/%E5%85%AB%E8%82%A1%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="1、从输入URL到页面展示期间发生了什么？"><a href="#1、从输入URL到页面展示期间发生了什么？" class="headerlink" title="1、从输入URL到页面展示期间发生了什么？"></a>1、从输入URL到页面展示期间发生了什么？</h2><p>（1）<strong>检查缓存</strong>：浏览器收到用户请求后，先检查浏览器缓存里是否有该资源，如果有直接返回；如果没有，进入下一步网络请求。</p><p>（2）<strong>DNS域名解析</strong>：进行网络请求之前需要获取请求域名的IP地址，（HTTP协议）。如果是HTTPS，还需要建立TLS连接。DNS解析时会按照本地浏览器缓存-&gt;本地HOST文件-&gt;路由器缓存-&gt;DNS服务器-&gt;根DNS服务器的顺序查询域名对应IP地址，直到找到为止。</p><p>DNS 中的域名都是用<strong>句点</strong>来分隔的，比如 <code>www.server.com.</code>，这里的句点代表了不同层次之间的<strong>界限</strong>。在域名中，<strong>越靠右</strong>的位置表示其层级<strong>越高</strong>。</p><p>（3）<strong>浏览器与服务器IP建立TCP连接</strong>（可靠传输）：建立连接后，浏览器端构建请求行、请求头等信息，并把和该域名相关的Cookie等数据附加到请求头中，向服务器构建请求信息。（由协议栈（TCP、IP)提供可靠传输–&gt;IP（远程定位）–&gt;MAC（两点传输）–&gt;网卡–&gt;交换机–&gt;路由器）</p><p>（4）<strong>服务器收到请求信息，根据请求生成响应数据，发给浏览器</strong>。</p><p>（5）<strong>浏览器解析服务器的响应数据</strong>：若响应头状态码为301、302，会重新定向到新地址（IP中的ICMP、ARP功能）；若响应数据类型是字节流类型，一般会将请求交给下载管理器；若是HTML类型，会进入下一步渲染流程。</p><p>（6）<strong>浏览器解析HTML文件</strong>，创建DOM树，解析CSS进行样式计算，然后将CSS与DOM合并，构建渲染树，最后布局和绘制渲染树，完成页面展示。</p><h2 id="2、HTTP常见面试题"><a href="#2、HTTP常见面试题" class="headerlink" title="2、HTTP常见面试题"></a>2、HTTP常见面试题</h2><h3 id="（1）什么是HTTP（超文本传输协议）"><a href="#（1）什么是HTTP（超文本传输协议）" class="headerlink" title="（1）什么是HTTP（超文本传输协议）"></a>（1）什么是HTTP（超文本传输协议）</h3><p>超文本：文字、图片、视频的混合体</p><p>传输：计算机世界中实现两点之间传输</p><p>协议：计算机世界里的约定和规范</p><p>即<strong>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</strong></p><h3 id="（2）HTTP常见的状态码有哪些"><a href="#（2）HTTP常见的状态码有哪些" class="headerlink" title="（2）HTTP常见的状态码有哪些"></a>（2）HTTP常见的状态码有哪些</h3><p><code>1xx</code> 类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少。</p><p><code>2xx</code> 类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态。</p><ul><li>「<strong>200 OK</strong>」是最常见的成功状态码，表示一切正常。如果是非 <code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据。</li><li>「<strong>204 No Content</strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</li><li>「<strong>206 Partial Content</strong>」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li></ul><p><code>3xx</code> 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</p><ul><li>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</li><li>「<strong>302 Found</strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</li></ul><p>301 和 302 都会在响应头里使用字段 <code>Location</code>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p><ul><li>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。</li></ul><p><code>4xx</code> 类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</p><ul><li>「<strong>400 Bad Request</strong>」表示客户端请求的报文有错误，但只是个笼统的错误。</li><li>「<strong>403 Forbidden</strong>」表示服务器禁止访问资源，并不是客户端的请求出错。</li><li>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li></ul><p><code>5xx</code> 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</p><ul><li>「<strong>500 Internal Server Error</strong>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</li><li>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li><li>「<strong>502 Bad Gateway</strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li><li>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。</li></ul><h3 id="（3）HTTP的常见字段有哪些"><a href="#（3）HTTP的常见字段有哪些" class="headerlink" title="（3）HTTP的常见字段有哪些"></a>（3）HTTP的常见字段有哪些</h3><p>HOST字段：客户端发送请求时，用来指定服务器的域名。</p><p>Content-Length 字段：服务器在返回数据时，会有 <code>Content-Length</code> 字段，表明本次回应的数据长度。</p><p><strong>HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决“粘包”的问题</strong></p><p>Connection 字段：<code>Connection</code> 字段最常用于客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用。</p><p>Content-Type 字段：<code>Content-Type</code> 字段用于服务器回应时，告诉客户端，本次数据是什么格式。</p><p>Content-Encoding 字段：<code>Content-Encoding</code> 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式。</p><h3 id="（4）-GET和POST有什么区别"><a href="#（4）-GET和POST有什么区别" class="headerlink" title="（4） GET和POST有什么区别"></a>（4） GET和POST有什么区别</h3><p>作用不同：GET用于从服务器获取资源；POST一般用来向服务器提交数据。</p><p>参数传递的方式不同：GET请求一般写在URL中，只接受ASCII字符。POST请求参数一般放在请求体中，对于数据类型也没有限制。</p><p>安全性不同：由于传递参数方式不同，GET请求直接暴露在URL中，一般不用来传递敏感信息。</p><p>参数长度限制不同：GET传输量较小，不能大于2KB；POST传递的数据量较大，一般默认不受限制。</p><p>编码方式不同：GET只进行URL编码，POST支持多种编码方式。</p><p>缓存机制不同：GET请求会被浏览器主动cache，POST不会，需要手动设置。GET请求参数会被完整保留在浏览器历史里，POST中的参数不会被保留。GET产生的URL可以被保存为书签，POST不可以。GET在浏览器回退时是无害的，POST会再次提交请求。</p><p>时间消耗不同：GET产生一个TCP数据包，POST产生两个TCP数据包。</p><p>先说明下安全和幂等的概念：</p><ul><li><p>在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。</p></li><li><p>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。</p></li><li><p><strong>GET 方法就是安全且幂等的</strong>，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，<strong>可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签</strong>。</p></li><li><p><strong>POST</strong> 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等</strong>的。所以，<strong>浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签</strong>。</p></li></ul><h3 id="（5）HTTP的缓存方式"><a href="#（5）HTTP的缓存方式" class="headerlink" title="（5）HTTP的缓存方式"></a>（5）HTTP的缓存方式</h3><p>缓存解决什么问题：减少不必要的网络传输，节约带宽；更快地加载页面，提高响应速度；减少服务器的负载，避免服务过载的情况出现。</p><p>强制缓存：浏览器判断请求的目标资源是否有效命中强缓存，如果命中，则直接从缓存中读取目标资源，无需与服务器通信，也就是说决定是否使用缓存的主动性在于浏览器这边。</p><p>Expires强缓存：设置一个强缓存时间，此时间范围内，从内存中读取并返回，但是因为其判断缓存过期的机制是获取本地时间戳，与之前拿到的资源文件的Expires字段时间进行比较，存在漏洞：如果本地时间不准怎么办，目前已被弃用。</p><p>Cache-Control强缓存：</p><ul><li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；</li><li>浏览器再次请求访问服务器中的该资源时，会先<strong>通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期</strong>，如果没有，则使用该缓存，否则重新请求服务器；</li><li>服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control</li></ul><p>max-age决定客户端资源被缓存多久；s-maxage决定代理服务器缓存多长时间；no-cache表示强制进行协商缓存；no-store表示禁止任何缓存策略；public表示资源既可以被浏览器缓存也可以被代理服务器缓存。private表示资源只能被浏览器缓存，默认为private。</p><p>基于Last-modified的协商缓存：</p><p>首先在服务器端读出资源文件的修改时间，将读出来的修改时间赋值给响应头的last-modified字段，然后设置Cache-Control为no-cache（强制协商缓存），当客户端读取到last-modified的时候，会在下次请求的的头部携带一个If-Modified-Since,即服务器第一次修改的时候给他的时间。之后每次对该资源进行请求，都会带上If-Modified-Since字段，服务器会拿着个字段并再次读取该资源的修改时间，进行比较，决定是读取缓存还是返回新资源。</p><p>缺点：根据修改时间做判断，如果内容没修改那也有可能更新文件修改时间（重命名-再改回来），文件内容没修改但缓存失效了；当文件在极短时间内修改完成，文件修改时间以秒为单位未检测到毫秒级的改变，此时文件内容被修改了，但缓存依然可用，并不发送新文件。-<em>-存在的问题</em></p><p>基于Etag的协商缓存：将原先协商缓存的比较时间戳的形式修改成了比较文件指纹（根据文件内容计算的唯一哈希值），解决了Last-Modified存在的问题。</p><p>第一次请求某资源的时候，服务端读取文件并计算文件指纹，将文件指纹放在响应头的Etag字段中跟随资源一起返回给客户端。第二次请求某资源的时候，客户端从缓存中读取上一次服务端返回的Etag（文件指纹），并赋值给请求头的if-none-match字段，让其跟随请求一起发回服务端。服务端接收到请求头中的if-node-match（上一次的文件指纹），并对目标资源文件再次读取并生成文件指纹，两个文件指纹进行对比，如果吻合，则直接返回304状态码和空的响应并return，如果不吻合，将新的文件指纹存储到Etag并返回给客户端。</p><p>缺点：Etag需要计算文件指纹，服务端需要更多的计算开销，如果文件尺寸大且计算频繁，会影响服务器性能。同时，Etag有强验证和弱验证，强验证需要将生成的哈希码深入到每个字节，文件中只有一个字节被改变，也会生成不同的哈希值，非常消耗服务器资源。弱验证通过提取文件的部分属性来生成哈希值，不必精确到每个字节，速度快，但准确率不高，会降低协商缓存的有效性。</p><h3 id="（6）HTTP1-0与HTTP1-1的区别"><a href="#（6）HTTP1-0与HTTP1-1的区别" class="headerlink" title="（6）HTTP1.0与HTTP1.1的区别"></a>（6）HTTP1.0与HTTP1.1的区别</h3><p>1、长连接</p><p>HTTP1.1支持长连接，每一个TCP连接上可以传送多个HTTP请求和响应，默认开启Connection： Keep-Alive。</p><p>HTTP1.0默认是短连接，每次请求都需要建立一个TCP连接。</p><p>2、缓存</p><p>HTTP1.0主要使用If-Modified_Since、Expires来作为缓存判断标准</p><p>HTTP1.1则引入了更多的缓存控制策略 比如Entity tag、If-None-Match等更多可选择的缓存头来控制缓存策略。</p><p>3、管道化</p><p>基于HTTP1.1的长连接，是的请求管道化成为可能，管道化能使得请求并行传输，但响应必须按照请求发出的顺序依次返回，性能在一定程度上得到了改善。</p><p>4、增加了Host字段</p><p>使得一个服务器可以创建多个web站点。</p><p>5、状态码</p><p>新增了24个错误状态响应码</p><p>6、带宽优化</p><p>HTTP1.0中，存在浪费带宽的现象，例如客户端只是需要某个资源的一部分，但服务器将整个资源对象传输过来，不支持断点续传功能。</p><p>HTTP1.1中加入了range头域，它允许之请求资源的某个部分，返回码是<code>206</code>（Partial content）。</p><h3 id="（7）HTTP2-0与HTTP1-1的区别"><a href="#（7）HTTP2-0与HTTP1-1的区别" class="headerlink" title="（7）HTTP2.0与HTTP1.1的区别"></a>（7）HTTP2.0与HTTP1.1的区别</h3><p>1、二进制分帧</p><p>HTTP2.0在应用层和传输层之间增加了一个二进制分帧层，突破了HTTP1.1的性能限制，改进了传输性能，实现低延迟高吞吐量。</p><p>2、多路复用（MultiPlexing）</p><p>允许通过单一的HTTP2.0连接发起多重的请求-响应消息，这个功能基于“二进制分帧”的特性。</p><p>3、首部压缩</p><p>HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header数据进行压缩。减少了数据体积，使得传输更快。高效的压缩算法可以尽量压缩header，减少发送包的数量从而降低延迟。</p><p>4、服务端推送</p><p>HTTP2.0中，服务器可以对客户端的一个请求发送多个响应，即服务器可以额外的向客户端推送资源，无需客户端明确的请求。</p><h3 id="（8）HTTPS的工作原理（HTTPS是怎么建立连接的）"><a href="#（8）HTTPS的工作原理（HTTPS是怎么建立连接的）" class="headerlink" title="（8）HTTPS的工作原理（HTTPS是怎么建立连接的）"></a>（8）HTTPS的工作原理（HTTPS是怎么建立连接的）</h3><p>首先，客户端向服务器发送请求报文，请求与服务端建立连接。服务端产生应一对公私密钥，然后将自己的公钥发送给CA机构，CA机构也有一对公私秘钥，CA机构使用自己的私钥将服务端发送过来的公钥进行加密，产生一个CA数字证书。（客户端–&gt;服务端&lt;–&gt;CA机构)</p><p>服务端响应客户端的请求，将CA机构生成的数字证书发送给客户端。(服务端–&gt;客户端)</p><p>客户端将服务端发送过来的数字证书进行解析，验证数字证书是否合法，不合法会发送警告，如果合法，取出服务端生成的公钥。客户端取出公钥并生成一个随机码key（对称加密中的秘钥），客户端将加密后的随机码key发送给服务端，作为之后对称加密的秘钥。（客户端–&gt;服务端）</p><p>服务端接收到随机码key（秘钥）后，使用服务端自己的私钥对他解密，然后获得这个随机码key。服务端使用这个随机码key对传输的数据进行加密，然后将加密后的内容发送给客户端。（服务端–&gt;客户端）</p><p>客户端使用自己生成的随机码key（密码）解密服务端发送过来的数据，之后客户端和服务端通过  对称加密传输数据，随机码key作为传输的秘钥。</p><p>（9）HTTPS与HTTP的区别</p><p>1、HTTP是明文传输，HTTPS通过SSL&#x2F;TLS进行加密。</p><p>2、HTTP的端口是80，HTTPS的端口是443</p><p>3、HTTPS需要到CA申请证书</p><p>4、HTTP的连接简单，是无状态的，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全。</p><h3 id="（9）DNS及其查询过程"><a href="#（9）DNS及其查询过程" class="headerlink" title="（9）DNS及其查询过程"></a>（9）DNS及其查询过程</h3><p>DNS（域名管理系统），当用户使用浏览器访问网址的时候，使用的第一个重要协议，解决的是域名和IP地址映射的问题。</p><p>用户在浏览器输入URL地址之后，会先在浏览器缓存中查询是否有该域名对应的IP地址。</p><p>如果浏览器缓存中没有，会去计算机本地的Host文件中查询是否有对应的缓存，是否有该域名对应的IP地址。</p><p>如果Host文件中也没有则会向本地DNS服务器发送一个DNS查询请求。本地DNS解析器没有缓存该域名的解析记录，它会向根DNS服务器发出查询请求，根DNS服务器不负责具体的域名解析，它会告诉本地DNS服务器应该向哪个顶级域DNS服务器发送查询请求。</p><p>本地DNS服务器接着向顶级域DNS服务器发送查询请求，顶级域DNS服务器也不负责具体的域名解析，它会告诉本地DNS服务器前往哪个权威域名DNS服务器发送查询请求。</p><p>本地DNS服务器接着向权威DNS服务器发送查询请求，权威DNS服务器是负责存储特定域名和IP地址映射的服务器。当权威DNS服务器收到查询请求是，会查找“example.com”域名对应的IP地址，并将结果返回给本地DNS服务器。</p><p>本地DNS服务器将收到的IP地址返回给浏览器，并将域名解析结果缓存在本地，以便下次更快响应。</p><h3 id="（10）HTTP多个TCP连接怎么实现"><a href="#（10）HTTP多个TCP连接怎么实现" class="headerlink" title="（10）HTTP多个TCP连接怎么实现"></a>（10）HTTP多个TCP连接怎么实现</h3><p>多个tcp连接是靠某些服务器对Connection： keep-alive的Header的支持。即完成这个HTTP请求之后，不要断开HTTP请求使用的TCP连接，这样的好处是连接可以被重复使用，之后发送的HTTP请求不需要重新建立新的TCP连接，并且SSL的开销也可以避免。</p><h3 id="（11）TCP的keepalive和HTTP的keep-alive是一个东西吗"><a href="#（11）TCP的keepalive和HTTP的keep-alive是一个东西吗" class="headerlink" title="（11）TCP的keepalive和HTTP的keep-alive是一个东西吗"></a>（11）TCP的keepalive和HTTP的keep-alive是一个东西吗</h3><p>HTTP的keep-alive，是由应用层（用户态）实现的，成为HTTP长连接：—<strong>保持成为长连接</strong></p><p>每次请求都要经历这样的过程：建立TCP-&gt;请求资源-&gt;响应资源-&gt;释放连接，这是HTTP短连接，但是这样每次建立连接都只能请求一次资源，所以HTTP通过keep-alive实现了使用同一个TCP连接来发送和接收多个HTTP请求，避免了连接建立和释放的开销，即HTTP长连接。</p><p>TCP的keepalive，是由TCP层（内核态）实现的，称为TCP保活机制。—<strong>判断是否存活</strong></p><p>TCP有一个定时任务倒计时，超时后会触发任务，内容是发送一个探测报文给对端，用来判断对端是否存活。</p><h2 id="3、TCP连接如何确保可靠性"><a href="#3、TCP连接如何确保可靠性" class="headerlink" title="3、TCP连接如何确保可靠性"></a>3、TCP连接如何确保可靠性</h2><p>1、数据块大小控制：应用数据被分割成TCP认为最合适发送的数据块，在传输给网络层，数据块被称为报文段或段。</p><p>2、序列号：TCP给每个数据包指定序列号，接收方根据序列号对数据包进行排序，并根据序列号对数据包进行去重。</p><p>3、校验和：TCP将保持首部和数据的校验和，这是一个端到端的校验和，目的是检测数据在传输过程中的任何变化，如果收到的报文的校验和有误，TCP将丢弃这个报文段和不确认收到此报文段（对面要重新发送或采取别的措施）</p><p>4、流量控制：TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据，当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止数据包丢失。TCP利用滑动窗口实现流量控制。</p><p>5、拥塞控制：当网络拥塞时，减少数据的发送。（有其拥塞控制算法）</p><p>6、确认应答：用过ARQ协议实现。基本原理是每发完一个分组就停止发送，等待对方确认。如果没收到确定就重新发送数据包，直到确认后再发送下一个分组。</p><p>7、超时重传：当TCP发出一个数据段后，启动一个定时器，等待目的端的确认收到这个报文段，如果在定时器时间内没收到，将重新发送这个报文段。 <strong>超时重传时间 RTO 的值应该略大于报文往返 RTT 的值</strong></p><p>还有一种实现重传机制的方式叫：<code>SACK</code>（ Selective Acknowledgment）， <strong>选择性确认</strong>。</p><p>这种方式需要在 TCP 头部「选项」字段里加一个 <code>SACK</code> 的东西，它<strong>可以将已收到的数据的信息发送给「发送方」</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong>。</p><h2 id="4、既然提到了拥塞控制，拥塞控制是怎么实现的？"><a href="#4、既然提到了拥塞控制，拥塞控制是怎么实现的？" class="headerlink" title="4、既然提到了拥塞控制，拥塞控制是怎么实现的？"></a>4、既然提到了拥塞控制，拥塞控制是怎么实现的？</h2><p>拥塞控制算法主要有以下几种：</p><p>1、慢启动</p><p>在连接刚开始时，发送方会逐渐增加发送窗口的大小，以指数增长的速度增加发送窗口的数据量。</p><p>2、拥塞避免</p><p>一旦慢启动阶段过去，发送方进入拥塞避免阶段，在这个阶段，发送方会逐渐增加发送窗口的大小，但增加速率较慢，以线性增长的方式，避免过快增加导致网络拥塞。</p><p>3、超时重传</p><p>如果发送方在超时时间内未收到确认，他会认为数据包丢失，并重传这些数据包。这是拥塞控制的最后手段，用于检测和处理网络中的丢包和拥塞情况。</p><p>4、快速重传</p><p>当发送方发送的数据包丢失或者网络出现拥塞时，接收方会重复发送确认通知（ACK）来通知发送方有数据丢失，当发送方收到三次重复确认时，在超时时间到期内立刻重新发送丢失的数据包，而不是等超时之后再发，这样可以减少网络的拥塞程度。</p><p>5、拥塞窗口调整</p><p>发送方根据网络的拥塞程度动态调整发送窗口的大小，通过监测网络延迟和丢包情况来确定合适的发送速率，以避免网络拥塞。</p><h2 id="5、Cookie和Session是什么，有什么区别？"><a href="#5、Cookie和Session是什么，有什么区别？" class="headerlink" title="5、Cookie和Session是什么，有什么区别？"></a>5、Cookie和Session是什么，有什么区别？</h2><p>Cookie和Session都用于管理用户的状态和身份。</p><p>Cookie通过在客户端记录信息来确定用户身份。</p><p>Session通过在服务器端记录信息确定用户身份。</p><p>1、Cookie</p><p>Cook是存储在用户浏览器中的小型文本文件，用于在用户和服务器之间传递数据。通常服务器会将一个或多个Cookie发送到用户浏览器，然后浏览器将这些Cookie存储在本地。</p><p>服务端在接收到来自客户端浏览器的请求之后，能够通过分析存放于请求头中的Cookie得到客户端特有的信息，从而动态生成与该客户端相对应的内容。</p><p>2、Session</p><p>客户端浏览器访问服务器的时候，服务器把客户端信息以某种新式记录在服务器上，即Session。Session主要用于维护用户登录状态、存储用户的临时数据和上下文信息等。</p><p>3、区别</p><p>存储位置：Cookie存储于用户的浏览器中，Session存储于服务器上。</p><p>数据容量：Cookie存储容量较小，一般为几KB，Session存储容量较大，通常没有固定限制，取决于服务器的配置和资源。</p><p>安全性：Cookie存储于用户浏览器中可以被用户读取和篡改。相比之下，Session存储于服务器上更难被访问和修改。</p><p>传输方式：Cookie在每次HTTP请求中会被自动发送到服务器，而Session ID通常通过Cookie或者URL参数传递。</p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="1、进程和线程的区别"><a href="#1、进程和线程的区别" class="headerlink" title="1、进程和线程的区别"></a>1、进程和线程的区别</h2><p>进程是系统进行资源分配和调度的基本单位。</p><p>线程是操作系统能够进行运算调度的最小单位。线程是进程的子任务，是进程内的执行单元。一个进程至少有一个线程，一个进程可以运行多个线程，这些线程共享一块内存。</p><p>资源开销：</p><p>进程：由于每个进程都有独立的内存空间，创建和销毁进程的开销较大。进程间切换需要保存和恢复整个进程的状态，因此上下文切换的开销较高。</p><p>线程：线程共享相同的内存空间，创建和销毁线程的开销较小。线程间切换只需保存和恢复少量的线程上下文，因此上下文的切换开销较小。</p><p>通信与同步:</p><p>进程：由于进程间相互隔离，进程之间的通信需要一些特殊机制，如管道、消息队列、共享内存等方式。</p><p>线程：由于线程共享相同的内存空间，他们之间可以直接访问共享数据，线程间通信更加方便。</p><p>安全性：</p><p>进程：由于进程间相互隔离，一个进程的崩溃不会影响其他进程的稳定性。</p><p>线程：由于线程共享相同的内存空间，一个线程的错误可能会影响整个进程的稳定性。</p><h2 id="2、进程的调度算法你了解多少？"><a href="#2、进程的调度算法你了解多少？" class="headerlink" title="2、进程的调度算法你了解多少？"></a>2、进程的调度算法你了解多少？</h2><p>进程都希望自己能够占用 CPU 进行工作，那么这涉及到前面说过的进程上下文切换。</p><p>一旦操作系统把进程切换到运行状态，也就意味着该进程占用着 CPU 在执行，但是当操作系统把进程切换到其他状态时，那就不能在 CPU 中执行了，于是操作系统会选择下一个要运行的进程，选择一个进程运行这一功能是在操作系统中完成的，通常称为<strong>调度程序</strong></p><p>01、先来先服务调度算法（FCFS）</p><p>顾名思义，先来后到，<strong>每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。</strong></p><p>这似乎很公平，但是当一个长作业先运行了，那么后面的短作业等待的时间就会很长，不利于短作业。</p><p>FCFS 对长作业有利，适用于 CPU 繁忙型作业的系统，而不适用于 I&#x2F;O 繁忙型作业的系统。</p><p>02、最短作业优先调度算法</p><p><strong>最短作业优先（*Shortest Job First, SJF*）调度算法</strong>同样也是顾名思义，它会<strong>优先选择运行时间最短的进程来运行</strong>，这有助于提高系统的吞吐量。</p><p>这显然对长作业不利，很容易造成一种极端现象。比如，一个长作业在就绪队列等待运行，而这个就绪队列有非常多的短作业，那么就会使得长作业不断的往后推，周转时间变长，致使长作业长期不会被运行。</p><p>03、高响应比优先调度算法</p><p>前面两种没有权衡长短作业的利弊，那么，<strong>高响应比优先 （*Highest Response Ratio Next, HRRN*）调度算法</strong>主要是权衡了短作业和长作业。<strong>每次进行进程调度时，先计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行</strong>。</p><p>优先权 &#x3D; （等待时间+要求服务时间）&#x2F;要求服务时间</p><ul><li>如果两个进程的「等待时间」相同时，「要求的服务时间」越短，「响应比」就越高，这样短作业的进程容易被选中运行；</li><li>如果两个进程「要求的服务时间」相同时，「等待时间」越长，「响应比」就越高，这就兼顾到了长作业进程，因为进程的响应比可以随时间等待的增加而提高，当其等待时间足够长时，其响应比便可以升到很高，从而获得运行的机会</li></ul><p>一个进程的要求服务时间是不可预估的，所以高响应比优先调度算法是理想算法，现实中实现不了。</p><p>04、时间片轮转调度算法</p><p>最古老、最简单、最公平且使用最广的算法就是<strong>时间片轮转（*Round Robin, RR*）调度算法</strong>。</p><p><strong>每个进程被分配一个时间段，称为时间片（*Quantum*），即允许该进程在该时间段中运行。</strong></p><ul><li>如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配给另外一个进程；</li><li>如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换；</li></ul><p>另外，时间片的长度就是一个很关键的点：</p><ul><li>如果时间片设得太短会导致过多的进程上下文切换，降低了 CPU 效率；</li><li>如果设得太长又可能引起对短作业进程的响应时间变长。</li></ul><p>一般来说，时间片设为 <code>20ms~50ms</code> 通常是一个比较合理的折中值。</p><p>05、最高优先级调度算法</p><p>前面的「时间片轮转算法」做了个假设，即让所有的进程同等重要，也不偏袒谁，大家的运行时间都一样。</p><p>但是，对于多用户计算机系统就有不同的看法了，它们希望调度是有优先级的，即希望调度程序能<strong>从就绪队列中选择最高优先级的进程进行运行，这称为最高优先级（*Highest Priority First，HPF*）调度算法</strong>。</p><p>进程的优先级可以分为，静态优先级和动态优先级：</p><ul><li>静态优先级：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化；</li><li>动态优先级：根据进程的动态变化调整优先级，比如如果进程运行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升高其优先级，也就是<strong>随着时间的推移增加等待进程的优先级</strong>。</li></ul><p>该算法也有两种处理优先级高的方法，非抢占式和抢占式：</p><ul><li>非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程。</li><li>抢占式：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。</li></ul><p>但是依然有缺点，可能会导致低优先级的进程永远不会运行。</p><p>06、多级反馈队列调度算法</p><p><strong>多级反馈队列（*Multilevel Feedback Queue*）调度算法</strong>是「时间片轮转算法」和「最高优先级算法」的综合和发展。</p><p>顾名思义：</p><ul><li><p>「多级」表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短。</p></li><li><p>「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列；</p></li><li><p>设置了多个队列，赋予每个队列不同的优先级，每个<strong>队列优先级从高到低</strong>，同时<strong>优先级越高时间片越短</strong>；</p></li><li><p>新的进程会被放入到第一级队列的末尾，按先来先服务的原则排队等待被调度，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成；</p></li><li><p>当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行；</p></li></ul><p>可以发现，对于短作业可能可以在第一级队列很快被处理完。对于长作业，如果在第一级队列处理不完，可以移入下次队列等待被执行，虽然等待的时间变长了，但是运行时间也变更长了，所以该算法很好的<strong>兼顾了长短作业，同时有较好的响应时间。</strong></p><h2 id="3、进程间有哪些通信方式"><a href="#3、进程间有哪些通信方式" class="headerlink" title="3、进程间有哪些通信方式?"></a>3、进程间有哪些通信方式?</h2><p>每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以进程之间要通信必须通过内核。</p><p>1、管道（匿名管道</p><p>半双工的通信方式，数据只能单向流动而且只能在具有父子进程关系的进程间使用。使用 <code>fork</code> 创建子进程，<strong>创建的子进程会复制父进程的文件描述符</strong>，这样就做到了两个进程各有两个「 <code>fd[0]</code> 与 <code>fd[1]</code>」，两个进程就可以通过各自的 fd 写入和读取同一个管道文件实现跨进程通信了。</p><p>2、命名管道</p><p>也叫做FIFO，也是半双工通信方式，但是允许无亲缘关系的进程之间的提通信。</p><p><strong>管道这种通信方式效率低，不适合进程间频繁地交换数据</strong>。当然，它的好处，自然就是简单，同时也我们很容易得知管道里的数据已经被另一个进程读取了。</p><p>不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循<strong>先进先出</strong>原则，不支持 lseek 之类的文件定位操作</p><p>3、消息队列</p><p>前面说到管道的通信方式是效率低的，因此管道不适合进程间频繁地交换数据。</p><p>对于这个问题，<strong>消息队列</strong>的通信模式就可以解决。比如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。同理，B 进程要给 A 进程发送消息也是如此。</p><p>再来，<strong>消息队列是保存在内核中的消息链表</strong>，在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。</p><p>消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在，而前面提到的匿名管道的生命周期，是随进程的创建而建立，随进程的结束而销毁。</p><p>消息这种模型，两个进程之间的通信就像平时发邮件一样，你来一封，我回一封，可以频繁沟通了。</p><p>但邮件的通信方式存在不足的地方有两点，<strong>一是通信不及时，二是附件也有大小限制</strong>，这同样也是消息队列通信不足的点。</p><p><strong>消息队列不适合比较大数据的传输</strong>，因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限。在 Linux 内核中，会有两个宏定义 <code>MSGMAX</code> 和 <code>MSGMNB</code>，它们以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度。</p><p><strong>消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销</strong>，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。</p><p>4、共享内存</p><p>消息队列的读取和写入的过程，都会有发生用户态与内核态之间的消息拷贝过程。那<strong>共享内存</strong>的方式，就很好的解决了这一问题。</p><p>现代操作系统，对于内存管理，采用的是虚拟内存技术，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程 A 和 进程 B 的虚拟地址是一样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。</p><p><strong>共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中</strong>。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。</p><p>5、信号量</p><p>用了共享内存通信方式，带来新的问题，那就是如果多个进程同时修改同一个共享内存，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。</p><p>为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，<strong>信号量</strong>就实现了这一保护机制。</p><p><strong>信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据</strong>。</p><p>信号量表示资源的数量，控制信号量的方式有两种原子操作：</p><ul><li>一个是 <strong>P 操作</strong>，这个操作会把信号量减去 1，相减后如果信号量 &lt; 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 &gt;&#x3D; 0，则表明还有资源可使用，进程可正常继续执行。</li><li>另一个是 <strong>V 操作</strong>，这个操作会把信号量加上 1，相加后如果信号量 &lt;&#x3D; 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程；</li></ul><p>P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。</p><p>信号初始化为 <code>1</code>，就代表着是<strong>互斥信号量</strong>，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。</p><p>我们可以初始化信号量为 <code>0</code>，就可以用信号量来实现多进程同步的方式，它可以保证进程 A 应在进程 B 之前执行。</p><p>6、信号</p><p>上面说的进程间通信，都是常规状态下的工作模式。<strong>对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。</strong></p><p>信号跟信号量虽然名字相似度 66.66%，但两者用途完全不一样，就好像 Java 和 JavaScript 的区别。</p><p>在 Linux 操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义。我们可以通过 <code>kill -l</code> 命令，查看所有的信号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">kill</span> -l</span><br> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP<br> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1<br>11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM<br>16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP<br>21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ<br>26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR<br>31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3<br>38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8<br>43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13<br>48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12<br>53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7<br>58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2<br>63) SIGRTMAX-1  64) SIGRTMAX<br></code></pre></td></tr></table></figure><p>运行在 shell 终端的进程，我们可以通过键盘输入某些组合键的时候，给进程发送信号。例如</p><ul><li>Ctrl+C 产生 <code>SIGINT</code> 信号，表示终止该进程；</li><li>Ctrl+Z 产生 <code>SIGTSTP</code> 信号，表示停止该进程，但还未结束；</li></ul><p>如果进程在后台运行，可以通过 <code>kill</code> 命令的方式给进程发送信号，但前提需要知道运行中的进程 PID 号，例如：</p><ul><li>kill -9 1050 ，表示给 PID 为 1050 的进程发送 <code>SIGKILL</code> 信号，用来立即结束该进程；</li></ul><p>所以，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令）。</p><p>信号是进程间通信机制中<strong>唯一的异步通信机制</strong>，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。</p><p><strong>1.执行默认操作</strong>。Linux 对每种信号都规定了默认操作，例如，上面列表中的 SIGTERM 信号，就是终止进程的意思。</p><p><strong>2.捕捉信号</strong>。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。</p><p><strong>3.忽略信号</strong>。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 <code>SIGKILL</code> 和 <code>SEGSTOP</code>，它们用于在任何时候中断或结束某一进程。</p><p>7、socket套接字</p><p>前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想<strong>跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。</strong></p><p>实际上，Socket 通信不仅可以跨网络与不同主机的进程间通信，还可以在同主机上进程间通信。</p><p>我们来看看创建 socket 的系统调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">socket</span><span class="hljs-params">(<span class="hljs-type">int</span> domain, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span> protocal)</span><br></code></pre></td></tr></table></figure><p>三个参数分别代表：</p><ul><li>domain 参数用来指定协议族，比如 AF_INET 用于 IPV4、AF_INET6 用于 IPV6、AF_LOCAL&#x2F;AF_UNIX 用于本机；</li><li>type 参数用来指定通信特性，比如 SOCK_STREAM 表示的是字节流，对应 TCP、SOCK_DGRAM 表示的是数据报，对应 UDP、SOCK_RAW 表示的是原始套接字；</li><li>protocal 参数原本是用来指定通信协议的，但现在基本废弃。因为协议已经通过前面两个参数指定完成，protocol 目前一般写成 0 即可；</li></ul><p>根据创建 socket 类型的不同，通信的方式也就不同：</p><ul><li>实现 TCP 字节流通信： socket 类型是 AF_INET 和 SOCK_STREAM；</li><li>实现 UDP 数据报通信：socket 类型是 AF_INET 和 SOCK_DGRAM；</li><li>实现本地进程间通信： 「本地字节流 socket 」类型是 AF_LOCAL 和 SOCK_STREAM，「本地数据报 socket 」类型是 AF_LOCAL 和 SOCK_DGRAM。另外，AF_UNIX 和 AF_LOCAL 是等价的，所以 AF_UNIX 也属于本地 socket；</li></ul><p>总结</p><p>由于每个进程的用户空间都是独立的，不能相互访问，这时就需要借助内核空间来实现进程间通信，原因很简单，每个进程都是共享一个内核空间。</p><p>Linux 内核提供了不少进程间通信的方式，其中最简单的方式就是管道，管道分为「匿名管道」和「命名管道」。</p><p><strong>匿名管道</strong>顾名思义，它没有名字标识，匿名管道是特殊文件只存在于内存，没有存在于文件系统中，shell 命令中的「<code>|</code>」竖线就是匿名管道，通信的数据是<strong>无格式的流并且大小受限</strong>，通信的方式是<strong>单向</strong>的，数据只能在一个方向上流动，如果要双向通信，需要创建两个管道，再来<strong>匿名管道是只能用于存在父子关系的进程间通信</strong>，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失。</p><p><strong>命名管道</strong>突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用命名管道的前提，需要在文件系统创建一个类型为 p 的设备文件，那么毫无关系的进程就可以通过这个设备文件进行通信。另外，不管是匿名管道还是命名管道，进程写入的数据都是<strong>缓存在内核</strong>中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循<strong>先进先出</strong>原则，不支持 lseek 之类的文件定位操作。</p><p><strong>消息队列</strong>克服了管道通信的数据是无格式的字节流的问题，消息队列实际上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数据类型，发送数据时，会被分成一个一个独立的消息体，当然接收数据时，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的数据是正确的。消息队列通信的速度不是最及时的，毕竟<strong>每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程。</strong></p><p><strong>共享内存</strong>可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，<strong>它直接分配一个共享空间，每个进程都可以直接访问</strong>，就像访问进程自己的空间一样快捷方便，不需要陷入内核态或者系统调用，大大提高了通信的速度，享有<strong>最快</strong>的进程间通信方式之名。但是便捷高效的共享内存通信，<strong>带来新的问题，多进程竞争同个共享资源会造成数据的错乱。</strong></p><p>那么，就需要<strong>信号量</strong>来保护共享资源，以确保任何时刻只能有一个进程访问共享资源，这种方式就是互斥访问。<strong>信号量不仅可以实现访问的互斥性，还可以实现进程间的同步</strong>，信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 <strong>P 操作和 V 操作</strong>。</p><p>与信号量名字很相似的叫<strong>信号</strong>，它俩名字虽然相似，但功能一点儿都不一样。信号是<strong>异步通信机制</strong>，信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令），一旦有信号发生，<strong>进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、3. 忽略信号</strong>。有两个信号是应用进程无法捕捉和忽略的，即 <code>SIGKILL</code> 和 <code>SIGSTOP</code>，这是为了方便我们能在任何时候结束或停止某个进程。</p><p>前面说到的通信机制，都是工作于同一台主机，如果<strong>要与不同主机的进程间通信，那么就需要 Socket 通信了</strong>。Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。</p><p>以上，就是进程间通信的主要机制了。你可能会问了，那线程通信间的方式呢？</p><p>同个进程下的线程之间都是共享进程的资源，只要是共享变量都可以做到线程间通信，比如全局变量，所以对于线程间关注的不是通信方式，而是关注多线程竞争共享资源的问题，信号量也同样可以在线程间实现互斥与同步：</p><ul><li>互斥的方式，可保证任意时刻只有一个线程访问共享资源；</li><li>同步的方式，可保证线程 A 应在线程 B 之前执行；</li></ul><h2 id="4、什么是死锁以及如何避免死锁？"><a href="#4、什么是死锁以及如何避免死锁？" class="headerlink" title="4、什么是死锁以及如何避免死锁？"></a>4、什么是死锁以及如何避免死锁？</h2><p><strong>死锁是指两个或多个线程在争夺系统资源时，由于相互等待对方释放资源而无法继续执行的状态。</strong></p><p>在多线程编程中，我们为了防止多线程竞争共享资源而导致数据错乱，都会在操作共享资源之前加上互斥锁，只有成功获得到锁的线程，才能操作共享资源，获取不到锁的线程就只能等待，直到锁被释放。</p><p>那么，当两个线程为了保护两个不同的共享资源而使用了两个互斥锁，那么这两个互斥锁应用不当的时候，可能会造成<strong>两个线程都在等待对方释放锁</strong>，在没有外力的作用下，这些线程会一直相互等待，就没办法继续运行，这种情况就是发生了<strong>死锁</strong></p><p>死锁只有<strong>同时满足</strong>以下四个条件才会发生：</p><ul><li>互斥条件：多个线程不能同时使用同一个资源</li><li>持有并等待条件：一个线程因为请求另外的资源被阻塞的时候，不会释放自己目前持有的资源。</li><li>不可剥夺条件：资源不能被强制性的从一个进程中夺走，只能由持有者资源释放释放。</li><li>环路等待条件：多个进程之间形成一个环形等待资源的链路，每个进程都在等待下一个进程释放自己所占有的资源</li></ul><p>只要破坏上面任意一个条件就可以破坏死锁。</p><p>破坏请求与保持条件：一次性申请所有的资源</p><p>破坏不可剥夺条件：占用资源的线程在申请其他资源被堵塞时，可以主动释放他已经占有的资源。</p><p>破坏循环等待条件：使用资源有序分配法，让所有进程按照相同的顺序请求资源，释放资源则反序释放。</p><p>总结：</p><p>简单来说，死锁问题的产生是由两个或者以上线程并行执行的时候，争夺资源而互相等待造成的。</p><p>死锁只有同时满足互斥、持有并等待、不可剥夺、环路等待这四个条件的时候才会发生。</p><p>所以要避免死锁问题，就是要破坏其中一个条件即可，<strong>最常用的方法就是使用资源有序分配法来破坏环路等待条件</strong></p><h2 id="5、什么是虚拟内存，为什么需要虚拟内存？"><a href="#5、什么是虚拟内存，为什么需要虚拟内存？" class="headerlink" title="5、什么是虚拟内存，为什么需要虚拟内存？"></a><strong>5、什么是虚拟内存，为什么需要虚拟内存？</strong></h2><p>虚拟内存在每一个进程创建加载的过程中，会分配一个连续的虚拟地址空间，他不是真实存在的，而是通过映射与实际地址空间对应，这样就可以是每个进程看起来都有自己独立的连续地址空间，并允许程序访问比物理内存更大的地址空间，每个程序都可以认为它拥有足够大的内存来运行。</p><p>需要虚拟内存有以下原因：</p><p>内存扩展：虚拟内存使得每个程序可以使用比实际可用内存更大的内存，从而允许运行更大的程序或处理更多的数据。</p><p>内存隔离：虚拟内存还提供了进程之间的内存隔离，每个进程都有自己的虚拟地址空间，因此一个进程无法直接访问另一个进程的内存。</p><p>物理内存管理：虚拟内存允许操作系统动态的将数据和程序的部分加载到物理内存中，以满足当前正在运行的进程的需求。当物理内存不足时，操作系统可以将不常用的数据或程序暂时移到硬盘上，从而释放内存，以便其他进程使用。</p><p>页面交换：当物理内存不足时，操作系统可以将一部分数据从物理内存写入到硬盘的虚拟内存中，这个过程被称为页面交换，当需要时，数据可以再次从虚拟内存中加载到物理内存中。这样可以保证系统可以继续运行，尽管物理内存有限。</p><p>内存映射文件：虚拟内存还可以用于将文件映射到内存中，这使得文件的读取和写入可以像访问内存一样高效。</p><h2 id="6、什么是内存分段和内存分页，作用是什么？"><a href="#6、什么是内存分段和内存分页，作用是什么？" class="headerlink" title="6、什么是内存分段和内存分页，作用是什么？"></a>6、什么是内存分段和内存分页，作用是什么？</h2><p><strong>核心功能是管理虚拟地址与物理地址的之间的映射关系</strong>。</p><p><strong>内存分段</strong>：将一个程序的内存空间分为不同的逻辑段（segments），每个段代表程序的一个功能模块或者数据类型，比如代码段、数据段、堆栈段等。每个段都有其自己的大小和权限。</p><p><strong>内存分页</strong>：把整个虚拟和物理空间分成固定大小的页（4KB），这样一个连续且大小固定的内存空间，称之为页。</p><p>作用：</p><p>1、<strong>逻辑隔离</strong>：内存分段和分页都实现了程序的逻辑隔离，使不同的功能模块或数据类型能够被单独的管理和保护，提高了程序的可靠性与安全性。</p><p>2、<strong>内存保护</strong>：通过将不同的段或页面设置为只读、可读写、不可执行等权限，操作系统可以确保程序不会越界访问或修改其他段的内容，从而提高了系统的稳定性。</p><p>3、<strong>虚拟内存</strong>：分段和分页都是为了实现虚拟内存的概念，允许应用程序认为他们使用的是一个比实际物理内存更大的内存空间。</p><p>4、<strong>内存共享</strong>：通过分页，操作系统可以实现内存页面的共享，从而节省内存空间，多个进程可以共享相同的代码段或数据页面。</p><p>5、<strong>内存管理</strong>：分页更加灵活，允许操作系统将不同进程的页面分散存放在物理内存中，从而提高内存利用率。分段则更适用于管理不同的逻辑模块。</p><p>分段和分页的区别：</p><p>分页对用户不可见，分段对用户可见。</p><p>分页的地址空间是一维的，分段的地址空间是二维的。</p><p>分页（单级页表）以及分段访问一个逻辑地址都需要两次访存，分段存储中可以引入快表机制</p><p>分段更容易实现信息的共享和保护</p><p>分段与分页的优缺点：</p><p>分页：内存空间利用率高，不会产生外部碎片，只会有少量的页内碎片，但不方便按照逻辑模块实现信息的共享与保护。</p><p>分段：方便按照逻辑模块实现信息的共享与保护，但是如果段长过大，为其分配很大的连续空间很不方便，且会产生外部碎片。</p><p><strong>7、解释一下用户态和内核态</strong></p><p><strong>用户态和内核态是操作系统中两种不同的执行模式，用于控制进程或程序对计算机硬件资源的访问权限和操作范围。</strong></p><p>用户态：在用户态下，进程或程序只能访问受限的资源和执行受限的指令集，不能直接访问操作系统的核心部分，也不能直接访问硬件资源，用户态下的CPU不能独占，允许被其他程序获取。</p><p>内核态：内核态是操作系统的特权级别，允许进程或程序执行特权指令和访问操作系统的核心部分。在内核态下，进程可以直接访问硬件资源，执行系统调用，管理内存、文件系统等操作。处于内核态的CPU可以从一个程序切换到另一个程序，并且占用CPU不会发生被抢占的情况。</p><p>用户空间的代码只能访问一个局部的内存空间，而内核空间的代码可以访问所有内存空间。因此，当程序使用用户空间时，我们常说该程序在<strong>用户态</strong>执行，而当程序使内核空间时，程序则在<strong>内核态</strong>执行。<strong>应用程序如果需要进入内核空间，就需要通过系统调用</strong>，内核程序执行在内核态，用户程序执行在用户态。<strong>当应用程序使用系统调用时，会产生一个中断</strong>。发生中断后， CPU 会中断当前在执行的用户程序，转而跳转到中断处理程序，也就是开始执行内核程序。内核处理完后，主动触发中断，把 CPU 执行权限交回给用户程序，回到用户态继续工作。</p><p>8、解释一下页面置换算法，例如LRU，FIFO等</p><p>在了解内存页面置换算法前，我们得先谈一下<strong>缺页异常（缺页中断）</strong>。</p><p>当 CPU 访问的页面不在物理内存时，便会产生一个缺页中断，请求操作系统将所缺页调入到物理内存。那它与一般中断的主要区别在于：</p><ul><li>缺页中断在指令执行「期间」产生和处理中断信号，而一般中断在一条指令执行「完成」后检查和处理中断信号。</li><li>缺页中断返回到该指令的开始重新执行「该指令」，而一般中断返回回到该指令的「下一个指令」执行。</li></ul><p><strong>缺页中断的处理流程</strong>：</p><ol><li>在 CPU 里访问一条 Load M 指令，然后 CPU 会去找 M 所对应的页表项。</li><li>如果该页表项的状态位是「有效的」，那 CPU 就可以直接去访问物理内存了，如果状态位是「无效的」，则 CPU 则会发送缺页中断请求。</li><li>操作系统收到了缺页中断，则会执行缺页中断处理函数，先会查找该页面在磁盘中的页面的位置。</li><li>找到磁盘中对应的页面后，需要把该页面换入到物理内存中，但是在换入前，需要在物理内存中找空闲页，如果找到空闲页，就把页面换入到物理内存中。</li><li>页面从磁盘换入到物理内存完成后，则把页表项中的状态位修改为「有效的」。</li><li>最后，CPU 重新执行导致缺页异常的指令。</li></ol><p>上面所说的过程，第 4 步是能在物理内存找到空闲页的情况，那如果找不到呢？</p><p>找不到空闲页的话，就说明此时内存已满了，这时候，就需要「页面置换算法」选择一个物理页，如果该物理页有被修改过（脏页），则把它换出到磁盘，然后把该被置换出去的页表项的状态改成「无效的」，最后把正在访问的页面装入到这个物理页中。如果没有修改，在置换该页时就不需要将该页写回到磁盘上，以减少系统的开销。</p><p>所以，页面置换算法的功能是，<strong>当出现缺页异常，需调入新页面而内存已满时，选择被置换的物理页面</strong>，也就是说选择一个物理页面换出到磁盘，然后把需要访问的页面换入到物理页，算法的目标是尽量减少页面的换入换出次数，减少系统的开销。</p><p>1、最佳置换算法</p><p>根据未来页面的访问情况，选择最长时间内不会被访问到的页面进行置换。那么就产生一个问题了，未来要访问什么页面操作系统如何未卜先知呢？所以该算法属于理想情况，用来衡量算法的优劣，越接近该算法的效率越高。</p><p>2、先进先出置换算法</p><p><strong>选择在内存驻留时间很长的页面进行中置换</strong>，这个就是「先进先出置换」算法的思想。但是FIFO算法可能会淘汰经常被使用的角色，导致切换次数增加。而且FIFO算法有可能出现贝拉迪异常：当分配给内存的空间增加时，切换次数反而增加了。</p><p>3、最近最久未使用算法（最近最少使用）</p><p>最近最久未使用（<em>LRU</em>）的置换算法的基本思路是，发生缺页时，<strong>选择最长时间没有被访问的页面进行置换</strong>，也就是说，该算法假设已经很久没有使用的页面很有可能在未来较长的一段时间内仍然不会被使用。</p><p>虽然 LRU 在理论上是可以实现的，但代价很高。为了完全实现 LRU，需要在内存中维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。困难的是，在每次访问内存时都必须要更新「整个链表」。在链表中找到一个页面，删除它，然后把它移动到表头是一个非常费时的操作。</p><p>所以，LRU 虽然看上去不错，但是由于开销比较大，实际应用中比较少使用。</p><p>4、时钟页面置换算法</p><p>那有没有一种即能优化置换的次数，也能方便实现的算法呢？</p><p><strong>时钟页面置换算法就可以两者兼得，它跟 LRU 近似，又是对 FIFO 的一种改进。</strong></p><p>该算法的思路是，把所有的页面都保存在一个类似钟面的「环形链表」中，一个表针指向最老的页面。</p><p>当发生缺页中断时，算法首先检查表针指向的页面：</p><ul><li>如果它的访问位位是 0 就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置；</li><li>如果访问位是 1 就清除访问位，并把表针前移一个位置，重复这个过程直到找到了一个访问位为 0 的页面为止；</li></ul><p>5、最不常用算法（LFU）</p><p><strong>当发生缺页中断时，选择「访问次数」最少的那个页面，并将其淘汰</strong>。</p><p>它的实现方式是，对每个页面设置一个「访问计数器」，每当一个页面被访问时，该页面的访问计数器就累加 1。在发生缺页中断时，淘汰计数器值最小的那个页面。</p><p>看起来很简单，每个页面加一个计数器就可以实现了，但是在操作系统中实现的时候，我们需要考虑效率和硬件成本的。</p><p>要增加一个计数器来实现，这个硬件成本是比较高的，另外如果要对这个计数器查找哪个页面访问次数最小，查找链表本身，如果链表长度很大，是非常耗时的，效率不高。</p><p>但还有个问题，LFU 算法只考虑了频率问题，没考虑时间的问题，比如有些页面在过去时间里访问的频率很高，但是现在已经没有访问了，而当前频繁访问的页面由于没有这些页面访问的次数高，在发生缺页中断时，就会可能会误伤当前刚开始频繁访问，但访问次数还不高的页面。</p><h2 id="7、解释一下进程同步和互斥，以及解决这些问题的方法？"><a href="#7、解释一下进程同步和互斥，以及解决这些问题的方法？" class="headerlink" title="7、解释一下进程同步和互斥，以及解决这些问题的方法？"></a>7、解释一下进程同步和互斥，以及解决这些问题的方法？</h2><p>互斥：在某一时刻只允许一个进程访问某个共享资源，当一个进程正在使用共享资源时，其他进程不能同时访问改共享资源。</p><p>进程同步：多个并发执行的进程之间协调和管理他们的执行顺序，以确保他们按照一定的顺序或时间间隔执行。</p><ul><li>同步就好比：「操作 A 应在操作 B 之前执行」，「操作 C 必须在操作 A 和操作 B 都完成之后才能执行」等；</li><li>互斥就好比：「操作 A 和操作 B 不能在同一时刻执行」</li></ul><p>临界区：将可能引发互斥问题的代码段称为临界区，为了实现互斥，每个进程在进入临界区前必须获取一个锁，退出临界区后释放该锁。确保同一时间只有一个进程可以进入临界区。</p><p>互斥锁：互斥锁是一种同步机制，用于实现互斥。每个共享资源都关联一个互斥锁，进程在访问该资源前需要获取互斥锁，使用完之后释放互斥锁，只有获得互斥锁的进程才能访问资源。</p><p>信号量：参考3.</p><p>信号初始化为 <code>1</code>，就代表着是<strong>互斥信号量</strong>，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。</p><p>我们可以初始化信号量为 <code>0</code>，就可以用信号量来实现多进程同步的方式，它可以保证进程 A 应在进程 B 之前执行。</p><h2 id="8、什么是中断和异常？二者有何区别？"><a href="#8、什么是中断和异常？二者有何区别？" class="headerlink" title="8、什么是中断和异常？二者有何区别？"></a>8、什么是中断和异常？二者有何区别？</h2><p>中断和异常是两种不同的事件，他们都会导致CPU暂停当前的程序执行，转而去执行一个特定的处理程序。</p><p>区别：</p><p><strong>中断是由外部设备或其他处理器产生的</strong>，通常是异步的，也就是说中断可以在任何时候发生。与当前执行的指令无关，比如键盘输入，鼠标移动等都会触发中断通知CPU去处理这些事件。</p><p><strong>异常是由CPU内部产生的</strong>，通常是同步的，也就是说只会在执行某些指令时发生，与当前执行的指令有关。比如访问非法内存地址，除数为零、执行非法指令等都会产生异常信号，通知CPU去处理这些错误或故障。</p><p><strong>中断可以被屏蔽或者禁止</strong>，意味着CPU可以通过设置某些标志位或寄存器来忽略或延迟响应某些中断信号。可以避免中断过于频繁或干扰重要的任务。</p><p><strong>异常不能被屏蔽或者禁止</strong>，意味着CPU必须立即响应异常信号，并进行相应的处理，这样可以保证程序的正确性和系统的稳定性。</p><p>中断的定义：CPU在执行指令时，收到某个中断信号转而去执行预先设定好的代码，然后再返回到原指令中继续执行，这就是中断机制。</p><p>中断的作用：</p><p>1、外设异步通知CPU，外设发生了什么事情或者完成了什么任务都可以通过中断异步通知CPU。</p><p>2、CPU之间发送消息，在SMP系统中，一个CPU想给另一个CPU发送消息，可以使用IPI（处理器间中断）。</p><p>3、处理CPU异常，CPU在执行指令的过程中遇到了异常会给自己发送中断信号来处理异常。</p><p>4、实现系统调用，早期的系统调用就是靠中断来实现的，后期虽然开发了专用的系统调用指令，但其基本原理还是相似的。</p><p>中断的产生：</p><p>1、外设（硬件中断），外设产生的中断信号时<strong>异步的</strong>，按照是否可以屏蔽分为可屏蔽中断和不可屏蔽中断。网卡、磁盘、定时器都可以产生硬件中断。</p><p>2、CPU，处理器间中断（IPI），可以看做一种特殊的硬件中断，<strong>异步</strong>。</p><p>3、CPU异常，<strong>同步的</strong>，在处理指令的过程中发现异常，会向自己发送中断信号，也叫做软件中断。CPU异常分为三类：</p><p>陷阱：不需要修复，中断处理完成后重新执行之前的指令。</p><p>故障：需要修复也有可能修复，中断处理完成后重新执行之前的指令。</p><p>中止：需要修复但是无法修复，中断处理完成后，进程或者内核将会崩溃。</p><p>4、中断指令，直接用CPU指令来产生中断信号，这种中断和CPU异常一样是<strong>同步的</strong>，也也可以叫做软件中断。</p><h2 id="9、介绍一下几种典型的锁"><a href="#9、介绍一下几种典型的锁" class="headerlink" title="9、介绍一下几种典型的锁"></a>9、介绍一下几种典型的锁</h2><p>加锁的目的就是保证共享资源在任意时间里，只有一个线程访问，这样就可以避免多线程导致共享数据错乱的问题。</p><p>两个基本的锁</p><p>1、互斥锁：一种最常见的锁类型，用于实现互斥访问共享资源。在任何时刻，只有一个线程可以持有互斥锁，其他线程必须等待直到锁被释放，确保了同一时间只有一个线程能够访问被保护的资源。</p><p>2、自旋锁：基于忙等待的锁，线程在尝试获取锁时会不断轮训，直到锁被释放。</p><ul><li><strong>互斥锁</strong>加锁失败后，线程会<strong>释放 CPU</strong> ，给其他线程；</li><li><strong>自旋锁</strong>加锁失败后，线程会<strong>忙等待</strong>，直到它拿到锁；</li></ul><p>其他的锁基于这两种锁</p><p>3、读写锁：允许多个线程同时共享资源，只允许一个线程进行写操作，读（共享）写（独占）两种状态。</p><p>4、悲观锁：认为多线程同时修改共享资源的概率比较高，所以访问资源时要上锁。</p><p>5、乐观锁：先不管，修改了共享资源再说，如果出现同时修改的情况，放弃本次操作。</p><p><strong>总结：</strong></p><p>开发过程中，最常见的就是互斥锁的了，互斥锁加锁失败时，会用「线程切换」来应对，当加锁失败的线程再次加锁成功后的这一过程，会有两次线程上下文切换的成本，性能损耗比较大。</p><p>如果我们明确知道被锁住的代码的执行时间很短，那我们应该选择开销比较小的自旋锁，因为自旋锁加锁失败时，并不会主动产生线程切换，而是一直忙等待，直到获取到锁，那么如果被锁住的代码执行时间很短，那这个忙等待的时间相对应也很短。</p><p>如果能区分读操作和写操作的场景，那读写锁就更合适了，它允许多个读线程可以同时持有读锁，提高了读的并发性。根据偏袒读方还是写方，可以分为读优先锁和写优先锁，读优先锁并发性很强，但是写线程会被饿死，而写优先锁会优先服务写线程，读线程也可能会被饿死，那为了避免饥饿的问题，于是就有了公平读写锁，它是用队列把请求锁的线程排队，并保证先入先出的原则来对线程加锁，这样便保证了某种线程不会被饿死，通用性也更好点。</p><p>互斥锁和自旋锁都是最基本的锁，读写锁可以根据场景来选择这两种锁其中的一个进行实现。</p><p>另外，互斥锁、自旋锁、读写锁都属于悲观锁，悲观锁认为并发访问共享资源时，冲突概率可能非常高，所以在访问共享资源前，都需要先加锁。</p><p>相反的，如果并发访问共享资源时，冲突概率非常低的话，就可以使用乐观锁，它的工作方式是，在访问共享资源时，不用先加锁，修改完共享资源后，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。</p><p>但是，一旦冲突概率上升，就不适合使用乐观锁了，因为它解决冲突的重试成本非常高。</p><p>不管使用的哪种锁，我们的加锁的代码范围应该尽可能的小，也就是加锁的粒度要小，这样执行速度会比较快。再来，使用上了合适的锁，就会快上加快了。</p><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="1、一条SQL查询语句是如何执行的？"><a href="#1、一条SQL查询语句是如何执行的？" class="headerlink" title="1、一条SQL查询语句是如何执行的？"></a>1、一条SQL查询语句是如何执行的？</h2><p>1、连接器：负责跟客户端建立连接，获取权限、维持和管理连接。</p><ul><li><p>与客户端进行 TCP 三次握手建立连接；</p></li><li><p>校验客户端的用户名和密码，如果用户名或密码不对，则会报错；</p></li><li><p>如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限；</p></li></ul><p>2、查询缓存：如果 SQL 是查询语句（select 语句），MySQL 就会先去查询缓存（ Query Cache ）里查找缓存数据，看看之前有没有执行过这一条命令，这个查询缓存是以 key-value 形式保存在内存中的，key 为 SQL 查询语句，value 为 SQL 语句查询的结果。</p><p>如果查询的语句命中查询缓存，那么就会直接返回 value 给客户端。如果查询的语句没有命中查询缓存中，那么就要往下继续执行，等执行完后，查询的结果就会被存入查询缓存中。</p><p>PS：对于更新比较频繁的表，查询缓存的命中率很低的，因为只要一个表有更新操作，那么这个表的查询缓存就会被清空。如果刚缓存了一个查询结果很大的数据，还没被使用的时候，刚好这个表有更新操作，查询缓冲就被清空了，相当于缓存了个寂寞。<strong>所以，MySQL 8.0 版本直接将查询缓存删掉了，也就是说 MySQL 8.0 开始，执行一条 SQL 查询语句，不会再走到查询缓存这个阶段了</strong>。</p><p>3、解析SQL：解析器做的第一件事情，<strong>词法分析</strong>。MySQL 会根据你输入的字符串识别出关键字出来，第二件事情，<strong>语法分析</strong>，根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法，如果没问题就会构建出 SQL 语法树，这样方便后面模块获取 SQL 类型、表名、字段名、 where 条件等等。</p><p>4、执行SQL：</p><p>经过解析器后，接着就要进入执行 SQL 查询语句的流程了，每条<code>SELECT</code> 查询语句流程主要可以分为下面这三个阶段：</p><ul><li>prepare 阶段，也就是预处理阶段；</li><li>optimize 阶段，也就是优化阶段；</li><li>execute 阶段，也就是执行阶段；</li></ul><p><strong>预处理器</strong>：我们先来说说预处理阶段做了什么事情。</p><ul><li><p>检查 SQL 查询语句中的表或者字段是否存在；</p></li><li><p>将 <code>select *</code> 中的 <code>*</code> 符号，扩展为表上的所有列；</p></li></ul><p><strong>优化器</strong>：经过预处理阶段后，还需要为 SQL 查询语句先制定一个执行计划，这个工作交由「优化器」来完成的。</p><p><strong>优化器主要负责将 SQL 查询语句的执行方案确定下来</strong>，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。</p><p>举例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> product <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span>  <span class="hljs-keyword">and</span> name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;i%&#x27;</span>;<br></code></pre></td></tr></table></figure><p>这条查询语句的结果既可以使用主键索引，也可以使用普通索引，但是执行的效率会不同。这时，就需要优化器来决定使用哪个索引了。</p><p>很显然这条查询语句是<strong>覆盖索引</strong>，直接在二级索引就能查找到结果（因为二级索引的 B+ 树的叶子节点的数据存储的是主键值），就没必要在主键索引查找了，<strong>因为查询主键索引的 B+ 树的成本会比查询二级索引的 B+ 的成本大</strong>，优化器基于查询成本的考虑，会选择查询代价小的普通索引。</p><p><strong>执行器</strong>：经历完优化器后，就确定了执行方案，接下来 MySQL 就真正开始执行语句了，这个工作是由「执行器」完成的。在执行的过程中，执行器就会和存储引擎交互了，交互是以记录为单位的。</p><p>总结：</p><p>执行一条 SQL 查询语句，期间发生了什么？</p><ul><li>连接器：建立连接，管理连接、校验用户身份；</li><li>查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；</li><li>解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；</li><li>执行 SQL：执行 SQL 共有三个阶段：<ul><li>预处理阶段：检查表或字段是否存在；将 <code>select *</code> 中的 <code>*</code> 符号扩展为表上的所有列。</li><li>优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；</li><li>执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</li></ul></li></ul><h2 id="2、什么是索引"><a href="#2、什么是索引" class="headerlink" title="2、什么是索引"></a>2、什么是索引</h2><p>索引的定义就是帮助存储引擎快速获取数据的一种数据结构，形象的说就是索引是数据的目录。</p><h2 id="3、索引的分类"><a href="#3、索引的分类" class="headerlink" title="3、索引的分类"></a>3、索引的分类</h2><p>我们可以按照四个角度来分类索引。</p><ul><li><p>按「数据结构」分类：</p><p><strong>B+tree索引</strong>:所有数据存放在叶子结点，适合范围查询。</p><p><strong>Hash索引</strong>：适合等值查询，检索效率高，一次到位。</p><p><strong>Full-text索引</strong>：一般在文本类型char、text、varchar上创建。</p></li><li><p>按「物理存储」分类：</p><p><strong>聚簇索引（主键索引）</strong>：主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；</p><p><strong>二级索引（辅助索引）</strong>：二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。</p><p>所以，在查询时使用了二级索引，如果查询的数据能在二级索引里查询的到，那么就不需要回表，这个过程就是<strong>覆盖索引</strong>。如果查询的数据不在二级索引里，就会先检索二级索引，找到对应的叶子节点，获取到主键值后，然后再检索主键索引，就能查询到数据了，这个过程就是<strong>回表</strong>。</p></li><li><p>按「字段特性」分类：</p><p><strong>主键索引</strong>：主键索引就是建立在主键字段上的索引，通常在创建表的时候一起创建，<strong>一张表最多只有一个主键索引，索引列的值不允许有空值</strong>。</p><p><strong>唯一索引</strong>：唯一索引建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，<strong>索引列的值必须唯一，但是允许有空值</strong>。</p><p><strong>普通索引</strong>：普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE，<strong>允许空值和重复值</strong>。</p><p><strong>前缀索引</strong>：前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。</p></li><li><p>按「字段个数」分类：</p><p><strong>单列索引</strong>：立在单列上的索引称为单列索引，比如主键索引。</p><p><strong>联合索引</strong>：通过将多个字段组合成一个索引，该索引就被称为联合索引。使用联合索引时，存在<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配。在使用联合索引进行查询的时候，如果不遵循「最左匹配原则」，联合索引会失效，这样就无法利用到索引快速查询的特性了。</p><p>注意：联合索引有一些特殊情况，<strong>并不是查询过程使用了联合索引查询，就代表联合索引中的所有字段都用到了联合索引进行索引查询</strong>，也就是可能存在部分字段用到联合索引的 B+Tree，部分字段没有用到联合索引的 B+Tree 的情况。</p><p><strong>这种特殊情况就发生在范围查询</strong>。联合索引的最左匹配原则会一直向右匹配直到遇到「范围查询」就会停止匹配。<strong>也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引</strong>。</p></li></ul><h2 id="4、什么时候需要索引，什么时候不需要索引？"><a href="#4、什么时候需要索引，什么时候不需要索引？" class="headerlink" title="4、什么时候需要索引，什么时候不需要索引？"></a>4、什么时候需要索引，什么时候不需要索引？</h2><p>索引最大的好处是提高查询速度，但是索引也是有缺点的，比如：</p><ul><li>需要占用物理空间，数量越大，占用空间越大；</li><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增大；</li><li>会降低表的增删改的效率，因为每次增删改索引，B+ 树为了维护索引有序性，都需要进行动态维护。</li></ul><p>所以，索引不是万能钥匙，它也是根据场景来使用的。</p><h4 id="什么时候适用索引？"><a href="#什么时候适用索引？" class="headerlink" title="什么时候适用索引？"></a>什么时候适用索引？</h4><ul><li><strong>字段有唯一性限制的</strong>，比如商品编码；</li><li><strong>经常用于 <code>WHERE</code> 查询条件的字段</strong>，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。</li><li><strong>经常用于 <code>GROUP BY</code> 和 <code>ORDER BY</code> 的字段</strong>，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。</li></ul><h4 id="什么时候不需要创建索引？"><a href="#什么时候不需要创建索引？" class="headerlink" title="什么时候不需要创建索引？"></a>什么时候不需要创建索引？</h4><ul><li><strong><code>WHERE</code> 条件，<code>GROUP BY</code>，<code>ORDER BY</code> 里用不到的字段</strong>，索引的价值是快速定位，如果起不到定位的字段通常是<strong>不需要创建索引</strong>的，因为索引是会占用物理空间的。</li><li><strong>字段中存在大量重复数据，不需要创建索引</strong>，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。</li><li><strong>表数据太少的时候，不需要创建索引</strong>；（小表）</li><li><strong>经常更新的字段不用创建索引</strong>，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。</li></ul><h2 id="5、为什么MySql采用B-Tree作为索引？"><a href="#5、为什么MySql采用B-Tree作为索引？" class="headerlink" title="5、为什么MySql采用B+Tree作为索引？"></a>5、为什么MySql采用B+Tree作为索引？</h2><p>MySql的数据是持久化的，所以其数据（索引+记录）是保存在磁盘中的，防止设备断电而导致数据丢失。所以，当我们通过索引查找数据的时候，查询过程会发生多次磁盘IO，而磁盘IO发生次数越多，所消耗的时间也越大。</p><p>所以，我们希望索引的数据结构能在尽可能少的磁盘的 I&#x2F;O 操作中完成查询工作，因为磁盘 I&#x2F;O 操作越少，所消耗的时间也就越小</p><p>另外，另外，MySQL 是支持范围查找的，所以索引的数据结构不仅要能高效地查询某一个记录，而且也要能高效地执行范围查找。</p><p>综上所述，要设计一个适合 MySQL 索引的数据结构，至少满足以下要求：</p><ul><li>能在尽可能少的磁盘的 I&#x2F;O 操作中完成查询工作；</li><li>要能高效地查询某一个记录，也要能高效地执行范围查找；</li></ul><p>分析各种数据结构的优缺点：</p><p>二分查找法每次都把查询的范围减半，这样时间复杂度就降到了 O(logn)，但是每次查找都需要不断计算中间位置。</p><p>二叉查找树（搜索树）解决了连续结构插入新元素开销很大的问题，同时又保持着天然的二分结构，但是**当每次插入的元素都是二叉查找树中最大的元素，二叉查找树就会退化成了一条链表，查找数据的时间复杂度变成了 O(n)**。</p><p>为了解决二叉查找树会在极端情况下退化成链表的问题，后面就有人提出<strong>平衡二叉查找树（AVL 树）</strong>。主要是在二叉查找树的基础上增加了一些条件约束：<strong>每个节点的左子树和右子树的高度差不能超过 1</strong>。也就是说节点的左子树和右子树仍然为平衡二叉树，这样查询操作的时间复杂度就会一直维持在 O(logn)。但是<strong>不管平衡二叉查找树还是红黑树，都会随着插入的元素增多，而导致树的高度变高，这就意味着磁盘 I&#x2F;O 操作次数多，会影响整体数据查询的效率</strong>。</p><p>为了解决降低树的高度的问题，后面就出来了 <strong>B 树</strong>，它不再限制一个节点就只能有 2 个子节点，而是允许 M 个子节点 (M&gt;2)，从而降低树的高度。同样的节点数量在平衡二叉树的场景下，树的高度就会很高，意味着磁盘 I&#x2F;O 操作会更多。<strong>所以，B 树在数据查询中比平衡二叉树效率要高。</strong>但是 B 树的每个节点都包含数据（索引+记录），而用户的记录数据的大小很有可能远远超过了索引数据，这就需要花费更多的磁盘 I&#x2F;O 操作次数来读到「有用的索引数据」，另外，如果使用 B 树来做范围查询的话，需要使用中序遍历，这会涉及多个节点的磁盘 I&#x2F;O 问题，从而导致整体速度下降。</p><p>B+ 树与 B 树差异的点，主要是以下这几点：</p><ul><li><strong>叶子节点（最底部的节点）才会存放实际数据（索引+记录）</strong>，<strong>非叶子节点只会存放索引；</strong></li><li>所有索引都会在叶子节点出现，叶子节点之间构成一个有序链表；</li><li>非叶子节点的索引也会同时存在在子节点中，并且是在子节点中所有索引的最大（或最小）。</li><li>非叶子节点中有多少个子节点，就有多少个索引；</li></ul><p>总结：MySQL 默认的存储引擎 InnoDB 采用的是 B+ 树作为索引的数据结构，原因有：</p><ul><li>B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，<strong>查询底层节点的磁盘 I&#x2F;O次数会更少。</strong>–单点查询更快</li><li>B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；–插入和删除效率</li><li>B+ 树叶子节点之间用链表连接了起来，<strong>有利于范围查询</strong>，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I&#x2F;O 操作，范围查询效率不如 B+ 树。–范围查询</li></ul><h2 id="6、索引失效的场景有哪些？"><a href="#6、索引失效的场景有哪些？" class="headerlink" title="6、索引失效的场景有哪些？"></a>6、索引失效的场景有哪些？</h2><p>1、对索引使用左或者左右模糊匹配</p><p>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code> 这两种方式都会造成索引失效，<strong>因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较。</strong></p><p>2、对索引使用函数</p><p>有时候我们会用一些 MySQL 自带的函数来得到我们想要的结果，这时候要注意了，如果查询条件中对索引字段使用函数，就会导致索引失效。因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。</p><p><strong>从 MySQL 8.0 开始，索引特性增加了函数索引，即可以针对函数计算后的值建立一个索引，也就是说该索引的值是函数计算后的值，所以就可以通过扫描索引来查询数据。</strong></p><p>3、对索引进行表达式计算</p><p>在查询条件中对索引进行表达式计算，也是无法走索引的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">explain select * from t_user where id + 1 = 10; // 不行<br>explain select * from t_user where id = 10 -1;// 可以<br></code></pre></td></tr></table></figure><p>4、对索引进行隐式类型转换</p><p><strong>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较</strong>。</p><p>前面的例子一中的查询语句，我也跟大家说了是会走<strong>全表扫描</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>例子一的查询语句<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> phone <span class="hljs-operator">=</span> <span class="hljs-number">1300000001</span>;<br></code></pre></td></tr></table></figure><p>这是因为 phone 字段为字符串，所以 MySQL 要会自动把字符串转为数字，所以这条语句相当于：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> <span class="hljs-built_in">CAST</span>(phone <span class="hljs-keyword">AS</span> signed <span class="hljs-type">int</span>) <span class="hljs-operator">=</span> <span class="hljs-number">1300000001</span>;<br></code></pre></td></tr></table></figure><p>可以看到，<strong>CAST 函数是作用在了 phone 字段，而 phone 字段是索引，也就是对索引使用了函数！而前面我们也说了，对索引使用函数是会导致索引失效的</strong>。</p><p>例子二中的查询语句，我跟大家说了是会走索引扫描：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>例子二的查询语句<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> &quot;1&quot;;<br></code></pre></td></tr></table></figure><p>这时因为字符串部分是输入参数，也就需要将字符串转为数字，所以这条语句相当于：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-built_in">CAST</span>(&quot;1&quot; <span class="hljs-keyword">AS</span> signed <span class="hljs-type">int</span>);<br></code></pre></td></tr></table></figure><p>可以看到，<strong>索引字段并没有用任何函数，CAST 函数是用在了输入参数，因此是可以走索引扫描的。</strong></p><p>5、联合索引非最左匹配（或遇到范围查询）</p><p>对主键字段建立的索引叫做聚簇索引，对普通字段建立的索引叫做二级索引。</p><p>那么<strong>多个普通字段组合在一起创建的索引就叫做联合索引</strong>，也叫组合索引。</p><p>创建联合索引时，我们需要注意创建时的顺序问题，因为联合索引 (a, b, c) 和 (c, b, a) 在使用的时候会存在差别。联合索引要能正确使用需要遵循<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配。</p><p>也就是说，如果我们想使用联合索引中尽可能多的列，查询条件中的各个列必须是联合索引中从最左边开始连续的列。如果我们仅仅按照第二列搜索，肯定无法走索引。</p><p>6、WHERE语句中的OR</p><p>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</p><p>总结：</p><ul><li>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；</li><li>当我们在查询条件中对索引列使用函数，就会导致索引失效。</li><li>当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。</li><li>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。</li><li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li><li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效</li></ul><h2 id="7、事物有哪些特性"><a href="#7、事物有哪些特性" class="headerlink" title="7、事物有哪些特性"></a>7、事物有哪些特性</h2><p>1、<strong>原子性</strong>：事物是不可分割的最小工作单元，一个事物中的所有操作，要么全部完成，要么全部未完成，不会停留在中间状态（比如只完成一半）。如果事物执行过程中发生了错误，会被回滚到没执行操作之前原来的状态，像事物没有执行过一样。**–undo 回滚日志实现**</p><p>2、<strong>一致性</strong>：一个事物操作之前和执行之后的状态必须保持一致。比如用户 A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，用户 A 给用户 B 转账 200 元，分为两个步骤，从 A 的账户扣除 200 元和对 B 的账户增加 200 元。一致性就是要求上述步骤操作后，最后的结果是用户 A 还有 600 元，用户 B 有 800 元，总共 1400 元，而不会出现用户 A 扣除了 200 元，但用户 B 未增加的情况。**–其他三种共同保障**</p><p>3、隔离性：数据库允许多个并发事务同时对其数据进行修改和读取，隔离性可以防止多个事物并发执行时由于交叉执行导致的数据不一致的情况，因为多个事物并发执行的时候不会相互干扰，每个事物都有一个完整的数据空间，对其他并发事务是隔离的。**–MVCC（多版本并发控制）或者锁机制。**</p><p>4、持久性：事物处理结束之后，对数据的修改是永久的，即使系统故障也不会丢失。-<strong>-redo log（重做日志）</strong></p><h2 id="8、说一说事物的隔离级别以及他们都是怎么实现的？"><a href="#8、说一说事物的隔离级别以及他们都是怎么实现的？" class="headerlink" title="8、说一说事物的隔离级别以及他们都是怎么实现的？"></a>8、说一说事物的隔离级别以及他们都是怎么实现的？</h2><p>MySQL 服务端是允许多个客户端连接的，这意味着 MySQL 会出现同时处理多个事务的情况。那么<strong>在同时处理多个事务的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题</strong>。</p><p>当多个事务并发执行时可能会遇到「脏读、不可重复读、幻读」的现象，这些现象会对事务的一致性产生不同程序的影响。</p><ul><li>脏读：读到其他事务未提交的数据；</li><li>不可重复读：前后读取的数据不一致；</li><li>幻读：前后读取的记录数量不一致。</li></ul><p>SQL 标准提出了四种隔离级别来规避这些现象，隔离级别越高，性能效率就越低，这四个隔离级别如下：<strong>自上而下隔离级别逐级变高</strong>、性能越低</p><ul><li><strong>读未提交（*read uncommitted*）</strong>，指一个事务还没提交时，它做的变更就能被其他事务看到；</li><li><strong>读提交（*read committed*）</strong>，指一个事务提交之后，它做的变更才能被其他事务看到；</li><li><strong>可重复读（*repeatable read*）</strong>，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，<strong>MySQL InnoDB 引擎的默认隔离级别</strong>；</li><li><strong>串行化（*serializable* ）</strong>；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；</li></ul><p><strong>针对不同的隔离级别，并发事务时可能发生的现象也会不同</strong>，也就是说：</p><ul><li>在「读未提交」隔离级别下，可能发生<strong>脏读</strong>、<strong>不可重复读</strong>和<strong>幻读</strong>现象；</li><li>在「读提交」隔离级别下，可能发生<strong>不可重复读</strong>和<strong>幻读</strong>现象，但是不可能发生脏读现象；</li><li>在「可重复读」隔离级别下，可能发生<strong>幻读</strong>现象，但是不可能发生脏读和不可重复读现象；</li><li>在「串行化」隔离级别下，脏读、不可重复读和幻读现象都不可能会发生。</li></ul><p>要解决脏读现象，就要将隔离级别升级到读已提交以上的隔离级别，要解决不可重复读现象，就要将隔离级别升级到可重复读以上的隔离级别。</p><p>而对于幻读现象，不建议将隔离级别升级为串行化，因为这会导致数据库并发时性能很差。MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象，解决的方案有两种：</p><ul><li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li><li>针对<strong>当前读</strong>（select … for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li></ul><p>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同：</p><ul><li>「读提交」隔离级别是在<strong>每个 select 都会生成一个新的 Read View，</strong>也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。</li><li>「可重复读」隔离级别是<strong>启动事务时生成一个 Read View</strong>，然后整个事务期间都在用这个 Read View，<strong>这样就保证了在事务期间读到的数据都是事务启动前的记录。</strong></li></ul><p>这两个隔离级别实现是通过「事务的 Read View 里的字段」和「记录中的两个隐藏列」的比对，来控制并发事务访问同一个记录时的行为，这就叫 MVCC（多版本并发控制）。</p><p>在可重复读隔离级别中，普通的 select 语句就是基于 MVCC 实现的快照读，也就是不会加锁的。而 select .. for update 语句就不是快照读了，而是当前读了，也就是每次读都是拿到最新版本的数据，但是它会对读到的记录加上 next-key lock 锁。</p><h2 id="9、MySQL-可重复读隔离级别，完全解决幻读了吗？"><a href="#9、MySQL-可重复读隔离级别，完全解决幻读了吗？" class="headerlink" title="9、MySQL 可重复读隔离级别，完全解决幻读了吗？"></a>9、MySQL 可重复读隔离级别，完全解决幻读了吗？</h2><p>MySQL InnoDB 引擎的可重复读隔离级别（默认隔离级），根据不同的查询方式，分别提出了避免幻读的方案：</p><ul><li>针对<strong>快照读</strong>（普通 select 语句），是通过 MVCC 方式解决了幻读。</li><li>针对<strong>当前读</strong>（select … for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读。</li></ul><p>我举例了两个发生幻读场景的例子。</p><p>第一个例子：对于快照读， MVCC 并不能完全避免幻读现象。因为当事务 A 更新了一条事务 B 插入的记录，那么事务 A 前后两次查询的记录条目就不一样了，所以就发生幻读。</p><p>第二个例子：对于当前读，如果事务开启后，并没有执行当前读，而是先快照读，然后这期间如果其他事务插入了一条记录，那么事务后续使用当前读进行查询的时候，就会发现两次查询的记录条目就不一样了，所以就发生幻读。</p><p>所以，<strong>MySQL 可重复读隔离级别并没有彻底解决幻读，只是很大程度上避免了幻读现象的发生。</strong></p><p>要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select … for update 这类当前读的语句，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。</p><h2 id="10、MYSQL有哪些锁？作用是什么？"><a href="#10、MYSQL有哪些锁？作用是什么？" class="headerlink" title="10、MYSQL有哪些锁？作用是什么？"></a>10、MYSQL有哪些锁？作用是什么？</h2><h3 id="1、全局锁"><a href="#1、全局锁" class="headerlink" title="1、全局锁"></a>1、全局锁</h3><blockquote><p>1、全局锁是怎么用的？</p></blockquote><p>要使用全局锁，则要执行这条命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">flush tables <span class="hljs-keyword">with</span> read lock<br></code></pre></td></tr></table></figure><p>执行后，<strong>整个数据库就处于只读状态了</strong>，这时其他线程执行以下操作，都会被阻塞：</p><ul><li>对数据的增删改操作，比如 insert、delete、update等语句；</li><li>对表结构的更改操作，比如 alter table、drop table 等语句。</li></ul><p>如果要释放全局锁，则要执行这条命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">unlock tables<br></code></pre></td></tr></table></figure><p>当然，当会话断开了，全局锁会被自动释放。</p><blockquote><p>2、全局锁应用场景是什么？</p></blockquote><p>全局锁主要应用于做<strong>全库逻辑备份</strong>，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。</p><blockquote><p>3、加全局锁又会带来什么缺点呢？</p></blockquote><p>加上全局锁，意味着整个数据库都是<strong>只读状态</strong>。</p><p>那么如果数据库里有很多数据，备份就会花费很多的时间，关键是备份期间，业务只能读数据，而不能更新数据，这样会造成业务停滞。</p><blockquote><p>4、既然备份数据库数据的时候，使用全局锁会影响业务，那有什么其他方式可以避免？</p></blockquote><p>有的，如果数据库的引擎支持的事务支持<strong>可重复读的隔离级别</strong>，<strong>那么在备份数据库之前先开启事务</strong>，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。</p><p>因为在可重复读的隔离级别下，即使其他事务更新了表的数据，也不会影响备份数据库时的 Read View，这就是事务四大特性中的<strong>隔离性</strong>，这样备份期间备份的数据一直是在开启事务时的数据。</p><p>PS： InnoDB 存储引擎默认的事务隔离级别正是可重复读，因此可以采用这种方式来备份数据库。但是，对于 MyISAM 这种不支持事务的引擎，在备份数据库时就要使用全局锁的方法。</p><h3 id="2、表级锁"><a href="#2、表级锁" class="headerlink" title="2、表级锁"></a>2、表级锁</h3><blockquote><p>MySQL 表级锁有哪些？具体怎么用的。</p></blockquote><p>MySQL 里面表级别的锁有这几种：</p><ul><li><p>表锁：表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。</p><p>也就是说如果本线程对学生表加了「共享表锁」，那么本线程接下来如果要对学生表执行<strong>写操作</strong>的语句，是会被阻塞的，当然其他线程对学生表进行<strong>写操作</strong>时也会被阻塞，直到锁被释放。</p><p>不过尽量避免在使用 InnoDB 引擎的表使用表锁，因为表锁的颗粒度太大，<strong>会影响并发性能</strong>，<strong>InnoDB 牛逼的地方在于实现了颗粒度更细的行级锁</strong>。</p></li><li><p>元数据锁（MDL）：我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：</p><ul><li>对一张表进行 CRUD 操作时，加的是 <strong>MDL 读锁</strong>；</li><li>对一张表做结构变更操作的时候，加的是 <strong>MDL 写锁</strong>；</li></ul><p><strong>MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。</strong></p><p>当有线程在执行 select 语句（ 加 MDL 读锁）的期间，如果有其他线程要更改该表的结构（ 申请 MDL 写锁），那么将会被阻塞，直到执行完 select 语句（ 释放 MDL 读锁）。</p><p>反之，当有线程对表结构进行变更（ 加 MDL 写锁）的期间，如果有其他线程执行了 CRUD 操作（ 申请 MDL 读锁），那么就会被阻塞，直到表结构变更完成（ 释放 MDL 写锁）。</p><p>MDL 是在事务提交后才会释放，这意味着<strong>事务执行期间，MDL 是一直持有的</strong>。</p><p><strong>PS</strong>：申请 MDL 锁的操作会形成一个队列，队列中<strong>写锁获取优先级高于读锁</strong>，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。</p><p>所以为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中的<strong>长事务</strong>，是否有事务已经对表加上了 MDL 读锁，如果可以考虑 kill 掉这个长事务，然后再做表结构的变更。</p></li><li><p>意向锁：</p><p>在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；</p><p>在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；</p><p>也就是，当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。</p><p>而普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。</p><p><strong>意向锁的目的是为了快速判断表里是否有记录被加锁</strong>。</p></li><li><p>AUTO-INC 锁：表里的主键通常都会设置成自增的，这是通过对主键字段声明 <code>AUTO_INCREMENT</code> 属性实现的。</p><p>之后可以在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过 <strong>AUTO-INC 锁</strong>实现的。</p><p>AUTO-INC 锁是特殊的表锁机制，锁<strong>不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放</strong>。</p><p><strong>在插入数据时，会加一个表级别的 AUTO-INC 锁</strong>，然后为被 <code>AUTO_INCREMENT</code> 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。</p><p>那么，一个事务在持有 AUTO-INC 锁的过程中，其他事务如果要向该表插入语句都会被阻塞，从而保证插入数据时，被 <code>AUTO_INCREMENT</code> 修饰的字段的值是连续递增的。</p></li></ul><h3 id="3、行级锁"><a href="#3、行级锁" class="headerlink" title="3、行级锁"></a>3、行级锁</h3><p>行级锁的类型主要有三类：</p><ul><li>Record Lock，记录锁，也就是仅仅把一条记录锁上；</li><li>Gap Lock，间隙锁，锁定一个范围，<strong>但是不包含记录本身</strong>；</li><li>Next-Key Lock： Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</li></ul><h4 id="Record-Lock"><a href="#Record-Lock" class="headerlink" title="Record Lock"></a>Record Lock</h4><p>Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的：</p><ul><li>当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;</li><li>当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。</li></ul><h4 id="Gap-Lock"><a href="#Gap-Lock" class="headerlink" title="Gap Lock"></a>Gap Lock</h4><p>Gap Lock 称为间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。</p><p>假设，表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id &#x3D; 4 这条记录了，这样就有效的防止幻读现象的发生。</p><p>间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，<strong>间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的</strong>。</p><h4 id="Next-Key-Lock"><a href="#Next-Key-Lock" class="headerlink" title="Next-Key Lock"></a>Next-Key Lock</h4><p>Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</p><p>假设，表中有一个范围 id 为（3，5] 的 next-key lock，那么其他事务即不能插入 id &#x3D; 4 记录，也不能修改 id &#x3D; 5 这条记录。</p><p>所以，next-key lock 即能保护该记录，又能阻止其他事务将新纪录插入到被保护记录前面的间隙中。</p><p><strong>next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的</strong>。</p><h4 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h4><p>一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。</p><p>如果有的话，插入操作就会发生<strong>阻塞</strong>，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个<strong>插入意向锁</strong>，表明有事务想在某个区间插入新记录，但是现在处于等待状态。</p><p>插入意向锁名字虽然有意向锁，但是它并<strong>不是意向锁，它是一种特殊的间隙锁，属于行级别锁</strong>。</p><p>如果说间隙锁锁住的是一个区间，那么「插入意向锁」锁住的就是一个点。因而从这个角度来说，插入意向锁确实是一种特殊的间隙锁。</p><h2 id="11、MYSQL的执行引擎有哪些？"><a href="#11、MYSQL的执行引擎有哪些？" class="headerlink" title="11、MYSQL的执行引擎有哪些？"></a>11、MYSQL的执行引擎有哪些？</h2><p>1、InnoDB</p><p>该引擎提供了对事务ACID的支持，还提供了行级锁和外键的支持。</p><p>2、MyISAM</p><p>该引擎不支持事务，也不支持行级锁和外键约束。</p><p>3、Memery</p><p>将数据放在内存中，数据处理速度很快，但是安全性不高。</p><h2 id="12、MYSQL的日志文件有哪几种？"><a href="#12、MYSQL的日志文件有哪几种？" class="headerlink" title="12、MYSQL的日志文件有哪几种？"></a>12、MYSQL的日志文件有哪几种？</h2><ul><li><strong>undo log（回滚日志）</strong>：是InnoDB存储引擎层生成的日志，实现了事务中的<strong>原子性</strong>，主要用于<strong>事务回滚</strong>和 MVCC。</li><li><strong>redo log（重做日志）</strong>：是 InnoDB存储引擎层生成的日志，实现了事务中的<strong>持久性</strong>，主要<strong>用于掉电等故障恢复</strong>；</li><li><strong>binlog （归档日志）</strong>：是 Server 层生成的日志，主要<strong>用于数据备份和主从复制</strong>；</li></ul><p>1、undo log 两大作用：</p><ul><li><strong>实现事务回滚，保障事务的原子性</strong>。事务处理过程中，如果出现了错误或者用户执 行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。</li><li><strong>实现 MVCC（多版本并发控制）关键因素之一</strong>。MVCC 是通过 Read View + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，<strong>顺着 undo log 的版本链</strong>找到满足其可见性的记录。</li></ul><p>2、redo log 和 undo log 区别在哪？</p><p>这两种日志是属于 InnoDB 存储引擎的日志，它们的区别在于：</p><ul><li>redo log 记录了此次事务「<strong>完成后</strong>」的数据状态，记录的是更新<strong>之后</strong>的值；</li><li>undo log 记录了此次事务「<strong>开始前</strong>」的数据状态，记录的是更新<strong>之前</strong>的值；</li></ul><p><strong>事务提交之前</strong>发生了崩溃，重启后会通过 undo log 回滚事务，<strong>事务提交之后</strong>发生了崩溃，重启后会通过 redo log 恢复事务。<strong>Redo</strong> log 保证了事务四大特性中的<strong>持久性。</strong></p><p>3、为什么需要 redo log 这个问题我们有两个答案：</p><ul><li><strong>实现事务的持久性，让 MySQL 有 crash-safe 的能力</strong>，能够保证 MySQL 在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失；</li><li><strong>将写操作从「随机写」变成了「顺序写」</strong>，提升 MySQL 写入磁盘的性能。</li></ul><p><strong>WAL 技术指的是， MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上</strong>。</p><p>4、产生的 redo log 是直接写入磁盘的吗？</p><p>不是的。</p><p>实际上， 执行一个事务的过程中，产生的 redo log 也不是直接写入磁盘的，因为这样会产生大量的 I&#x2F;O 操作，而且磁盘的运行速度远慢于内存。</p><p>所以，redo log 也有自己的缓存—— <strong>redo log buffer</strong>，每当产生一条 redo log 时，会先写入到 redo log buffer，后续在持久化到磁盘如下图：</p><p>5、redo log 和 bin log有什么区别？</p><p>这两个日志有四个区别。</p><p><em>1、适用对象不同：</em></p><ul><li>binlog 是 MySQL 的 Server 层实现的日志，所有存储引擎都可以使用；</li><li>redo log 是 InnoDB存储引擎实现的日志；</li></ul><p><em>2、文件格式不同：</em></p><ul><li>binlog 有 3 种格式类型，分别是 STATEMENT（默认格式）、ROW、 MIXED，区别如下：<ul><li>STATEMENT：每一条修改数据的 SQL 都会被记录到 binlog 中（相当于记录了逻辑操作，所以针对这种格式， binlog 可以称为逻辑日志），主从复制中 slave 端再根据 SQL 语句重现。但 STATEMENT 有动态函数的问题，比如你用了 uuid 或者 now 这些函数，你在主库上执行的结果并不是你在从库执行的结果，这种随时在变的函数会导致复制的数据不一致；</li><li>ROW：记录行数据最终被修改成什么样了（这种格式的日志，就不能称为逻辑日志了），不会出现 STATEMENT 下动态函数的问题。但 ROW 的缺点是每行数据的变化结果都会被记录，比如执行批量 update 语句，更新多少行数据就会产生多少条记录，使 binlog 文件过大，而在 STATEMENT 格式下只会记录一个 update 语句而已；</li><li>MIXED：包含了 STATEMENT 和 ROW 模式，它会根据不同的情况自动使用 ROW 模式和 STATEMENT 模式；</li></ul></li><li>redo log 是物理日志，记录的是在某个数据页做了什么修改，比如对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新；</li></ul><p><em>3、写入方式不同：</em></p><ul><li>binlog 是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志。</li><li><strong>redo log 是循环写</strong>，日志空间大小是固定，全部写满就从头开始，保存未被刷入磁盘的脏页日志。</li></ul><p><em>4、用途不同：</em></p><ul><li>binlog 用于备份恢复、主从复制；</li><li>redo log 用于掉电等故障恢复。</li></ul><h2 id="13、MySQL-磁盘-I-O-很高，有什么优化的方法？"><a href="#13、MySQL-磁盘-I-O-很高，有什么优化的方法？" class="headerlink" title="13、MySQL 磁盘 I&#x2F;O 很高，有什么优化的方法？"></a>13、MySQL 磁盘 I&#x2F;O 很高，有什么优化的方法？</h2><p>现在我们知道事务在提交的时候，需要将 binlog 和 redo log 持久化到磁盘，那么如果出现 MySQL 磁盘 I&#x2F;O 很高的现象，我们可以通过控制以下参数，来 “延迟” binlog 和 redo log 刷盘的时机，从而降低磁盘 I&#x2F;O 的频率：</p><ul><li>设置组提交的两个参数： binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count 参数，延迟 binlog 刷盘的时机，从而减少 binlog 的刷盘次数。这个方法是基于“额外的故意等待”来实现的，因此可能会增加语句的响应时间，但即使 MySQL 进程中途挂了，也没有丢失数据的风险，因为 binlog 早被写入到 page cache 了，只要系统没有宕机，缓存在 page cache 里的 binlog 就会被持久化到磁盘。</li><li>将 sync_binlog 设置为大于 1 的值（比较常见是 100~1000），表示每次提交事务都 write，但累积 N 个事务后才 fsync，相当于延迟了 binlog 刷盘的时机。但是这样做的风险是，主机掉电时会丢 N 个事务的 binlog 日志。</li><li>将 innodb_flush_log_at_trx_commit 设置为 2。表示每次事务提交时，都只是缓存在 redo log buffer 里的 redo log 写到 redo log 文件，注意写入到「 redo log 文件」并不意味着写入到了磁盘，因为操作系统的文件系统中有个 Page Cache，专门用来缓存文件数据的，所以写入「 redo log文件」意味着写入到了操作系统的文件缓存，然后交由操作系统控制持久化到磁盘的时机。但是这样做的风险是，主机掉电的时候会丢数据。</li></ul><h2 id="14、总结"><a href="#14、总结" class="headerlink" title="14、总结"></a>14、总结</h2><p>具体更新一条记录 <code>UPDATE t_user SET name = &#39;xiaolin&#39; WHERE id = 1;</code> 的流程如下:</p><ol><li>执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id &#x3D; 1 这一行记录：<ul><li>如果 id&#x3D;1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新；</li><li>如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。</li></ul></li><li>执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样：<ul><li>如果一样的话就不进行后续更新流程；</li><li>如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作；</li></ul></li><li>开启事务， InnoDB 层更新记录前，首先要记录相应的 undo log，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，不过在内存修改该 Undo 页面后，需要记录对应的 redo log。</li><li>InnoDB 层开始更新记录，会先更新内存（同时标记为脏页），然后将记录写到 redo log 里面，这个时候更新就算完成了。为了减少磁盘I&#x2F;O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。这就是 <strong>WAL 技术</strong>，MySQL 的写操作并不是立刻写到磁盘上，而是先写 redo 日志，然后在合适的时间再将修改的行数据写到磁盘上。</li><li>至此，一条记录更新完了。</li><li>在一条更新语句执行完成后，然后开始记录该语句对应的 binlog，此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。</li><li>事务提交（为了方便说明，这里不说组提交的过程，只说<strong>两阶段提交</strong>）：<ul><li><strong>prepare 阶段</strong>：将 redo log 对应的事务状态设置为 prepare，然后将 redo log 刷新到硬盘；</li><li><strong>commit 阶段</strong>：将 binlog 刷新到磁盘，接着调用引擎的提交事务接口，将 redo log 状态设置为 commit（将事务设置为 commit 状态后，刷入到磁盘 redo log 文件）；</li></ul></li><li>至此，一条更新语句执行完成。</li></ol><p><strong>为什么需要两阶段提交：</strong>事务提交后，redo log 和 binlog 都要持久化到磁盘，但是这两个是独立的逻辑，可能出现半成功的状态，这样就造成两份日志之间的逻辑不一致。</p><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="1、什么是Redis？"><a href="#1、什么是Redis？" class="headerlink" title="1、什么是Redis？"></a>1、什么是Redis？</h2><p>Redis是一种基于内存的数据库，对数据的读写操作都在内存中完成，因此读写速度非常快，通常用于缓存、消息队列、分布式锁等场景。</p><p>Redis 提供了多种数据类型来支持不同的业务场景，比如 String(字符串)、Hash(哈希)、 List (列表)、Set(集合)、Zset(有序集合)、Bitmaps（位图）、HyperLogLog（基数统计）、GEO（地理信息）、Stream（流），并且对数据类型的操作都是<strong>原子性</strong>的，因为执行命令由单线程负责的，不存在并发竞争的问题。</p><p>除此之外，Redis 还支持<strong>事务 、持久化、Lua 脚本、多种集群方案（主从复制模式、哨兵模式、切片机群模式）、发布&#x2F;订阅模式，内存淘汰机制、过期删除机制</strong>等等。</p><h2 id="2、Redis-和-Memcached-有什么区别？"><a href="#2、Redis-和-Memcached-有什么区别？" class="headerlink" title="2、Redis 和 Memcached 有什么区别？"></a>2、Redis 和 Memcached 有什么区别？</h2><p>Redis和Memcached都是内存数据库，为什么选择Redis而不选择Memcached？</p><p><strong>相同点：</strong></p><ol><li>都是基于内存的数据库，一般都用来当做缓存使用。</li><li>都有过期策略。</li><li>两者的性能都非常高。</li></ol><p>不同点：</p><ul><li>Redis 支持的<strong>数据类型更丰富</strong>（String、Hash、List、Set、ZSet），而 Memcached 只支持最简单的 key-value 数据类型；</li><li>Redis 支持<strong>数据的持久化</strong>，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而 Memcached 没有持久化功能，数据全部存在内存之中，Memcached 重启或者挂掉后，数据就没了；</li><li>Redis 原生<strong>支持集群模式</strong>，Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；</li><li>Redis 支持<strong>发布订阅模型</strong>、<strong>Lua 脚本</strong>、<strong>事务</strong>等功能，而 Memcached 不支持；</li></ul><h2 id="3、为什么用-Redis-作为-MySQL-的缓存？"><a href="#3、为什么用-Redis-作为-MySQL-的缓存？" class="headerlink" title="3、为什么用 Redis 作为 MySQL 的缓存？"></a>3、为什么用 Redis 作为 MySQL 的缓存？</h2><p>主要是因为 <strong>Redis 具备「高性能」和「高并发」两种特性</strong>。</p><p>1、高性能：</p><p>假如用户第一次访问 MySQL 中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据缓存在 Redis 中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了，操作 Redis 缓存就是直接操作内存，所以速度相当快。</p><p>2、高并发</p><p>单台设备的 Redis 的 QPS（Query Per Second，每秒钟处理完请求的次数） 是 MySQL 的 10 倍，Redis 单机的 QPS 能轻松破 10w，而 MySQL 单机的 QPS 很难破 1w。</p><p>所以，直接访问 Redis 能够承受的请求是远远大于直接访问 MySQL 的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p><h2 id="4、Redis数据结构和使用场景"><a href="#4、Redis数据结构和使用场景" class="headerlink" title="4、Redis数据结构和使用场景"></a>4、Redis数据结构和使用场景</h2><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" alt="img"></p><p>随着 Redis 版本的更新，后面又支持了四种数据类型： <strong>BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增）</strong>。 Redis 五种数据类型的应用场景：</p><ul><li>String 类型的应用场景：缓存对象、常规计数、分布式锁、共享 session 信息等。</li><li>List 类型的应用场景：消息队列（但是有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据）等。</li><li>Hash 类型：缓存对象、购物车等。</li><li>Set 类型：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。</li><li>Zset 类型：排序场景，比如排行榜、电话和姓名排序等。</li></ul><p>Redis 后续版本又支持四种数据类型，它们的应用场景如下：</p><ul><li>BitMap（2.2 版新增）：二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等；</li><li>HyperLogLog（2.8 版新增）：海量数据基数统计的场景，比如百万级网页 UV 计数等；</li><li>GEO（3.2 版新增）：存储地理位置信息的场景，比如滴滴叫车；</li><li>Stream（5.0 版新增）：消息队列，相比于基于 List 类型实现的消息队列，有这两个特有的特性：自动生成全局唯一消息ID，支持以消费组形式消费数据。</li></ul><h2 id="5、Redis是单线程的吗？"><a href="#5、Redis是单线程的吗？" class="headerlink" title="5、Redis是单线程的吗？"></a>5、Redis是单线程的吗？</h2><p><strong>Redis 单线程指的是「接收客户端请求-&gt;解析请求 -&gt;进行数据读写等操作-&gt;发送数据给客户端」这个过程是由一个线程（主线程）来完成的</strong>，这也是我们常说 Redis 是单线程的原因。</p><p>但是，<strong>Redis 程序并不是单线程的</strong>，Redis 在启动的时候，是会<strong>启动后台线程</strong>（BIO）的：</p><ul><li><strong>Redis 在 2.6 版本</strong>，会启动 2 个后台线程，分别处理关闭文件、AOF 刷盘这两个任务；</li><li><strong>Redis 在 4.0 版本之后</strong>，新增了一个新的后台线程，用来异步释放 Redis 内存，也就是 lazyfree 线程。例如执行 unlink key &#x2F; flushdb async &#x2F; flushall async 等命令，会把这些删除操作交给后台线程来执行，好处是不会导致 Redis 主线程卡顿。因此，当我们要删除一个大 key 的时候，不要使用 del 命令删除，因为 del 是在主线程处理的，这样会导致 Redis 主线程卡顿，因此我们应该使用 unlink 命令来异步删除大key。</li></ul><p>之所以 Redis 为「关闭文件、AOF 刷盘、释放内存」这些任务创建单独的线程来处理，是因为这些任务的操作都是很耗时的，如果把这些任务都放在主线程来处理，那么 Redis 主线程就很容易发生阻塞，这样就无法处理后续的请求了。</p><h2 id="6、Redis采用单线程模式为什么还这么快？"><a href="#6、Redis采用单线程模式为什么还这么快？" class="headerlink" title="6、Redis采用单线程模式为什么还这么快？"></a>6、Redis采用单线程模式为什么还这么快？</h2><ul><li>Redis 的大部分操作<strong>都在内存中完成</strong>，并且采用了高效的数据结构，因此 Redis 瓶颈可能是机器的内存或者网络带宽，而并非 CPU，既然 CPU 不是瓶颈，那么自然就采用单线程的解决方案了；</li><li>Redis 采用单线程模型可以<strong>避免了多线程之间的竞争</strong>，省去了多线程切换带来的时间和性能上的开销，而且也不会导致死锁问题。</li><li>Redis 采用了 <strong>I&#x2F;O 多路复用机制</strong>处理大量的客户端 Socket 请求，IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select&#x2F;epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听 Socket 和已连接 Socket。内核会一直监听这些 Socket 上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。</li></ul><h2 id="7、-Redis-如何实现数据不丢失？"><a href="#7、-Redis-如何实现数据不丢失？" class="headerlink" title="7、 Redis 如何实现数据不丢失？"></a>7、 Redis 如何实现数据不丢失？</h2><p>Redis 的读写操作都是在内存中，所以 Redis 性能才会高，但是当 Redis 重启后，内存中的数据就会丢失，那为了保证内存中的数据不会丢失，Redis 实现了数据持久化的机制，这个机制会把数据存储到磁盘，这样在 Redis 重启就能够从磁盘中恢复原有的数据。</p><p>Redis 共有三种数据持久化的方式：</p><ul><li><strong>AOF 日志</strong>：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里；</li><li><strong>RDB 快照</strong>：将某一时刻的内存数据，以二进制的方式写入磁盘；</li><li><strong>混合持久化方式</strong>：Redis 4.0 新增的方式，集成了 AOF 和 RBD 的优点；</li></ul><h2 id="8、AOF-日志是如何实现的？"><a href="#8、AOF-日志是如何实现的？" class="headerlink" title="8、AOF 日志是如何实现的？"></a>8、AOF 日志是如何实现的？</h2><p>Redis 在执行完一条写操作命令后，就会把该命令以追加的方式写入到一个文件里，然后 Redis 重启时，会读取该文件记录的命令，然后逐一执行命令的方式来进行数据恢复。</p><blockquote><p>为什么先执行命令，再把数据写入日志呢？</p></blockquote><p>Redis 是先执行写操作命令后，才将该命令记录到 AOF 日志里的，这么做其实有两个好处。</p><ul><li><strong>避免额外的检查开销</strong>：因为如果先将写操作命令记录到 AOF 日志里，再执行该命令的话，如果当前的命令语法有问题，那么如果不进行命令语法检查，该错误的命令记录到 AOF 日志里后，Redis 在使用日志恢复数据时，就可能会出错。</li><li><strong>不会阻塞当前写操作命令的执行</strong>：因为当写操作命令执行成功后，才会将命令记录到 AOF 日志。</li></ul><p>当然，这样做也会带来风险：</p><ul><li><strong>数据可能会丢失：</strong> 执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个数据就会有丢失的风险。</li><li><strong>可能阻塞其他操作：</strong> 由于写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前命令的执行，但因为 AOF 日志也是在主线程中执行，所以当 Redis 把日志文件写入磁盘的时候，还是会阻塞后续的操作无法执行。</li></ul><p>AOF 写回策略有几种？</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/98987d9417b2bab43087f45fc959d32a-20230309232253633.png" alt="img"></p><blockquote><p>AOF 日志过大，会触发什么机制？</p></blockquote><p>AOF 日志是一个文件，随着执行的写操作命令越来越多，文件的大小会越来越大。 如果当 AOF 日志文件过大就会带来性能问题，比如重启 Redis 后，需要读 AOF 文件的内容以恢复数据，如果文件过大，整个恢复的过程就会很慢。</p><p><strong>所以，Redis 为了避免 AOF 文件越写越大，提供了 AOF 重写机制，当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件。</strong></p><p>AOF 重写机制是在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件。</p><h2 id="9、RDB-快照是如何实现的呢？"><a href="#9、RDB-快照是如何实现的呢？" class="headerlink" title="9、RDB 快照是如何实现的呢？"></a>9、RDB 快照是如何实现的呢？</h2><p>因为 AOF 日志记录的是操作命令，不是实际的数据，所以用 AOF 方法做故障恢复时，需要全量把日志都执行一遍，一旦 AOF 日志非常多，势必会造成 Redis 的恢复操作缓慢。</p><p>为了解决这个问题，Redis 增加了 RDB 快照。所谓的快照，就是记录某一个瞬间东西，比如当我们给风景拍照时，那一个瞬间的画面和信息就记录到了一张照片。</p><p>所以，<strong>RDB 快照就是记录某一个瞬间的内存数据，记录的是实际数据</strong>，而 <strong>AOF 文件记录的是命令操作的日志</strong>，而不是实际的数据。</p><p>因此在 Redis 恢复数据时， RDB 恢复数据的效率会比 AOF 高些，因为直接将 RDB 文件读入内存就可以，不需要像 AOF 那样还需要额外执行操作命令的步骤才能恢复数据。</p><blockquote><p>RDB 做快照时会阻塞线程吗？</p></blockquote><p>Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave，他们的区别就在于是否在「主线程」里执行：</p><ul><li>执行了 save 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，<strong>会阻塞主线程</strong>；</li><li>执行了 bgsave 命令，会创建一个子进程来生成 RDB 文件，这样可以<strong>避免主线程的阻塞</strong>；</li></ul><p>这里提一点，Redis 的快照是<strong>全量快照</strong>，也就是说每次执行快照，都是把内存中的「<strong>所有数据</strong>」都记录到磁盘中。所以执行快照是一个比较重的操作，如果频率太频繁，可能会对 Redis 性能产生影响。如果频率太低，服务器故障时，丢失的数据会更多。</p><blockquote><p>RDB 在执行快照的时候，数据能修改吗？</p></blockquote><p><strong>可以的</strong>，执行 bgsave 过程中，Redis 依然<strong>可以继续处理操作命令</strong>的，也就是数据是能被修改的，关键的技术就在于<strong>写时复制技术（Copy-On-Write, COW）。</strong></p><p>执行 bgsave 命令的时候，会通过 fork() 创建子进程，此时子进程和父进程是<strong>共享同一片内存数据</strong>的，因为创建子进程的时候，会复制父进程的页表，但是页表指向的物理内存还是一个，此时如果主线程执行<strong>读操作</strong>，则主线程和 bgsave 子进程互相不影响。如果主线程执行<strong>写操作</strong>，则被修改的数据会复制一份副本，然后 bgsave 子进程会把该副本数据写入 RDB 文件，在这个过程中，主线程仍然可以直接修改原来的数据。</p><h2 id="10、为什么会有混合持久化？"><a href="#10、为什么会有混合持久化？" class="headerlink" title="10、为什么会有混合持久化？"></a>10、为什么会有混合持久化？</h2><p>RDB 优点是数据恢复速度快，但是快照的频率不好把握。频率太低，丢失的数据就会比较多，频率太高，就会影响性能。</p><p>AOF 优点是丢失数据少，但是数据恢复不快。</p><p>为了集成了两者的优点， Redis 4.0 提出了<strong>混合使用 AOF 日志和内存快照</strong>，也叫混合持久化，既保证了 Redis 重启速度，又降低数据丢失风险。</p><p>混合持久化工作在 <strong>AOF 日志重写过程</strong>，当开启了混合持久化时，在 AOF 重写日志时，fork 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的AOF 文件。</p><p>也就是说，使用了混合持久化，AOF 文件的<strong>前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据</strong>，这样的好处在于，重启 Redis 加载数据的时候，由于前半部分是 RDB 内容，这样<strong>加载的时候速度会很快</strong>。</p><p>加载完 RDB 的内容后，才会加载后半部分的 AOF 内容，这里的内容是 Redis 后台子进程重写 AOF 期间，主线程处理的操作命令，可以使得<strong>数据更少的丢失</strong>。</p><p><strong>混合持久化优点：</strong></p><ul><li>混合持久化结合了 RDB 和 AOF 持久化的优点，开头为 RDB 的格式，使得 Redis 可以更快的启动，同时结合 AOF 的优点，有减低了大量数据丢失的风险。</li></ul><p><strong>混合持久化缺点：</strong></p><ul><li>AOF 文件中添加了 RDB 格式的内容，使得 AOF 文件的可读性变得很差；</li><li>兼容性差，如果开启混合持久化，那么此混合持久化 AOF 文件，就不能用在 Redis 4.0 之前版本了。</li></ul><h1 id="C-语言基础"><a href="#C-语言基础" class="headerlink" title="C++语言基础"></a>C++语言基础</h1><h2 id="1、虚函数与纯虚函数的区别"><a href="#1、虚函数与纯虚函数的区别" class="headerlink" title="1、虚函数与纯虚函数的区别"></a>1、虚函数与纯虚函数的区别</h2><p><strong>虚函数</strong> </p><p>有实现： 虚函数有函数声明和实现，即在基类中可以提供默认实现。 </p><p>可选实现： 派⽣类可以选择是否覆盖虚函数。如果派⽣类没有提供实现，将使⽤基类的默认实现。 </p><p>允许实例化： 虚函数的类可以被实例化。即你可以创建⼀个虚函数的类的对象。 调⽤靠对象类型决定： 在运⾏时，根据对象的实际类型来决定调⽤哪个版本的虚函数。 </p><p>⽤ virtual 关键字声明： 虚函数使⽤ virtual 关键字声明，但不包含 &#x3D; 0 。</p><p><strong>纯虚函数</strong> </p><p>没有实现： 纯虚函数没有函数体，只有函数声明，即没有提供默认的实现。 </p><p>强制覆盖： 派⽣类必须提供纯虚函数的具体实现，否则它们也会成为<strong>抽象类</strong>。 </p><p>禁⽌实例化： 包含纯虚函数的类⽆法被实例化，只能⽤于派⽣其他类。</p><p>⽤ &#x3D; 0 声明： 纯虚函数使⽤ &#x3D; 0 在函数声明末尾进⾏声明。</p><p> 为接⼝提供规范： 通过纯虚函数，抽象类提供⼀种接⼝规范，要求派⽣类提供相关实现。</p><h2 id="2、CPP怎么实现多态？"><a href="#2、CPP怎么实现多态？" class="headerlink" title="2、CPP怎么实现多态？"></a>2、CPP怎么实现多态？</h2><p>1、函数重载：通过在同一个作用域内定义多个同名函数，但是参数类型和数量不同，编译器会根据调用时提供的参数来决定调用哪个函数版本。</p><p>2、运算符重载：允许定义或修改大部分运算符的默认行为。</p><p>3、模板：通过模板函数或模板类，可以编写泛型代码，实现对多种类型的操作，而无需知道这些类型的具体细节。</p><p>4、抽象基类：使用包含纯虚函数的类作为接口，强制派生类提供纯虚函数的具体实现。</p><p>5、动态多态：除了虚函数外，还可以通过指针或引用传递基类类型的对象，而在运行时根据对象的实际类型来调用相应的成员函数，这通常与虚函数一起使用。</p><p>6、静态多态：也称为编译时多态，包括函数重载和模版，由于在编译时已经确定了调用哪个函数，所以称为静态多态。</p><h2 id="3、new-和-malloc的区别"><a href="#3、new-和-malloc的区别" class="headerlink" title="3、new 和 malloc的区别"></a>3、new 和 malloc的区别</h2><p>1、new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。</p><p>  2、使⽤new操作符申请内存分配时⽆须指定内存块的⼤⼩，⽽malloc则需要显式地指出所需内存的尺⼨。 </p><p> 3、opeartor new &#x2F;operator delete可以被重载，⽽malloc&#x2F;free并不允许重载。 </p><p> 4、new&#x2F;delete会调⽤对象的构造函数&#x2F;析构函数以完成对象的构造&#x2F;析构。⽽malloc则不会  </p><p>5、malloc与free是C++&#x2F;C语⾔的标准库函数,new&#x2F;delete是C++的运算符  </p><p>6、new操作符从⾃由存储区上为对象动态分配内存空间，⽽malloc函数从堆上动态分配内存。</p><h2 id="4、讲一讲封装、继承、多态是什么？"><a href="#4、讲一讲封装、继承、多态是什么？" class="headerlink" title="4、讲一讲封装、继承、多态是什么？"></a>4、讲一讲封装、继承、多态是什么？</h2><p><strong>封装：</strong>将一个功能或者方法的实现过程以及所需要的数据封装成一个函数，对外提供一个公共的访问接口以供其他程序调用，降低耦合性。这么做使得类成为一个具有内部数据自我隐藏能力、功能独立的软件模块。</p><p>意义：保护类中的成员，保护或者防止代码在无意中被破坏，避免了让类外成员直接访问或修改类中的数据，只能通过类提供的接口进行访问。</p><p><strong>继承：</strong>子类可以继承父类的特征和行为，可以复用基类（父类）的全体数据和成员函数具有从基类（父类）复制而来的成员数据和成员函数。（基类的私有成员可以被继承，但是无法被访问）。其中<strong>构造函数、析构函数、友元函数、静态数据成员、静态成员函数</strong>都不能被继承。基类中成员的访问方式只能决定派生类能否访问它们。增强了代码耦合性，当父类中的成员变量或者类本身被final关键字修饰时，修饰的类不能被继承，修饰的成员变量不能重写或修改。</p><p>意义：基类的程序代码可以被派生类服用，提高了软件复用的效率，缩短了软件开发的周期。</p><p><strong>多态：</strong>不同继承类的对象对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现形式。</p><p>意义：对已存在的代码具有可替代性，对代码具有可扩充性，新增子类不会影响已存在类的各种性质，在程序中体现了灵活多样的操作，提高了使用效率，简化了对应用代码的编写和修改过程。</p><h2 id="5、多态的实现原理（实现方式）是什么？以及多态的优点（特点）？"><a href="#5、多态的实现原理（实现方式）是什么？以及多态的优点（特点）？" class="headerlink" title="5、多态的实现原理（实现方式）是什么？以及多态的优点（特点）？"></a>5、多态的实现原理（实现方式）是什么？以及多态的优点（特点）？</h2><p>实现方式：多态分为动态多态（动态多态是利用虚函数实现运行时的多态，即在系统编译的时候并不知道程序将要调用哪一个函数，只有在运行到这里的时候才能确定接下来会跳转到哪一个函数。）和静态多态（又称编译期多态，即在系统编译期间就可以确定程序将要执行哪个函数），其中动态多态是通过虚函数实现的，虚函数是类的成员函数，存在存储虚函数指针的表叫做虚函数表，虚函数表是一个存储类成员虚函数的指针，每个指针都指向调用它的地方，当子类调用虚函数时，就会去虚表里面找自己对应的函数指针，从而实现“谁调用、实现谁”从而实现多态。而静态多态则是通过函数重载（函数名相同，参数不同，两个函数在同一作用域），运算符重载，和重定义（又叫隐藏，指的是在继承关系中，子类实现了一个和父类名字一样的函数，（只关注函数名，和参数与返回值无关）这样的话子类的函数就把父类的同名函数隐藏了。隐藏只与函数名有关，与参数没有关系.）来实现的。</p><p>优点：加强代码的可扩展性，可替换性，增强程序的灵活性，提高使用效率，简化对应用代码的编写和修改过程。</p><h2 id="6、final标识符的作用是什么"><a href="#6、final标识符的作用是什么" class="headerlink" title="6、final标识符的作用是什么"></a>6、final标识符的作用是什么</h2><p>放在类的后面表示该类无法被继承，也就是阻止了从类的继承，放在虚函数后面该虚函数无法被重写，表示阻止虚函数的重载</p><h2 id="7、虚函数是怎么实现的？它存放在哪里在内存的哪个区？什么时候生成的"><a href="#7、虚函数是怎么实现的？它存放在哪里在内存的哪个区？什么时候生成的" class="headerlink" title="7、虚函数是怎么实现的？它存放在哪里在内存的哪个区？什么时候生成的"></a>7、虚函数是怎么实现的？它存放在哪里在内存的哪个区？什么时候生成的</h2><p>在C++中，虚函数的实现原理基于两个关键概念：虚函数表和虚函数指针</p><p>虚函数表：每个包含虚函数的类都会生成一个虚函数表，其中存储着该类中所有虚函数的地址。虚函数表是一个由指针构成的数组，每个指针指向一个虚函数的实现代码。</p><p>虚函数指针：在对象的内存布局中，编译器会添加一个额外的指针，称为虚函数指针或虚表指针。这个指针指向该对象对应的虚函数表，从而让程序能够动态的调用虚函数。</p><p>当一个基类指针或引用调用虚函数时，编译器会使用虚表指针来查找该对象对应的虚函数表，并根据函数在虚函数表中的位置来调用正确的虚函数。</p><p>在编译阶段生成，虚函数和普通函数一样存放在代码段，只是它的指针又存放在了虚表之中。</p><h2 id="8、智能指针的本质是什么，它们的实现原理是什么？"><a href="#8、智能指针的本质是什么，它们的实现原理是什么？" class="headerlink" title="8、智能指针的本质是什么，它们的实现原理是什么？"></a>8、智能指针的本质是什么，它们的实现原理是什么？</h2><p>智能指针本质是一个封装了一个原始C++指针的类模板，为了确保动态内存的安全性而产生的。实现原理是通过一个对象存储需要被自动释放的资源，然后依靠对象的析构函数来释放资源。</p><p>智能指针⽤于管理动态内存的对象，其主要⽬的是在避免内存泄漏和⽅便资源管理。</p><p>分为独占智能指针、共享智能指针和弱引用智能指针。</p><p>std::unique_ptr （独占智能指针）提供对动态分配的单⼀对象所有权的独占管理。通过独占所有权，确保只有⼀个 std::unique_ptr 可以拥有指定的内存资源。移动语义和右值引⽤允许 std::unique_ptr 在所有权转移时⾼ 效地进⾏转移。</p><p>std::shared_ptr （共享智能指针）允许多个智能指针共享同⼀块内存资源。内部使⽤引⽤计数来跟踪对象被共享的次数，当计数 为零时，资源被释放。提供更灵活的内存共享，但可能存在循环引⽤的问题。</p><p>std::weak_ptr （弱引用智能指针）⽤于解决 std::shared_ptr 可能导致的循环引⽤问题。 std::weak_ptr 可以从 std::shared_ptr 创建，但不会增加引⽤计数，不会影响资源的释放。 通过 std::weak_ptr::lock() 可以获取⼀个 std::shared_ptr 来访问资源。</p><h2 id="9、匿名函数的本质是什么？他的优点是什么？"><a href="#9、匿名函数的本质是什么？他的优点是什么？" class="headerlink" title="9、匿名函数的本质是什么？他的优点是什么？"></a>9、匿名函数的本质是什么？他的优点是什么？</h2><p>匿名函数本质上是一个对象，在其定义的过程中会创建出一个栈对象，内部通过<strong>重载()符号</strong>实现函数调用的外表。</p><p>优点：使用匿名函数，可以免去函数的声明和定义。这样匿名函数仅在调用函数的时候才会创建函数对象，而调用结束后立即释放，所以匿名函数比非匿名函数更节省空间。</p><h2 id="10、delete-和-free-有什么区别？"><a href="#10、delete-和-free-有什么区别？" class="headerlink" title="10、delete 和 free 有什么区别？"></a>10、delete 和 free 有什么区别？</h2><p>类型安全性： delete 会调⽤对象的析构函数，确保资源被正确释放。 free 不了解对象的构造和析构，只是简单地释放内存块。 </p><p>内存块释放后的⾏为： delete 释放的内存块的指针值会被设置为 nullptr ，以避免ᰀ指针。 free 不会修改指针的值，可能导致ᰀ指针问题。 </p><p>数组的释放： delete 可以正确释放通过 new[] 分配的数组。 free 不了解数组的⼤⼩，不适⽤于释放通过 malloc 分配的数组。</p><h2 id="11、什么是野指针，如何产生以及如何避免？"><a href="#11、什么是野指针，如何产生以及如何避免？" class="headerlink" title="11、什么是野指针，如何产生以及如何避免？"></a>11、什么是野指针，如何产生以及如何避免？</h2><p>野指针是指指向已被释放或无效的的内存地址的指针，使用野指针可能会导致程序崩溃、数据损坏或其他不可预测的行为。通常由以下几种情况产生：</p><p>1、释放后没有置空指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span>* ptr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br><span class="hljs-keyword">delete</span> ptr;<br><span class="hljs-comment">// 此时 ptr 成为ᰀ指针，因为它仍然指向已经被释放的内存</span><br>ptr = <span class="hljs-literal">nullptr</span>; <br></code></pre></td></tr></table></figure><p>2、返回局部变量的指针（局部变量在函数调用后被销毁，返回的指针成为了野指针&#x2F;悬浮指针）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">createInt</span><span class="hljs-params">()</span> </span>&#123;<br> <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br> <span class="hljs-keyword">return</span> &amp;x; <span class="hljs-comment">// x 是局部变ᰁ，函数结束后 x 被销毁，返回的指针成为野指针</span><br>&#125;<br><span class="hljs-comment">// 在使⽤返回值时可能引发未定义⾏为</span><br></code></pre></td></tr></table></figure><p>3、释放内存后没有调整指针指向（同1）</p><p>4、函数参数指针被释放</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>* ptr)</span> </span>&#123;<br> <span class="hljs-comment">// 操作 ptr</span><br> <span class="hljs-keyword">delete</span> ptr;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br> <span class="hljs-type">int</span>* ptr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br> <span class="hljs-built_in">foo</span>(ptr);<br> <span class="hljs-comment">// 在 foo 函数中 ptr 被释放，但在 main 函数中仍然可⽤，成为野指针</span><br> <span class="hljs-comment">// 避免：在 foo 函数中不要释放调⽤⽅传递的指针</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对应的解决方法以及避免野指针的方法：</p><p>1、释放内存后将指针设置为nullptr；2、避免返回局部变量的指针；3、使用智能指针；4、注意函数参数的生命周期，避免在函数内释放调用方传递的指针。</p><h2 id="12、野指针和悬浮指针的区别"><a href="#12、野指针和悬浮指针的区别" class="headerlink" title="12、野指针和悬浮指针的区别"></a>12、野指针和悬浮指针的区别</h2><p>野指针是指向已经被释放或者⽆效的内存地址的指针。通常由于指针指向的内存被释放，但指针本身没有被置为 nullptr 或者重新分配有效的内存，导致指针仍然包含之前的内存地址。使⽤野指针进⾏访问会导致未定义⾏ 为，可能引发程序崩溃、数据损坏等问题。</p><p> 悬浮指针是<strong>指向已经被销毁的对象的引⽤</strong>。当函数返回⼀个局部变量的引⽤，⽽调⽤者使⽤该引⽤时，就可能产⽣ 悬浮引⽤。访问悬浮引⽤会导致未定义⾏为，因为引⽤指向的对象已经被销毁，数据不再有效。</p><h2 id="13、说说C-的内存分配方式"><a href="#13、说说C-的内存分配方式" class="headerlink" title="13、说说C++的内存分配方式"></a>13、说说C++的内存分配方式</h2><p>（1）从静态存储区域分配：内存在程序编译的时候就已经分配好，这块内存在程序的整个运⾏期间都存在，如全局变量，static变量。 </p><p>（2）在栈上创建：在执⾏函数时，函数内局部变量的存储单元都可以在栈上创建，函数执⾏结束时这些存储单元⾃动被释放。栈内存 分配运算内置于处理器的指令集中，效率很⾼，但是分配的内存容量有限。 </p><p>（3）从堆上分配(动态内存分配) 程序在运⾏的时候⽤malloc或new申请任意多少的内存，程序员负责在何时⽤free或delete释放内存。动态内存的 ⽣存期⾃⼰决定，使⽤⾮常灵活。</p><h2 id="14、成员函数、成员变量、静态成员变量、静态成员函数的区别成员函数"><a href="#14、成员函数、成员变量、静态成员变量、静态成员函数的区别成员函数" class="headerlink" title="14、成员函数、成员变量、静态成员变量、静态成员函数的区别成员函数"></a>14、成员函数、成员变量、静态成员变量、静态成员函数的区别成员函数</h2><p>1、成员函数</p><p>是属于类的函数，它们可以访问类的成员变量和其他成员函数。 成员函数可以分为普通成员函数和静态成员函数。 普通成员函数使⽤对象调⽤，可以访问对象的成员变量。 普通成员函数的声明和定义通常在类的内部，但定义时需要使⽤类名作为限定符。</p><p>2、成员变量</p><p>成员变量是属于类的变量，存储在类的每个对象中。 每个对象拥有⼀份成员变量的副本，它们在对象创建时分配，并在对象销毁时释放。 成员变量的访问权限可以是 public 、 private 或 protected 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br> <span class="hljs-type">int</span> memberVariable; <span class="hljs-comment">// 成员变量的声明</span><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">memberFunction</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// 普通成员函数使用对象调用</span><br> <span class="hljs-comment">// 成员函数的实现</span><br> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>3、静态成员函数</p><p> 静态成员函数属于类⽽不是对象，因此可以直接通过类名调⽤，⽽不需要创建类的实例。 静态成员函数不能直接访问普通成员变量，因为它们没有隐含的 this 指针。 静态成员函数的声明和定义也通常在类的内部，但在定义时需要使⽤类名作为限定符。</p><p>4、 静态成员变量</p><p> 静态成员变量是属于类⽽不是对象的变量，它们在所有对象之间共享。 静态成员变量通常在类的声明中进⾏声明，但在类的定义外进⾏定义和初始化。 静态成员变量可以通过类名或对象访问。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br> <span class="hljs-type">static</span> <span class="hljs-type">int</span> staticMemberVariable; <span class="hljs-comment">// 静态成员变量的声明</span><br> <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">staticMemberFunction</span><span class="hljs-params">()</span> </span>&#123;<br> <span class="hljs-comment">// 静态成员函数的实现</span><br> &#125;<br>&#125;;<br><span class="hljs-type">int</span> MyClass::staticMemberVariable = <span class="hljs-number">0</span>;<span class="hljs-comment">// 静态成员变量的定义和初始化</span><br></code></pre></td></tr></table></figure><h2 id="15、什么是抽象类和纯虚函数？（接1）"><a href="#15、什么是抽象类和纯虚函数？（接1）" class="headerlink" title="15、什么是抽象类和纯虚函数？（接1）"></a>15、什么是抽象类和纯虚函数？（接1）</h2><p>抽象类是不能被实例化的类，它存在的主要⽬的是为了提供⼀个接⼝，供派⽣类继承和实现。抽象类中可以包含普通的成员函数、数据成员和构造函数，但它必须<strong>包含⾄少⼀个纯虚函数</strong>。即在声明中使⽤ virtual 关键字并赋予 函数⼀个 &#x3D; 0 的纯虚函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractShape</span> &#123;<br><span class="hljs-keyword">public</span>:<br> <span class="hljs-comment">// 纯虚函数，提供接⼝</span><br> <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br> <span class="hljs-comment">// 普通成员函数</span><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">commonFunction</span><span class="hljs-params">()</span> </span>&#123;<br> <span class="hljs-comment">// 具体实现</span><br> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>纯虚函数是在抽象类中声明的虚函数，它<strong>没有具体的实现，只有函数的声明</strong>。通过在函数声明的末尾使⽤ &#x3D; 0 ， 可以将虚函数声明为纯虚函数。派⽣类必须实现抽象类中的纯虚函数，否则它们也会成为抽象类。</p><h2 id="16、为什么有虚析构函数，没有虚构造函数？"><a href="#16、为什么有虚析构函数，没有虚构造函数？" class="headerlink" title="16、为什么有虚析构函数，没有虚构造函数？"></a>16、为什么有虚析构函数，没有虚构造函数？</h2><p><strong>虚析构函数</strong>是⼀个带有 virtual 关键字的析构函数。 主要作⽤是确保在通过基类指针删除派⽣类对象时，能够正确调⽤派⽣类的析构函数，从⽽释放对象所占⽤的资源。 通常，如果⼀个类可能被继承，且在其派⽣类中有可能使⽤ delete 运算符来删除通过基类指针指向的对象，那么该基类的析构函数应该声明为虚析构函数。</p><p>因此，<strong>虚析构函数</strong>的作用是：</p><p>1、允许在<strong>运行的时候</strong>根据对象的实际类型调用正确的析构函数，从而实现多态性。</p><p>2、如果基类的析构函数不是虚函数，当通过基类指针删除指向派生类的对象时，只会调用基类的析构函数，不会调用派生类的析构函数，可能会导致派生类的资源未被正确释放，造成内存泄漏。</p><p>构造函数在对象的<strong>创建阶段</strong>被调⽤，对象的类型在构造函数中已经确定。因此，构造函数调⽤不涉及多态性，也就 是说，在对象的构造期间⽆法实现动态绑定。虚构造函数没有意义，因为对象的类型在构造过程中就已经确定，不需要动态地选择构造函数。</p><p>1、从存储空间⻆度：虚函数对应⼀个vtable,这个表的地址是存储在对象的内存空间的。如果将构造函数设置为虚函数，就需要到vtable 中调⽤，可是对象还没有实例化，没有内存空间分配，如何调⽤。（悖论）</p><p> 2、从使⽤⻆度：虚函数主要⽤于在信息不全的情况下，能使重载的函数得到对应的调⽤。构造函数本身就是要初 始化实例，那使⽤虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。虚函数的作⽤在于通过⽗类的 指针或者引⽤来调⽤它的时候能够变成调⽤⼦类的那个成员函数。⽽构造函数是在创建对象时⾃动调⽤的，不可能通过⽗类的指针或者引⽤去调⽤，因此也就规定构造函数不能是虚函数。 </p><p>3、从实现上看，vtable 在构造函数调⽤后才建⽴，因⽽构造函数不可能成为虚函数。从实际含义上看，在调⽤构造 函数时还不能确定对象的真实类型（因为⼦类会调⽗类的构造函数）；⽽且构造函数的作⽤是提供初始化，在对象⽣命期只执⾏⼀次，不是对象的动态⾏为，也没有太⼤的必要成为虚函数。</p><h2 id="17、哪些函数不能被声明为虚函数？"><a href="#17、哪些函数不能被声明为虚函数？" class="headerlink" title="17、哪些函数不能被声明为虚函数？"></a>17、哪些函数不能被声明为虚函数？</h2><p>构造函数：在对象创建时调用，对象的类型在创建时期已经确定，虚函数是在运行阶段动态绑定，二者矛盾。</p><p>普通函数（非成员函数），在编译阶段绑定，只能重载，不能重写。</p><p>静态成员函数：对于每一个类都只有一份代码，共享，不需要动态绑定。</p><p>友元函数：C++不支持友元函数的继承，对于没有继承性质的函数没有虚函数的说法。</p><p>内联成员函数：内联函数就是为了在代码中直接展开，减少函数调⽤花费的代价，虚函数是为了在继承后对象能够准确的执⾏⾃⼰ 的动作，这是不可能统⼀的。（再说了，inline函数在编译时被展开，虚函数在运⾏时才能动态的绑定函数）</p><h2 id="18、深拷贝和浅拷贝的区别"><a href="#18、深拷贝和浅拷贝的区别" class="headerlink" title="18、深拷贝和浅拷贝的区别"></a>18、深拷贝和浅拷贝的区别</h2><p>主要区别是如何处理对象内部动态分配的资源。</p><p>1、深拷贝：</p><p>深拷⻉是对对象的完全独⽴复制，包括对象内部动态分配的资源。在深拷⻉中，不仅复制对象的值，还会复制对象 所指向的堆上的数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DeepCopyExample</span> &#123;<br><span class="hljs-keyword">public</span>:<br> <span class="hljs-type">int</span> *data;<br> <span class="hljs-built_in">DeepCopyExample</span>(<span class="hljs-type">const</span> DeepCopyExample &amp;other) &#123;<br> <span class="hljs-comment">// ⼿动分配内存并复制数据</span><br> data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*(other.data));<br> &#125;<br> ~<span class="hljs-built_in">DeepCopyExample</span>() &#123;<br> <span class="hljs-comment">// 释放动态分配的资源</span><br> <span class="hljs-keyword">delete</span> data;<br> &#125;<br> DeepCopyExample&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> DeepCopyExample &amp;other) &#123;<span class="hljs-comment">// 重载 = 号 用于深拷贝的赋值</span><br> <span class="hljs-comment">// 复制数据</span><br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br> <span class="hljs-keyword">delete</span> data;<br> data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*(other.data));<br> &#125;<br> <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>2、 浅拷⻉ ：</p><p>浅拷⻉仅复制对象的值，⽽不涉及对象内部动态分配的资源。在浅拷⻉中，新对象和原对象共享相同的资源，⽽不 是复制⼀份新的资源。</p><h2 id="19、什么是STL（标准模板库），包含哪些组件？"><a href="#19、什么是STL（标准模板库），包含哪些组件？" class="headerlink" title="19、什么是STL（标准模板库），包含哪些组件？"></a>19、什么是STL（标准模板库），包含哪些组件？</h2><p><strong>⼴义上讲</strong>，STL分为3类：Algorithm（算法）、Container（容器）和Iterator（迭代器），容器和算法通过迭代器 可以进⾏⽆缝地连接。 </p><p>详细的说，STL由6部分组成：容器(Container)、算法（Algorithm）、 迭代器（Iterator）、仿函数（Function object）、适配器（Adaptor）、空间配制器（Allocator）。 STL提供了六⼤组件，彼此之间可以组合套⽤，这六⼤组件分别是:容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器。</p><p>  STL六⼤组件的交互关系：</p><p>1、容器通过空间配置器取得数据存储空间 </p><p>2、算法通过迭代器存储容器中的内容  </p><p>3、仿函数可以协助算法完成不同的策略的变化  </p><p>4、适配器可以修饰仿函数</p><p>容器: vector map list deque set等用来存放数据，从实现角度看是一种类模板（class template）</p><p>算法：sort find for_each copy等，从实现角度来看，是一种函数模板（function template）</p><p>迭代器：扮演着容器与算法之间的粘合剂，从实现⻆度来看，迭代器是⼀种将operator* , operator-&gt; , operator++,operator–等指针相关操作予以重载的class template。（类模板）</p><p>仿函数：⾏为类似函数，可作为算法的某种策略。从实现⻆度来看，仿函数是⼀种重载了operator()的class 或者class template </p><p>适配器：用来修饰容器、仿函数、或迭代器的接口</p><p>STL提供的queue 和 stack，虽然看似容器，但其实只能算是⼀种容器配接器，因为它们的底部完全借助deque， 所有操作都由底层的deque供应。</p><p>空间配置器：负责空间的配置与管理。从实现⻆度看，配置器是⼀个实现了动态空间配置、空间管理、空间释放的class template.  ⼀般的分配器的std:alloctor都含有两个函数allocate与deallocte，这两个函数分别调⽤operator new()与 delete()，这两个函数的底层⼜分别是malloc()and free();但是每次malloc会带来格外开销（因为每次malloc⼀个元素都要带有附加信息）</p><h2 id="20、STL的优点"><a href="#20、STL的优点" class="headerlink" title="20、STL的优点"></a>20、STL的优点</h2><p>STL具有高可重用性、高性能、高移植性、跨平台的优点。</p><p>1、高可重用性：STL中所有的代码都采用了模板类和模板函数的方式实现，相比于传统的由函数和类组成的库来说，提供了更好的代码重用机会。</p><p>2、高性能：例如map可以高效的从几十万的记录里面查出指定的记录，map底层采用红黑树实现。</p><p>3、高移植性</p><p>STL 的⼀个᯿要特性是将数据和操作分离 数据由容器类别加以管理，操作则由可定制的算法定义。迭代器在两者之间充当“粘合剂”,以使算法可以和容器交互 运作。</p><h2 id="21、vector和list的区别"><a href="#21、vector和list的区别" class="headerlink" title="21、vector和list的区别"></a>21、vector和list的区别</h2><p>1、vector底层实现是数组；list是双向链表 </p><p>2、vector是顺序内存,⽀持随机访问，list不⾏</p><p>3、 vector在中间节点进⾏插⼊删除会导致内存拷⻉，list不会 </p><p>4、vector⼀次性分配好内存，不够时才进⾏翻倍扩容；list每次插⼊新节点都会进⾏内存申请 </p><p>5、vector随机访问性能好，插⼊删除性能差；list随机访问性能差，插⼊删除性能好</p><h2 id="22、map-set的区别和实现原理"><a href="#22、map-set的区别和实现原理" class="headerlink" title="22、map &amp;&amp; set的区别和实现原理"></a>22、map &amp;&amp; set的区别和实现原理</h2><p> map内部实现了⼀个红⿊树（红⿊树是⾮严格平衡的⼆叉搜索树，⽽AVL是严格平衡⼆叉搜索树），红⿊树有⾃动 排序的功能，因此map内部所有元素都是有序的，红⿊树的每⼀个节点都代表着map的⼀个元素。因此，对于map 进⾏的查找、删除、添加等⼀系列的操作都相当于是对红⿊树进⾏的操作。map中的元素是按照⼆叉树（⼜名⼆叉 查找树、⼆叉排序树）存储的，特点就是左⼦树上所有节点的键值都⼩于根节点的键值，右⼦树所有节点的键值都 ⼤于根节点的键值。使⽤中序遍历可将键值按照从⼩到⼤遍历出来。 </p><p>共同点： 都是C++的关联容器,只是通过它提供的接⼝对⾥⾯的元素进⾏访问，底层都是采⽤红⿊树实现。 </p><p> 不同点： set：⽤来判断某⼀个元素是不是在⼀个组⾥⾯。  </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>水下机器人岸基客户端开发</title>
    <link href="/2024/05/09/%E6%B0%B4%E4%B8%8B%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%B2%B8%E5%9F%BA%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    <url>/2024/05/09/%E6%B0%B4%E4%B8%8B%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%B2%B8%E5%9F%BA%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h1 id="水下机器人岸基客户端"><a href="#水下机器人岸基客户端" class="headerlink" title="水下机器人岸基客户端"></a>水下机器人岸基客户端</h1><p>背景概述：2023.7–2024.5 任职青岛澎湃海洋科技有限公司，软件开发工程师，负责水下机器人岸基客户端的开发与维护。</p><h2 id="1、项目概述与角色"><a href="#1、项目概述与角色" class="headerlink" title="1、项目概述与角色"></a>1、项目概述与角色</h2><p>（1）项目的背景和目标：公司主要经营自主式水下机器人（潜航器）的研发与生产，对于水下机器人的控制与监测需要一套岸基操作系统，开发和设计岸基操作软件的客户端，实现对水下机器人的远程控制与数据传输。</p><p>（2）我所担任的角色（我在项目中承担的任务）：作为项目的主要开发者与维护者，负责设计和实现岸基界面，使用C++和Qt框架，在linux环境下基于MOOS框架开发。设计、实现、优化岸基界面及其与水下机器人的人机交互。</p><h2 id="2、技术栈与工具"><a href="#2、技术栈与工具" class="headerlink" title="2、技术栈与工具"></a>2、技术栈与工具</h2><p>所用技术与工具：C++、Qt、Mysql、网络编程、多线程、Linux、MOSS框架</p><p>C++用于实现项目的核心功能，包括数据处理、通信模块以及控制逻辑等。Qt作为界面开发的主要工具，能够支持创建直观、清晰快速响应的岸基界面，提供丰富的用户交互体验。另外，Qt的跨平台移植能力较强，适用于各种操作系统。</p><p>公司研发的水下潜航器是基于MOOS框架搭建的，MOOS为水下机器人系统提供了必要的通信和数据处理能力，其中MOOSDB提供了消息的订阅与转发机制，通过岸基界面与MOOSDB进行数据通信与交互，从而实现岸基客户端与水下机器人的数据交换和控制指令的发送。</p><h2 id="3、项目过程中遇到的挑战"><a href="#3、项目过程中遇到的挑战" class="headerlink" title="3、项目过程中遇到的挑战"></a>3、项目过程中遇到的挑战</h2><p>（持续优化，想到在写，结合实际情况具体阐述）</p><p>在项目开发过程中，我面临了多个挑战，其中一个主要挑战是处理实时数据和保证系统的稳定性。由于水下机器人的操作需要高度的准确性和实时性，我需要设计高效的数据处理算法，并优化系统的资源利用，以确保岸基客户端能够及时、准确地与水下机器人进行通信和控制。</p><p>另外，界面的设计和交互体验也是一个挑战，因为要考虑到操作人员在实际使用中的需求和习惯，我通过用户反馈和不断优化，逐步提升了岸基界面的易用性和效率。</p><p>地图功能的实现，地图选点、发送到地图等功能也可以结合HTML来描述。</p><p>在项目中，有一个挑战是确保岸基客户端与水下机器人之间稳定可靠的通信和数据交换。我通过深入学习MOOS框架和利用Qt的多线程技术，设计了可靠的数据传输机制，确保实时性和准确性。</p><h2 id="4、项目成果和贡献"><a href="#4、项目成果和贡献" class="headerlink" title="4、项目成果和贡献"></a>4、项目成果和贡献</h2><p>我的工作使得水下机器人岸基客户端功能更加完善和稳定，为水下机器人操作人员提供了便利和高效的使用环境。我设计和实现的岸基界面大大提升了操作员的操作体验，使得控制水下机器人变得更加直观和可靠。</p><p>另外，我还负责优化数据传输和处理流程，通过引入异步处理机制和内存管理技术，提高了系统的性能和稳定性，确保了水下机器人的实时响应和数据准确性。</p><p>这个项目使我能够深入理解水下机器人控制系统的开发和应用，通过开发岸基客户端，成功实现了对水下机器人的远程监控和控制。这种技术对于海洋科学研究和工业应用具有重要意义，为水下机器人的智能化控制提供了可行性和可靠性。</p><p>5、团队协作与沟通</p><p>在实际开发过程中，需要与水下机器人团队密切合作，与硬件工程师、算法工程师和控制组成员以及其他开发者共同商讨需求和解决方案。我们使用Git进行版本控制和团队协作，保证代码的一致性和可维护性。通过定期的沟通会议和协作工具，我能够及时了解用户需求，并将其转化为具体的界面设计和功能开发。公司搭建了服务器，可以将代码和相关程序部署到服务器，以便成员使用和访问。</p><h2 id="5、相关问题积累"><a href="#5、相关问题积累" class="headerlink" title="5、相关问题积累"></a>5、相关问题积累</h2><p>（1）在项目中使用的Qt框架是用来实现哪些功能的</p><p>Qt框架在项目中主要用于图形用户界面（GUI）开发，包括设计和实现岸基控制界面，显示水下机器人的状态和数据，以及与MOOS通信和数据交互。</p><p>（2）请介绍一下MOOS框架在你的项目中的作用和应用场景</p><p>MOOS是一种用于海洋操作的开源软件平台，我在项目中利用MOOS框架实现了与水下机器人的通信和数据交换。通过MOOS，岸基客户端可以发送控制指令和接收水下机器人的传感器数据，实现对机器人的监控和控制。</p><h2 id="遇到的问题："><a href="#遇到的问题：" class="headerlink" title="遇到的问题："></a>遇到的问题：</h2><p>最近在调整水下机器人内部架构，启用新架构实现AUV的控制。需要一版新的岸基界面提供控制与指令的下发。在此之前是由另一位员工开发的，实现了基本功能，代码实现方式比较复杂，结构相对混乱，还影响了现有的基本功能的实现，比如发送路径点到地图，从地图选点发送到文本框等。现在交由我负责相关功能的开发与实现，现在存在的问题是，他在航渡任务参数配置的构造函数中保存了路径点的信息，而创建航渡任务配置窗口的是在另一个类里构造的，为此，外界访问不到他保存的路径信息，也就无法获取到路径点以供外界访问和使用。基于路径点的地图相关功能目前无法实现，正在考虑如何解决。</p><p>解决方法：</p><p>我发现每个任务信息的发送功能都是正常的，因此，去探索发送任务信息的流程，发现了通过view视图，将新创建的窗口内容发送出去，供外界调用和访问，为此，可以模拟发送任务消息的形式实现发送路径点信息到地图。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">std::string <span class="hljs-title">WayPointView::getPointDate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>    QString way_points = <span class="hljs-built_in">QString</span>(<span class="hljs-string">&quot;;;points=&quot;</span>);<br>    <span class="hljs-type">int</span> waypoint_count = point_list_.point_list.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> current_waypoint_index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;waypoint : point_list_.point_list)<br>    &#123;<br>        way_points += <span class="hljs-built_in">QString</span>(<span class="hljs-string">&quot;%1,%2&quot;</span>).<span class="hljs-built_in">arg</span>(waypoint.second.longitude, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-number">6</span>).<span class="hljs-built_in">arg</span>(waypoint.second.latitude, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-number">6</span>);<br>        <span class="hljs-keyword">if</span> (++current_waypoint_index &lt; waypoint_count) &#123;<br>            way_points += <span class="hljs-string">&quot;:&quot;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> way_points.<span class="hljs-built_in">toStdString</span>()+ <span class="hljs-string">&quot;;&quot;</span>;<br>&#125;<span class="hljs-comment">// 获取路径点信息以供调用。</span><br><span class="hljs-function">std::string <span class="hljs-title">mission::sendWaypointsToMap</span><span class="hljs-params">(QTreeWidgetItem* item)</span></span><br><span class="hljs-function"></span>&#123;<br>    QWidget* way_widget;<br>    QWidget* traversal_widget;<br>    <span class="hljs-keyword">if</span> (!item)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;no points!&quot;</span>;<br>    QString point_str;<br>    <span class="hljs-keyword">auto</span> way_item = waypointLayout-&gt;<span class="hljs-built_in">itemAtPosition</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">auto</span> traversal_item = traversalLayout-&gt;<span class="hljs-built_in">itemAtPosition</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-type">bool</span> is_waypoint_;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; item-&gt;<span class="hljs-built_in">childCount</span>(); ++i) &#123;<br>        QTreeWidgetItem *childItem = item-&gt;<span class="hljs-built_in">child</span>(i);<br>        <span class="hljs-keyword">if</span> (childItem-&gt;<span class="hljs-built_in">text</span>(<span class="hljs-number">0</span>) == <span class="hljs-string">&quot;航渡平台参数配置&quot;</span>) &#123;<br>           is_waypoint_ = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(childItem-&gt;<span class="hljs-built_in">text</span>(<span class="hljs-number">0</span>) == <span class="hljs-string">&quot;遍历平台参数配置&quot;</span>)<br>        &#123;<br>            is_waypoint_ = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">break</span>;<br><br>        &#125; <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> point_str.<span class="hljs-built_in">toStdString</span>();<br>        &#125;<br>    &#125;<br>        <span class="hljs-keyword">if</span> (is_waypoint_)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!way_item)<br>        &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;sadfsad&quot;</span> &lt;&lt; std::endl;<br>            <span class="hljs-keyword">return</span> point_str.<span class="hljs-built_in">toStdString</span>();<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            way_widget = way_item-&gt;<span class="hljs-built_in">widget</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">qobject_cast</span>&lt;WayPointView*&gt;(way_widget)!= <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">auto</span> view =treeWidget-&gt;<span class="hljs-built_in">getViewMap</span>()[item-&gt;<span class="hljs-built_in">text</span>(<span class="hljs-number">0</span>)];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; item-&gt;<span class="hljs-built_in">childCount</span>(); ++i) &#123;<br>                QTreeWidgetItem *childItem = item-&gt;<span class="hljs-built_in">child</span>(i);<br>                <span class="hljs-keyword">if</span> (childItem-&gt;<span class="hljs-built_in">text</span>(<span class="hljs-number">0</span>) == <span class="hljs-string">&quot;航渡平台参数配置&quot;</span>) &#123;<br>                    <span class="hljs-keyword">auto</span> way_view = <span class="hljs-built_in">qobject_cast</span>&lt;WayPointView*&gt;(view);<br>                    point_str += way_view-&gt;<span class="hljs-built_in">getPointDate</span>().<span class="hljs-built_in">c_str</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( !is_waypoint_)&#123;<br><br>        <span class="hljs-keyword">if</span> (!traversal_item)<br>        &#123;<br>            <span class="hljs-keyword">return</span> point_str.<span class="hljs-built_in">toStdString</span>();<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            traversal_widget = traversal_item-&gt;<span class="hljs-built_in">widget</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">qobject_cast</span>&lt;TraversalView*&gt;(traversal_widget)!= <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">auto</span> view =treeWidget-&gt;<span class="hljs-built_in">getViewMap</span>()[item-&gt;<span class="hljs-built_in">text</span>(<span class="hljs-number">0</span>)];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; item-&gt;<span class="hljs-built_in">childCount</span>(); ++i) &#123;<br>                QTreeWidgetItem *childItem = item-&gt;<span class="hljs-built_in">child</span>(i);<br>                <span class="hljs-keyword">if</span> (childItem-&gt;<span class="hljs-built_in">text</span>(<span class="hljs-number">0</span>) == <span class="hljs-string">&quot;遍历平台参数配置&quot;</span>) &#123;<br>                    <span class="hljs-keyword">auto</span> way_view = <span class="hljs-built_in">qobject_cast</span>&lt;TraversalView*&gt;(view);<br>                    point_str += way_view-&gt;<span class="hljs-built_in">getStrData</span>().<span class="hljs-built_in">c_str</span>() + <span class="hljs-built_in">QString</span>(<span class="hljs-string">&quot;;&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> point_str.<span class="hljs-built_in">toStdString</span>();<br>&#125;<span class="hljs-comment">// 外界整合路径点信息</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mission::sendTomapClicked</span><span class="hljs-params">(QTreeWidgetItem* item)</span><span class="hljs-comment">// 0514 byz ds</span></span><br><span class="hljs-function"></span>&#123;<br>    QMessageBox::StandardButton reply;<br>    reply = QMessageBox::<span class="hljs-built_in">question</span>(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">tr</span>( <span class="hljs-string">&quot;是否发送到地图&quot;</span> ),  <span class="hljs-built_in">tr</span>( <span class="hljs-string">&quot;确认发送&quot;</span> ),<br>                                    QMessageBox::Yes | QMessageBox::No );<br>    <span class="hljs-keyword">if</span>( reply == QMessageBox::Yes )<br>    &#123;<br>        sendToMap = <span class="hljs-literal">true</span>;<br>        <span class="hljs-function">emit <span class="hljs-title">snedPointparameter</span><span class="hljs-params">(sendWaypointsToMap(item))</span></span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( reply == QMessageBox::No )<br>    &#123;<br>        sendToMap = <span class="hljs-literal">false</span>;<br>    &#125; <br>&#125;<span class="hljs-comment">// 发送到地图槽函数</span><br><span class="hljs-built_in">connect</span>(treeWidget,&amp;TaskTreeWidget::send_to_map, <span class="hljs-keyword">this</span>, &amp;mission::sendTomapClicked);<span class="hljs-comment">//触发信号</span><br></code></pre></td></tr></table></figure><p>实现了发送路径点到地图功能后，还需要实现地图选点功能，即从地图上标记好路径点之后，点击确认选点会将路径点信息填充到表格中。同样存在操作不同实例化对象的问题，为此，我将每次创建新窗口时新建的实例化对象通过信号与槽的机制将其传出来，在外面定义一个实例化对象接收，确保我操作的路径点表格是当前创建窗口的。</p><p>首先，定义操作路径点窗口信息的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WayPointView::getPointFromMap</span><span class="hljs-params">(std::string points)</span></span>&#123;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt;<span class="hljs-string">&quot;获取航渡点&quot;</span> &lt;&lt;QString::<span class="hljs-built_in">fromStdString</span>(points) &lt;&lt; endl;<br>    QStringList pointList = QString::<span class="hljs-built_in">fromStdString</span>(points).<span class="hljs-built_in">split</span>(<span class="hljs-string">&#x27;:&#x27;</span>);<br>    <span class="hljs-comment">// 获取路径点数目，最多处理表格行数</span><br>    <span class="hljs-type">int</span> numPoints = std::<span class="hljs-built_in">min</span>(pointList.<span class="hljs-built_in">size</span>(), model_-&gt;<span class="hljs-built_in">rowCount</span>());<br>    <span class="hljs-comment">// 填充经纬度信息到表格中</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numPoints; ++i) &#123;<br>        QStringList lngLat = pointList[i].<span class="hljs-built_in">split</span>(<span class="hljs-string">&#x27;,&#x27;</span>);<br>        <span class="hljs-keyword">if</span> (lngLat.<span class="hljs-built_in">size</span>() &gt;= <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-comment">// 设置经度和纬度到对应的单元格中</span><br>            QString longitude = QString::<span class="hljs-built_in">number</span>(lngLat[<span class="hljs-number">0</span>].<span class="hljs-built_in">toFloat</span>(), <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-number">6</span>);<br>            QString latitude = QString::<span class="hljs-built_in">number</span>(lngLat[<span class="hljs-number">1</span>].<span class="hljs-built_in">toFloat</span>(), <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-number">6</span>);<br>            model_-&gt;<span class="hljs-built_in">setData</span>(model_-&gt;<span class="hljs-built_in">index</span>(i, <span class="hljs-number">0</span>), longitude); <span class="hljs-comment">// 经度</span><br>            model_-&gt;<span class="hljs-built_in">setData</span>(model_-&gt;<span class="hljs-built_in">index</span>(i, <span class="hljs-number">1</span>), latitude); <span class="hljs-comment">// 纬度</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在mission类里定义全局的waypointview的对象WayPointView* way_View; 用来接收传出来的实例化对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TaskTreeWidget::addFerryPlatform</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; current_item_-&gt;<span class="hljs-built_in">childCount</span>(); ++i) &#123;<br>        QTreeWidgetItem *childItem = current_item_-&gt;<span class="hljs-built_in">child</span>(i);<br>        <span class="hljs-keyword">if</span> (childItem-&gt;<span class="hljs-built_in">text</span>(<span class="hljs-number">0</span>) == <span class="hljs-string">&quot;航渡平台参数配置&quot;</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">auto</span> ferry_item = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QTreeWidgetItem</span>(current_item_);<br>    ferry_item-&gt;<span class="hljs-built_in">setText</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;航渡平台参数配置&quot;</span>);<br>    ferry_item-&gt;<span class="hljs-built_in">setData</span>(<span class="hljs-number">0</span>, Qt::UserRole, <span class="hljs-number">0</span>);<br>    current_item_-&gt;<span class="hljs-built_in">addChild</span>(ferry_item);<br>    current_item_-&gt;<span class="hljs-built_in">setExpanded</span>(<span class="hljs-literal">true</span>);<br><br>    <span class="hljs-keyword">auto</span> way_point_view = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WayPointView</span>();<br>    ViewMap.<span class="hljs-built_in">insert</span>(current_item_-&gt;<span class="hljs-built_in">text</span>(<span class="hljs-number">0</span>), way_point_view);<span class="hljs-comment">// 0515 by</span><br>    <span class="hljs-function">emit <span class="hljs-title">showFerryPlatformConfig</span><span class="hljs-params">(way_point_view)</span></span>;<br>    <span class="hljs-function">emit <span class="hljs-title">getcurrentwaypointview</span><span class="hljs-params">(way_point_view)</span></span>;<br>&#125;<span class="hljs-comment">// 创建窗口时就将实例化对象通过信号传出去</span><br><br><span class="hljs-built_in">connect</span>(treeWidget, &amp;TaskTreeWidget::getcurrentwaypointview, <span class="hljs-keyword">this</span>, &amp;mission::getCurrentWayView);<br><span class="hljs-comment">//信号与槽机制，收到传出的信号，将实例化对象传给way_View</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mission::getCurrentWayView</span><span class="hljs-params">(WayPointView* view)</span></span>&#123;<br>    way_View = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WayPointView</span>(<span class="hljs-keyword">this</span>);<br>    way_View= view;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;获取新窗口的view&quot;</span> &lt;&lt; endl;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>通过上述操作，我们就获取到了需要操作的实例化对象，通过这个对象去调用相关的成员函数，实现地图选点功能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mission::getpointsfromMap</span><span class="hljs-params">(std::string points)</span></span>&#123;<span class="hljs-comment">// 0515 by zds</span><br><br>    <span class="hljs-keyword">if</span> (way_View) &#123;<br>        <span class="hljs-comment">// 调用 WayPointView 的 getPointFromMap 方法</span><br>        way_View-&gt;<span class="hljs-built_in">getPointFromMap</span>(points);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 处理转换失败的情况</span><br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;Failed to cast view to WayPointView&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">// 输出调试信息</span><br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;地图选点功能测试: &quot;</span> &lt;&lt; QString::<span class="hljs-built_in">fromStdString</span>(points);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>demo</title>
    <link href="/2024/05/08/Git%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/05/08/Git%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>1、熟悉git的相关命令<br>操作类似于Linux相关指令，通过git init 将创建好的文件夹变成git可以管理的仓库（版本库）<br>git add readme.txt 添加文件到暂存区<br>git commit 将文件提交到仓库（-m可以添加备注）<br>git status 查看文件提交状态<br>git diff rademe.txt 查看文件修改了什么内容<br>git log 查看历史记录<br>git reset -hard HEAD^ 版本回退<br>git reflog 获取所有记录的版本号<br>git reset -hard 版本号，恢复指定版本<br>git restore– readme.txt 撤销未提交的工作（– 很重要！）<br>git push origin master 本地代码推送到github上<br>git checkout -b dev 创建并切换到该分支&#x3D;&#x3D;git branh dev + git<br>checkout dev<br>git branch 查看分支<br>git branch -d dev 删除分支dev<br>2、github远程仓库搭建<br>ssh加密同步方式</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>张登胜的博客</title>
    <link href="/2024/05/08/%E5%BC%A0%E7%99%BB%E8%83%9C%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <url>/2024/05/08/%E5%BC%A0%E7%99%BB%E8%83%9C%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>这是我的个人博客，欢迎大家访问！</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>

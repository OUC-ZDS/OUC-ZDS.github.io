<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>算法刷题</title>
    <link href="/2024/05/21/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    <url>/2024/05/21/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="单调栈刷题总结"><a href="#单调栈刷题总结" class="headerlink" title="单调栈刷题总结"></a>单调栈刷题总结</h1><h2 id="1、力扣题目"><a href="#1、力扣题目" class="headerlink" title="1、力扣题目"></a>1、力扣题目</h2><p>（每日温度）<a href="https://leetcode.cn/problems/daily-temperatures/">https://leetcode.cn/problems/daily-temperatures/</a></p><p>（下一个更大元素|）<a href="https://leetcode.cn/problems/next-greater-element-i/">https://leetcode.cn/problems/next-greater-element-i/</a></p><p>（下一个更大元素||）<a href="https://leetcode.cn/problems/next-greater-element-ii/">https://leetcode.cn/problems/next-greater-element-ii/</a></p><p>（接雨水）<a href="https://leetcode.cn/problems/trapping-rain-water/">https://leetcode.cn/problems/trapping-rain-water/</a></p><p>（最大矩形面积）<a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">https://leetcode.cn/problems/largest-rectangle-in-histogram/</a></p><h2 id="2、学习笔记"><a href="#2、学习笔记" class="headerlink" title="2、学习笔记"></a>2、学习笔记</h2><p>（1）什么是单调栈：利用一维数组模拟栈，按照从大到小或者从小到大的顺序，去记录遍历过的元素或者元素下标，利用空间换取时间的一种方式。</p><p>（2）什么时候适用单调栈解题：当需要寻找一个元素的左边或者右边第一个比自己大或者小的元素的时候，可以考虑使用单调栈。</p><p>（3）在使用单调栈的时候首先要明确如下几点：</p><ol><li>单调栈里存放的元素是什么？</li></ol><p>单调栈里只需要存放元素的下标i就可以了，如果需要使用对应的元素，直接T[i]就可以获取。</p><ol><li>单调栈里元素是递增呢？ 还是递减呢？</li></ol><p><strong>注意以下讲解中，顺序的描述为 从栈头到栈底的顺序</strong>，因为单纯的说从左到右或者从前到后，不说栈头朝哪个方向的话，大家一定比较懵。</p><p>这里我们要使用递增循序（再强调一下是指从栈头到栈底的顺序），因为只有递增的时候，栈里要加入一个元素i的时候，才知道栈顶元素在数组中右面第一个比栈顶元素大的元素是i。</p><p>即：如果求一个元素右边第一个更大元素，单调栈就是递增的，如果求一个元素右边第一个更小元素，单调栈就是递减的。</p><p>（4）使用单调栈主要有三个判断条件：</p><ul><li>当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况</li><li>当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况</li><li>当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况</li></ul><h2 id="3、刷题总结"><a href="#3、刷题总结" class="headerlink" title="3、刷题总结"></a>3、刷题总结</h2><h3 id="（1）每日温度："><a href="#（1）每日温度：" class="headerlink" title="（1）每日温度："></a>（1）每日温度：</h3><p>理清楚单调栈在递增情况下，三个判断条件对应的处理逻辑，本题求的是下一个比自己高的元素距离自己的距离，所以在收集结果的时候统计的是下标之间的差值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; T)</span> </span>&#123;<br>        <span class="hljs-comment">// 递增栈</span><br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(T.size(), <span class="hljs-number">0</span>)</span></span>;<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; T.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (T[i] &lt; T[st.<span class="hljs-built_in">top</span>()]) &#123;                       <span class="hljs-comment">// 情况一</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (T[i] == T[st.<span class="hljs-built_in">top</span>()]) &#123;               <span class="hljs-comment">// 情况二</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; T[i] &gt; T[st.<span class="hljs-built_in">top</span>()]) &#123; <span class="hljs-comment">// 情况三 收集结果是两个元素之间的距离</span><br>                    result[st.<span class="hljs-built_in">top</span>()] = i - st.<span class="hljs-built_in">top</span>();<br>                    st.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="（2）下一个更大元素-："><a href="#（2）下一个更大元素-：" class="headerlink" title="（2）下一个更大元素|："></a>（2）下一个更大元素|：</h3><p>相较于上面一道题目，讨论一个外壳，其本质还是单调栈的思路。不同的是，需要在nums2中找nums1中的元素的下一个比它大的值，可以看出顺序还是从小到大的单调栈。但是需要map做映射，方便判断nums2[i]是否在nums1中出现过。C++中，当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的。</p><p>接下来就要分析如下三种情况：</p><ol><li>情况一：当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况</li></ol><p>此时满足递增栈（栈头到栈底的顺序），所以直接入栈。</p><ol><li>情况二：当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况</li></ol><p>如果相等的话，依然直接入栈，因为我们要求的是右边第一个比自己大的元素，而不是大于等于！</p><ol><li>情况三：当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况</li></ol><p>此时如果入栈就不满足递增栈了，这也是找到右边第一个比自己大的元素的时候。</p><p>判断栈顶元素是否在nums1里出现过，（注意栈里的元素是nums2的元素），如果出现过，开始记录结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(nums1.size(), <span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-keyword">if</span> (nums1.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result;<br><br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; umap; <span class="hljs-comment">// key:下标元素，value：下标</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums1.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            umap[nums1[i]] = i;<br>        &#125;<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums2.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums2[i] &lt; nums2[st.<span class="hljs-built_in">top</span>()]) &#123;           <span class="hljs-comment">// 情况一</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums2[i] == nums2[st.<span class="hljs-built_in">top</span>()]) &#123;   <span class="hljs-comment">// 情况二</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">else</span> &#123;                                    <span class="hljs-comment">// 情况三</span><br>                <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; nums2[i] &gt; nums2[st.<span class="hljs-built_in">top</span>()]) &#123;<br>                    <span class="hljs-keyword">if</span> (umap.<span class="hljs-built_in">count</span>(nums2[st.<span class="hljs-built_in">top</span>()]) &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 看map里是否存在这个元素</span><br>                        <span class="hljs-type">int</span> index = umap[nums2[st.<span class="hljs-built_in">top</span>()]]; <span class="hljs-comment">// 根据map找到nums2[st.top()] 在 nums1中的下标。记录结果这块逻辑有一点小绕，要清楚，此时栈顶元素在nums2数组中右面第一个大的元素是nums2[i]（即当前遍历元素</span><br>                        result[index] = nums2[i];<br>                    &#125;<br>                    st.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="（3）下一个更大元素"><a href="#（3）下一个更大元素" class="headerlink" title="（3）下一个更大元素||"></a>（3）下一个更大元素||</h3><p>对比上一题，数组变成环形了，需要模拟走了两边数组来解题，（1 2  1 1 2 1）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElements</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(nums.size(), <span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>() * <span class="hljs-number">2</span>; i++) &#123; <br>            <span class="hljs-comment">// 模拟遍历两边nums，注意一下都是用i % nums.size()来操作 防止遍历越界</span><br>            <span class="hljs-keyword">if</span> (nums[i % nums.<span class="hljs-built_in">size</span>()] &lt; nums[st.<span class="hljs-built_in">top</span>()]) st.<span class="hljs-built_in">push</span>(i % nums.<span class="hljs-built_in">size</span>());<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i % nums.<span class="hljs-built_in">size</span>()] == nums[st.<span class="hljs-built_in">top</span>()]) st.<span class="hljs-built_in">push</span>(i % nums.<span class="hljs-built_in">size</span>()); <br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i % nums.<span class="hljs-built_in">size</span>()] &gt; nums[st.<span class="hljs-built_in">top</span>()]) &#123;<br>                    result[st.<span class="hljs-built_in">top</span>()] = nums[i % nums.<span class="hljs-built_in">size</span>()];<br>                    st.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>                st.<span class="hljs-built_in">push</span>(i % nums.<span class="hljs-built_in">size</span>());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="（4）接雨水"><a href="#（4）接雨水" class="headerlink" title="（4）接雨水"></a>（4）接雨水</h3><img src="C:\Users\zhangdengsheng\AppData\Roaming\Typora\typora-user-images\image-20240509151300969.png" style="zoom:50%;" /><p>处理逻辑同单调栈的从小到大顺序相同，在收获结果的时候，要注意计算方式。</p><p>当当前元素大于栈顶元素了，取栈顶元素，将栈顶元素弹出，这个就是凹槽的底部，也就是中间位置，下标记为mid，对应的高度为height[mid]。</p><p>此时的栈顶元素st.top()，就是凹槽的左边位置，下标为st.top()，对应的高度为height[st.top()]。</p><p>当前遍历的元素i，就是凹槽右边的位置，下标为i，对应的高度为height[i]。</p><p>此时大家应该可以发现其实就是<strong>栈顶和栈顶的下一个元素以及要入栈的元素，三个元素来接水！</strong></p><p>那么雨水高度是 min(凹槽左边高度, 凹槽右边高度) - 凹槽底部高度，代码为：<code>int h = min(height[st.top()], height[i]) - height[mid];</code></p><p>雨水的宽度是 凹槽右边的下标 - 凹槽左边的下标 - 1（因为只求中间宽度），代码为：<code>int w = i - st.top() - 1 ;</code></p><p>当前凹槽雨水的体积就是：<code>h * w</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (height.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 可以不加</span><br>        stack&lt;<span class="hljs-type">int</span>&gt; st; <span class="hljs-comment">// 存着下标，计算的时候用下标对应的柱子高度</span><br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; height.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (height[i] &lt; height[st.<span class="hljs-built_in">top</span>()]) &#123;     <span class="hljs-comment">// 情况一</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">if</span> (height[i] == height[st.<span class="hljs-built_in">top</span>()]) &#123;  <span class="hljs-comment">// 情况二</span><br>                st.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 其实这一句可以不加，效果是一样的，但处理相同的情况的思路却变了。</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">else</span> &#123;                                <span class="hljs-comment">// 情况三</span><br>                <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; height[i] &gt; height[st.<span class="hljs-built_in">top</span>()]) &#123; <span class="hljs-comment">// 注意这里是while</span><br>                    <span class="hljs-type">int</span> mid = st.<span class="hljs-built_in">top</span>();<br>                    st.<span class="hljs-built_in">pop</span>();<br>                    <span class="hljs-keyword">if</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>                        <span class="hljs-type">int</span> h = <span class="hljs-built_in">min</span>(height[st.<span class="hljs-built_in">top</span>()], height[i]) - height[mid];<br>                        <span class="hljs-type">int</span> w = i - st.<span class="hljs-built_in">top</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意减一，只求中间宽度</span><br>                        sum += h * w;<br>                    &#125;<br>                &#125;<br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="（5）矩形柱子的最大面积"><a href="#（5）矩形柱子的最大面积" class="headerlink" title="（5）矩形柱子的最大面积"></a>（5）矩形柱子的最大面积</h3><p>本题将单调栈的顺序变成了从大到小，处理逻辑也要取反。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; heights)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        heights.<span class="hljs-built_in">insert</span>(heights.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">0</span>); <span class="hljs-comment">// 数组头部加入元素0</span><br>        heights.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 数组尾部加入元素0</span><br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">// 第一个元素已经入栈，从下标1开始</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; heights.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (heights[i] &gt; heights[st.<span class="hljs-built_in">top</span>()]) &#123; <span class="hljs-comment">// 情况一</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (heights[i] == heights[st.<span class="hljs-built_in">top</span>()]) &#123; <span class="hljs-comment">// 情况二</span><br>                st.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 这个可以加，可以不加，效果一样，思路不同</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 情况三</span><br>                <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; heights[i] &lt; heights[st.<span class="hljs-built_in">top</span>()]) &#123; <span class="hljs-comment">// 注意是while</span><br>                    <span class="hljs-type">int</span> mid = st.<span class="hljs-built_in">top</span>();<br>                    st.<span class="hljs-built_in">pop</span>();<br>                    <span class="hljs-keyword">if</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>                        <span class="hljs-type">int</span> left = st.<span class="hljs-built_in">top</span>();<br>                        <span class="hljs-type">int</span> right = i;<br>                        <span class="hljs-type">int</span> w = right - left - <span class="hljs-number">1</span>;<br>                        <span class="hljs-type">int</span> h = heights[mid];<br>                        result = <span class="hljs-built_in">max</span>(result, w * h);<br>                    &#125;<br>                &#125;<br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="动态规划刷题总结"><a href="#动态规划刷题总结" class="headerlink" title="动态规划刷题总结"></a>动态规划刷题总结</h1><p>DP（动态规划）当前状态是由上一时刻的状态推导而来的。</p><p>动态规划五部曲：</p><p>1、确定dp数组以及其下标的含义</p><p>2、确定递推公式（状态转移公式）</p><p>3、dp数组如何初始化</p><p>4、确定遍历顺序</p><p>5、打印出dp数组，判断问题出在哪。</p><h2 id="1、斐波那契数列"><a href="#1、斐波那契数列" class="headerlink" title="1、斐波那契数列"></a>1、斐波那契数列</h2><p><a href="https://leetcode.cn/problems/fibonacci-number/">https://leetcode.cn/problems/fibonacci-number/</a></p><p>入门级别的动态规划，重点在于动态规划五部曲的使用，方法论的实现。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">// 方法一：动规五部曲</span><br>    <span class="hljs-comment">//     if(n &lt;= 1) return n;</span><br>    <span class="hljs-comment">//     vector&lt;int&gt; dp(n+1);// 1、确定dp数组即下标含义：下标为i的元素的斐波那契数列的值</span><br>    <span class="hljs-comment">//     dp[0] = 0;</span><br>    <span class="hljs-comment">//     dp[1] = 1; // 3、dp数组初始化</span><br>    <span class="hljs-comment">//     for(int i=2;i&lt;=n;i++)&#123;// 4、确定遍历顺序</span><br>    <span class="hljs-comment">//         dp[i] = dp[i-1] + dp[i-2];// 2、确定递推公式</span><br>    <span class="hljs-comment">//     &#125;</span><br>    <span class="hljs-comment">//     return dp[n];</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// 方法二：用两个数组维护就可以实现，节约空间</span><br>    <span class="hljs-keyword">if</span>(n &lt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;<br>    <span class="hljs-type">int</span> dp[<span class="hljs-number">2</span>];<span class="hljs-comment">// 确定dp数组</span><br>    dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    dp[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-comment">//dp数组初始化</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-type">int</span> sum = dp[<span class="hljs-number">0</span>]+dp[<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>]= dp[<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">1</span>]=sum; <span class="hljs-comment">// 变相实现递推公式：dp[i] = dp[i-1]+dp[i-2];</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、爬楼梯"><a href="#2、爬楼梯" class="headerlink" title="2、爬楼梯"></a>2、爬楼梯</h2><p><a href="https://leetcode.cn/problems/climbing-stairs/">https://leetcode.cn/problems/climbing-stairs/</a></p><p>动规五部曲：</p><p>定义一个一维数组来记录不同楼层的状态</p><p>1、确定dp数组以及下标的含义</p><p>dp[i]： <strong>爬到第i层楼梯，有dp[i]种方法</strong></p><p>2、确定递推公式</p><p>如何可以推出dp[i]呢？</p><p>从dp[i]的定义可以看出，dp[i] 可以有两个方向推出来。</p><p>首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。（题目中可以每次只跳一步）</p><p>还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么。（题目中可以每次跳两步）</p><p>那么dp[i]就是 dp[i - 1]与dp[i - 2]之和！</p><p>所以dp[i] &#x3D; dp[i - 1] + dp[i - 2] 。</p><p>在推导dp[i]的时候，一定要时刻想着dp[i]的定义，否则容易跑偏。这体现出确定dp数组以及下标的含义的重要性！</p><p>3、dp数组的初始化</p><p>本题中n是正整数，所以不用去定义dp[0]的含义，我们可以直接从dp[1]开始定义</p><p>那么初始化dp[1]&#x3D;1,dp[2]&#x3D;2;遍历的时候从3开始即可。</p><p>PS dp[0]&#x3D;1认为什么都不干也是一种方法。</p><p>4、确定遍历顺序</p><p>由递推公式可以看出遍历顺序一定是从前往后</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n; <span class="hljs-comment">// 因为下面直接对dp[2]操作了，防止空指针</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-comment">// dp数组</span><br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;/ dp数组初始化<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++) &#123; <span class="hljs-comment">// 注意i是从3开始的 ，遍历顺序</span><br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<span class="hljs-comment">// 递推公式</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>爬楼梯拓展</strong>：如果每次你可以爬至多m (1 &lt;&#x3D; m &lt; n)个台阶。你有多少种不同的方法可以爬到楼顶呢？–变成一个完全背包问题了。1阶，2阶，…. m阶就是物品，楼顶就是背包。每一阶可以重复使用，例如跳了1阶，还可以继续跳1阶。问跳到楼顶有几种方法其实就是问装满背包有几种方法。（求排列数）</p><p>1、确定dp数组以及下标的含义</p><p><strong>dp[i]：爬到有i个台阶的楼顶，有dp[i]种方法</strong>。</p><p>2、确定递推公式</p><p>本题呢，dp[i]有几种来源，dp[i - 1]，dp[i - 2]，dp[i - 3] 等等，即：dp[i - j]那么递推公式为：dp[i] +&#x3D; dp[i - j]</p><p>3、dp数组如何初始化</p><p>既然递归公式是 dp[i] +&#x3D; dp[i - j]，那么dp[0] 一定为1，dp[0]是递归中一切数值的基础所在，如果dp[0]是0的话，其他数值都是0了。下标非0的dp[i]初始化为0，因为dp[i]是靠dp[i-j]累计上来的，dp[i]本身为0这样才不会影响结果</p><p>4、确定遍历顺序</p><p>这是背包里求排列问题，即：<strong>1、2 步 和 2、1 步都是上三个台阶，但是这两种方法不一样！</strong>所以需将target放在外循环，将nums放在内循环。每一步可以走多次，这是完全背包，内循环需要从前向后遍历。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<span class="hljs-comment">// 1、确定dp数组</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<span class="hljs-comment">// 3、dp数组初始化，装满容量为0的背包由1种方法（什么都不放）</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-comment">//4、确定遍历顺序，因为求的是排列数（1、2和2,1是两种方法）外层循环遍历背包，内层遍历物品，且从前向后遍历，确保物品可以重复选取</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123; <br>                <span class="hljs-keyword">if</span> (i - j &gt;= <span class="hljs-number">0</span>) dp[i] += dp[i - j];<span class="hljs-comment">// 2、确定递推公式</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="3、使用最小花费爬楼梯"><a href="#3、使用最小花费爬楼梯" class="headerlink" title="3、使用最小花费爬楼梯"></a>3、使用最小花费爬楼梯</h2><p><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">https://leetcode.cn/problems/min-cost-climbing-stairs/</a></p><p>1、确定dp数组以及下标的含义</p><p>**dp[i]的定义：到达第i台阶所花费的最少体力为dp[i]**。</p><p>2、确定递推公式</p><p>**可以有两个途径得到dp[i]，一个是dp[i-1] 一个是dp[i-2]**。</p><p>dp[i - 1] 跳到 dp[i] 需要花费 dp[i - 1] + cost[i - 1]。</p><p>dp[i - 2] 跳到 dp[i] 需要花费 dp[i - 2] + cost[i - 2]。</p><p>那么究竟是选从dp[i - 1]跳还是从dp[i - 2]跳呢？</p><p>一定是选最小的，所以dp[i] &#x3D; min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);</p><p>3、dp数组如何初始化</p><p>根据dp数组的定义，到达第0台阶所花费的最小体力为dp[0]，那么有同学可能想，那dp[0] 应该是 cost[0]，例如 cost &#x3D; [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] 的话，dp[0] 就是 cost[0] 应该是1。</p><p>题目描述中明确说了 “你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。” 也就是说 到达 第 0 个台阶是不花费的，但从 第0 个台阶 往上跳的话，需要花费 cost[0]。</p><p>所以初始化 dp[0] &#x3D; 0，dp[1] &#x3D; 0;</p><p>4、确定遍历顺序</p><p>因为是模拟台阶，而且dp[i]由dp[i-1]dp[i-2]推出，所以是从前到后遍历cost数组就可以。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(cost.size() + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 默认第一步都是不花费体力的</span><br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= cost.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            dp[i] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>] + cost[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + cost[i - <span class="hljs-number">2</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[cost.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="4、不同路径"><a href="#4、不同路径" class="headerlink" title="4、不同路径"></a>4、不同路径</h2><p><a href="https://leetcode.cn/problems/unique-paths/">https://leetcode.cn/problems/unique-paths/</a></p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<span class="hljs-comment">// 1、[i][j]的定义：从（0,0）到（n-1，m-1）有dp[i][j]种方法</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<span class="hljs-comment">// 建立dp数组（二维数组的定义）</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<span class="hljs-comment">// 3、dp数组初始化（横着走、竖着走只有一种方法）</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<span class="hljs-comment">// 4、遍历顺序，从左往右依次遍历即可</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<span class="hljs-comment">// 2、递推公式</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="5、不同路径"><a href="#5、不同路径" class="headerlink" title="5、不同路径||"></a>5、不同路径||</h2><p>如果路径上有了障碍物，如何计算有几种方式到达目标位置呢？</p><p>如果遇到障碍，其实就把对应的dp数组置为0就可以了（这条路径上有障碍，就到不了目的地了）。</p><p>所以，当（i，j）位置有障碍物，dp数组要重置为0，所以初始化的部分要考虑障碍物情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n &amp;&amp; obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>; j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<span class="hljs-comment">// 数组初始化</span><br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;<span class="hljs-comment">// 带障碍物的网格</span><br>        <span class="hljs-type">int</span> m = obstacleGrid.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//行数</span><br>        <span class="hljs-type">int</span> n = obstacleGrid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<span class="hljs-comment">//列数</span><br><span class="hljs-keyword">if</span> (obstacleGrid[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span> || obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) <span class="hljs-comment">//如果在起点或终点出现了障碍，直接返回0</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<span class="hljs-comment">// 定义dp数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n &amp;&amp; obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>; j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<span class="hljs-comment">// 初始化</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<span class="hljs-comment">//初始化的部分，很容易忽略了障碍之后应该都是0的情况。</span><br></code></pre></td></tr></table></figure><h2 id="6、背包理论基础1"><a href="#6、背包理论基础1" class="headerlink" title="6、背包理论基础1"></a>6、背包理论基础1</h2><p>1、01背包</p><p>有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p>（1）确定dp数组及其含义</p><p>第一种写法， 是使用二维数组，即dp[i] [j]表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。</p><p>（2）确定递推公式</p><p>dp[i] [j]可以由两种方式推导出来：</p><ul><li><p>不放物品：由dp[i-1] [j]表示，背包容量为j，不放物品的最大价值，则dp[i-1] [j] &#x3D; dp[i] [j]（物品重量大于背包容量）包里不放物品时候的价值</p></li><li><p>放物品：由dp[i-1] [j-weight]表示，背包容量为j-weight，不放物品的最大价值，则dp[i] [j] &#x3D; dp[i-1] [j-weight] + value[i]</p></li></ul><p>则递推公式为 dp[i] [j] &#x3D; max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]);</p><p>（3）dp数组的初始化</p><p>首先从dp[i] [j]的定义出发，如果背包容量j为0的话，即dp[i] [0]，无论是选取哪些物品，背包价值总和一定为0；</p><p>由状态转移方程 dp[i] [j] &#x3D; max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]); 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。</p><p>dp[0] [j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。那么很明显当 j &lt; weight[0]的时候，dp[0] [j] 应该是 0，因为背包容量比编号0的物品重量还小。当j &gt;&#x3D; weight[0]时，dp[0] [j] 应该是value[0]，因为背包容量放足够放编号0物品。</p><p>dp[0] [j] 和 dp[i] [0] 都已经初始化了，那么其他下标应该初始化多少呢？</p><p>其实从递归公式： dp[i] [ j] &#x3D; max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]); 可以看出dp[i] [j] 是由左上方数值推导出来了，那么 其他下标初始为什么数值都可以，因为都会被覆盖。</p><p>（4）确定遍历顺序</p><p>对于二维数组的01背包问题，先遍历物品再遍历背包和先遍历背包再遍历物品都可以。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//二维dp数组实现</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, bagweight;<span class="hljs-comment">// bagweight代表行李箱空间</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">weight</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 存储每件物品所占空间</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">value</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;  <span class="hljs-comment">// 存储每件物品价值</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        cin &gt;&gt; weight[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>        cin &gt;&gt; value[j];<br>    &#125;<br>    <span class="hljs-comment">// dp数组, dp[i][j]代表行李箱空间为j的情况下,从下标为[0, i]的物品里面任意取,能达到的最大价值</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(weight.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(bagweight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><br>    <span class="hljs-comment">// 初始化, 因为需要用到dp[i - 1]的值</span><br>    <span class="hljs-comment">// j &lt; weight[0]已在上方被初始化为0</span><br>    <span class="hljs-comment">// j &gt;= weight[0]的值就初始化为value[0]</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = weight[<span class="hljs-number">0</span>]; j &lt;= bagweight; j++) &#123;<br>        dp[<span class="hljs-number">0</span>][j] = value[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历科研物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagweight; j++) &#123; <span class="hljs-comment">// 遍历行李箱容量</span><br>            <span class="hljs-comment">// 如果装不下这个物品,那么就继承dp[i - 1][j]的值</span><br>            <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>            <span class="hljs-comment">// 如果能装下,就将值更新为 不装这个物品的最大值 和 装这个物品的最大值 中的 最大值</span><br>            <span class="hljs-comment">// 装这个物品的最大值由容量为j - weight[i]的包任意放入序号为[0, i - 1]的最大值 + 该物品的价值构成</span><br>            <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; dp[weight.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][bagweight] &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; n &gt;&gt; bagweight) &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7、背包理论基础2"><a href="#7、背包理论基础2" class="headerlink" title="7、背包理论基础2"></a>7、背包理论基础2</h2><p>考虑用一维数组（滚动数组的形式）</p><p>1、确定dp数组的定义</p><p>在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。</p><p>2、一维dp数组的递推公式</p><p>dp[j]为 容量为j的背包所背的最大价值，那么如何推导dp[j]呢？</p><p>dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。</p><p>dp[j - weight[i]] + value[i] 表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）</p><p>此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1] [j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值，</p><p>所以递归公式为：dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);</p><p>3、dp数组的初始化</p><p><strong>关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱</strong>。</p><p>dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。</p><p>那么dp数组除了下标0的位置，初始为0，其他下标应该初始化多少呢？</p><p>看一下递归公式：dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);</p><p>dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。</p><p><strong>这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了</strong>。</p><p>那么我假设物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了。</p><p>4、遍历顺序</p><p>为了保证物品只被使用一次，需要倒序遍历背包容量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>这里大家发现和二维dp的写法中，遍历背包的顺序是不一样的！</strong></p><p>二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。</p><p>为什么呢？</p><p><strong>倒序遍历是为了保证物品i只被放入一次！</strong>。但如果一旦正序遍历了，那么物品0就会被重复加入多次！</p><p>举一个例子：物品0的重量weight[0] &#x3D; 1，价值value[0] &#x3D; 15</p><p>如果正序遍历</p><p>dp[1] &#x3D; dp[1 - weight[0]] + value[0] &#x3D; 15</p><p>dp[2] &#x3D; dp[2 - weight[0]] + value[0] &#x3D; 30</p><p>此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。</p><p>为什么倒序遍历，就可以保证物品只放入一次呢？</p><p>倒序就是先算dp[2]</p><p>dp[2] &#x3D; dp[2 - weight[0]] + value[0] &#x3D; 15 （dp数组已经都初始化为0）</p><p>dp[1] &#x3D; dp[1 - weight[0]] + value[0] &#x3D; 15</p><p>所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_1_wei_bag_problem</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; weight = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>    vector&lt;<span class="hljs-type">int</span>&gt; value = &#123;<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;;<br>    <span class="hljs-type">int</span> bagWeight = <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(bagWeight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test_1_wei_bag_problem</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8、分割等和子集"><a href="#8、分割等和子集" class="headerlink" title="8、分割等和子集"></a>8、分割等和子集</h2><p><a href="https://leetcode.cn/problems/partition-equal-subset-sum/">https://leetcode.cn/problems/partition-equal-subset-sum/</a></p><p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。根据题目描述，可以抽象成01背包问题，如果几个元素的和加起来能等于和的一半，即sum&#x2F;2，那就说明可以拆成两个子集。即背包容量为sum&#x2F;2，每个物品的重量为其大小，即nums[i]。</p><p>1、确定dp数组的含义：</p><p><strong>dp[j]表示 背包总容量（所能装的总重量）是j，放进物品后，背的最大重量为dp[j]</strong></p><p>如果背包容量为target， dp[target]就是装满 背包之后的重量，所以 当 dp[target] &#x3D;&#x3D; target 的时候，背包就装满了。</p><p>2、确定递推公式</p><p>01背包的递推公式为：dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);</p><p>本题，相当于背包里放入数值，那么物品i的重量是nums[i]，其价值也是nums[i]。</p><p>所以递推公式：dp[j] &#x3D; max(dp[j], dp[j - nums[i]] + nums[i]);</p><p>3、dp数组初始化</p><p>本题题目中 只包含正整数的非空数组，所以非0下标的元素初始化为0就可以。</p><p>4、确定遍历顺序</p><p>背包容量倒序遍历</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// dp[i]中的i表示背包内总和</span><br>        <span class="hljs-comment">// 题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200</span><br>        <span class="hljs-comment">// 总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以了</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">10001</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            sum += nums[i];<br>        &#125;<br>        <span class="hljs-comment">// 也可以使用库函数一步求和</span><br>        <span class="hljs-comment">// int sum = accumulate(nums.begin(), nums.end(), 0);</span><br>        <span class="hljs-keyword">if</span> (sum % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> target = sum / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-comment">// 开始 01背包</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = target; j &gt;= nums[i]; j--) &#123; <span class="hljs-comment">// 每一个元素一定是不可重复放入，所以从大到小遍历</span><br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - nums[i]] + nums[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 集合中的元素正好可以凑成总和target</span><br>        <span class="hljs-keyword">if</span> (dp[target] == target) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>9、最后一块石头的重量2</p><p><a href="https://leetcode.cn/problems/last-stone-weight-ii/">https://leetcode.cn/problems/last-stone-weight-ii/</a></p><p>有一堆石头，每块石头的重量都是正整数。</p><p>每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;&#x3D; y。那么粉碎的可能结果如下：</p><p>如果 x &#x3D;&#x3D; y，那么两块石头都会被完全粉碎；</p><p>如果 x !&#x3D; y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。</p><p>最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。</p><p>原理等同上一台的分割等和子集，也把石头分成两堆，背包容量为target（总石头重量的一半），dp[target]表示装满一半石头最大有多少，那剩下的一堆就是sum - dp[target]。两者相减就是剩余的最小值。</p><p>1、确定dp数组以及下标的含义</p><p>**dp[j]表示容量（这里说容量更形象，其实就是重量）为j的背包，最多可以背最大重量为dp[j]**。</p><p>可以回忆一下01背包中，dp[j]的含义，容量为j的背包，最多可以装的价值为 dp[j]。</p><p>相对于 01背包，本题中，石头的重量是 stones[i]，石头的价值也是 stones[i] ，可以 “最多可以装的价值为 dp[j]” &#x3D;&#x3D; “最多可以背的重量为dp[j]”</p><p>2、确定递推公式</p><p>01背包的递推公式为：dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);</p><p>本题则是：<strong>dp[j] &#x3D; max(dp[j], dp[j - stones[i]] + stones[i]);</strong></p><p>3、dp数组如何初始化</p><p>既然 dp[j]中的j表示容量，那么最大容量（重量）是多少呢，就是所有石头的重量和。</p><p>因为提示中给出1 &lt;&#x3D; stones.length &lt;&#x3D; 30，1 &lt;&#x3D; stones[i] &lt;&#x3D; 1000，所以最大重量就是30 * 1000 。</p><p>而我们要求的target其实只是最大重量的一半，所以dp数组开到15000大小就可以了。</p><p>当然也可以把石头遍历一遍，计算出石头总重量 然后除2，得到dp数组的大小。</p><p>我这里就直接用15000了。</p><p>接下来就是如何初始化dp[j]呢，因为重量都不会是负数，所以dp[j]都初始化为0就可以了，这样在递归公式dp[j] &#x3D; max(dp[j], dp[j - stones[i]] + stones[i]);中dp[j]才不会初始值所覆盖。</p><p>4、遍历顺序</p><p>外层遍历石头，内存倒序遍历容量。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lastStoneWeightII</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; stones)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">15001</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; stones.<span class="hljs-built_in">size</span>(); i++) sum += stones[i];<br>        <span class="hljs-type">int</span> target = sum / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; stones.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = target; j &gt;= stones[i]; j--) &#123; <span class="hljs-comment">// 遍历背包</span><br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - stones[i]] + stones[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum - dp[target] - dp[target];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="9、目标和"><a href="#9、目标和" class="headerlink" title="9、目标和"></a>9、目标和</h2><p><a href="https://leetcode.cn/problems/target-sum/">https://leetcode.cn/problems/target-sum/</a></p><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p><p>既然目标值为target，那么就一定有：加法组合 - 减法组合 &#x3D; target。</p><p>加法组合 + 减法组合&#x3D; sum，而sum是固定的。减法组合&#x3D; sum - 加法组合</p><p>公式来了， 加法组合- (sum - 加法组合) &#x3D; target 推导出 加法组合&#x3D; (target + sum)&#x2F;2 。</p><p>target是固定的，sum是固定的，加法组合就可以求出来。</p><p>此时问题就是在集合nums中找出值为(target + sum)&#x2F;2的加法组合。—转化为01背包问题（元素不能重复使用）</p><p>假设加法的总和为x，那么减法对应的总和就是sum - x。</p><p>所以我们要求的是 x - (sum - x) &#x3D; target</p><p>x &#x3D; (target + sum) &#x2F; 2–&gt;x即为背包容量–&gt;<strong>转化为求装满背包容量为x的背包一共有几种方法</strong>。</p><p><strong>注意：</strong></p><p>这里的背包容量是一个取整的表达式，例如sum 是5，S是2的话其实就是无解的，所以</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> ((S + sum) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 此时没有方案</span><br></code></pre></td></tr></table></figure><p>同时如果 S的绝对值已经大于sum，那么也是没有方案的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(S) &gt; sum) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 此时没有方案</span><br></code></pre></td></tr></table></figure><p>1、确定dp数组及其含义：</p><p>dp[j]表示装满容量为j的背包一共有dp[j]种方法。</p><p>2、推导递推公式</p><p>有哪些来源可以推出dp[j]呢？</p><p>只要搞到nums[i]，凑成dp[j]就有dp[j - nums[i]] 种方法。注意这里说的是装满背包的方法总数，</p><p>例如：dp[j]，j 为5，</p><ul><li>已经有一个1（nums[i]） 的话，有 dp[4]种方法 凑成 容量为5的背包。背包里已经有一个1了，对于容量为5的背包来说，装满它有dp[5-1]种方法，即dp[4]种方法。下述同理。</li><li>已经有一个2（nums[i]） 的话，有 dp[3]种方法 凑成 容量为5的背包。</li><li>已经有一个3（nums[i]） 的话，有 dp[2]中方法 凑成 容量为5的背包</li><li>已经有一个4（nums[i]） 的话，有 dp[1]中方法 凑成 容量为5的背包</li><li>已经有一个5 （nums[i]）的话，有 dp[0]中方法 凑成 容量为5的背包</li></ul><p>那么凑整dp[5]有多少方法呢，也就是把 所有的 dp[j - nums[i]] 累加起来。</p><p>递推公式为：dp[j] &#x3D; dp[j] + dp[j-nums[i]]</p><p>3、dp数组初始化</p><p>如果数组[0] ，target &#x3D; 0，那么 bagSize &#x3D; (target + sum) &#x2F; 2 &#x3D; 0。 dp[0]也应该是1， 也就是说给数组里的元素 0 前面无论放加法还是减法，都是 1 种方法。</p><p>所以本题我们应该初始化 dp[0] 为 1。装满容量为0的背包有1种方法，—什么都不放。</p><p>4、确定遍历顺序</p><p>外层遍历物品，内层倒序遍历背包容量（确保每个物品只被使用一次）</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++) sum += nums[i]; <span class="hljs-comment">// 求和</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(target) &gt; sum) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//目标和的绝对值大于总和，没有解决方案</span><br>    <span class="hljs-keyword">if</span>((target+sum)%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 向下取整 没有解决方案</span><br>    <span class="hljs-comment">// 转化为01背包问题</span><br>    <span class="hljs-type">int</span> bagsize = (target+sum)/<span class="hljs-number">2</span>;<span class="hljs-comment">//背包容量</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(bagsize+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<span class="hljs-comment">//定义dp数组</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<span class="hljs-comment">//初始化，不取任何数，背包容量为0，算一种方案；</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<span class="hljs-comment">// 先遍历物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j =bagsize;j&gt;=nums[i];j--)&#123;<span class="hljs-comment">// 倒序遍历背包容量，防止物品重复使用</span><br>            dp[j] = dp[j] +dp[j-nums[i]];<span class="hljs-comment">// 求装满背包有几种方法的递推公式。</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[bagsize];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="10、一和零"><a href="#10、一和零" class="headerlink" title="10、一和零"></a>10、一和零</h2><p><a href="https://leetcode.cn/problems/ones-and-zeroes/">https://leetcode.cn/problems/ones-and-zeroes/</a></p><p>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。</p><p>请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。</p><p>本题的本质其实是01背包问题：这个背包容量有两个纬度m和n，不同长度的字符串就是不同大小的物品</p><p>一个字符串由x个0和y个1组成（重量）x要满足m，y要满足n。</p><p>1、确定dp数值及其含义</p><p>dp[i] [j] 表示最多含有i个0和j个1的strs的最大子集的大小（元素个数)为dp[i] [j]。</p><p>2、确定递推公式：</p><p>还是分为拿还是不拿</p><p>不拿：dp[i] [j] </p><p>拿：dp[i-zeronum] [j-onenum] + 1 </p><p>dp[i] [j]是可以由前一个strs推导出来的，如果字符串strs里有一个元素有x个o和y个1，那么dp[i] [j] &#x3D; dp[i-x] [j-y]  +1</p><p>去的是dp[i] [j] 的最大值</p><p>所以dp[i] [j] &#x3D; max(dp[i] [j], dp[i - zeronum] [j - onenum] + 1);</p><p>字符串的zeronum和onenum相当于物品的重量（weight[i]），字符串本身的个数相当于物品的价值（value[i]）。</p><p>3、dp数组初始化</p><p>物品价值是非负的，初始化为0即可，保证会被递推公式覆盖。</p><p>4、确定遍历顺序</p><p>物品就是strs里的字符串，背包容量就是m和n。先遍历物品再遍历背包，且倒序遍历背包容量。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMaxForm</span><span class="hljs-params">(vector&lt;string&gt;&amp; strs, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<span class="hljs-comment">//   默认初始化为0；</span><br>        <span class="hljs-keyword">for</span>(string str:strs)&#123;<br>            <span class="hljs-type">int</span> zeronum = <span class="hljs-number">0</span>,onenum =<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c :str)&#123;<span class="hljs-comment">// 字符串只由0和1组成</span><br>            <span class="hljs-keyword">if</span>( c == <span class="hljs-string">&#x27;0&#x27;</span>)zeronum++;<br>            <span class="hljs-keyword">else</span> onenum++;<br>            &#125;<span class="hljs-comment">//遍历物品，统计每个物品（字符串）所包含的0和1的个数（重量）</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =m;i&gt;=zeronum;i--)&#123;<span class="hljs-comment">// 倒序遍历背包容量</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=n;j&gt;=onenum;j--)&#123;<span class="hljs-comment">// 倒序遍历背包容量</span><br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j],dp[i-zeronum][j-onenum]+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>            <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="11、完全背包理论基础"><a href="#11、完全背包理论基础" class="headerlink" title="11、完全背包理论基础"></a>11、完全背包理论基础</h2><p>有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品都有无限个（也就是可以放入背包多次）</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p>可以看到，对于完全背包来说，每件物品的数量不受限制，可以重复使用同一件物品。由此体现出遍历顺序的区别上，对于01背包，首先，<strong>for循环的顺序可以发生变化了</strong>，先遍历物品再遍历背包或者先遍历背包再遍历物品都可以，因为都能保证下标j之前的dp[j]都是遍历过的值，能有效覆盖，其次，对于<strong>遍历背包容量，不用再从大到小遍历</strong>，使得物品只能被添加一次了，因为完全背包问题中，每件物品可以使用无限次。</p><p>以上讨论是针对纯完全背包问题的，当题目要求发生变化，对于两层循环的遍历顺序就有了要求，针对不同的变体形式，主要体现在遍历顺序的不同。</p><h2 id="12、零钱兑换"><a href="#12、零钱兑换" class="headerlink" title="12、零钱兑换||"></a>12、零钱兑换||</h2><p><a href="https://leetcode.cn/problems/coin-change-ii/">https://leetcode.cn/problems/coin-change-ii/</a></p><p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币<strong>组合数</strong>。假设每一种面额的硬币有无限个。</p><p>根据题目描述可以看出，每种面额的硬币都有无限个，可以抽象成完全背包问题。</p><p>但本题和纯完全背包不一样，<strong>纯完全背包是凑成背包最大价值是多少，而本题是要求凑成总金额的物品组合个数！</strong></p><p>注意题目描述中是凑成总金额的硬币组合数，为什么强调是组合数呢？</p><p>例如示例一：</p><p>5 &#x3D; 2 + 2 + 1</p><p>5 &#x3D; 2 + 1 + 2</p><p>这是一种组合，都是 2 2 1。</p><p>如果问的是排列数，那么上面就是两种排列了。</p><p><strong>组合不强调元素之间的顺序，排列强调元素之间的顺序</strong></p><p>1、确定dp数组以及下标的含义</p><p>dp[j]：凑成总金额j的货币组合数为dp[j]（方法数）</p><p>2、确定递推公式</p><p>dp[j] 就是所有的dp[j - coins[i]]（考虑coins[i]的情况）相加。</p><p>所以递推公式：dp[j] +&#x3D; dp[j - coins[i]];</p><p><strong>这个递推公式大家应该不陌生了，我在讲解01背包题目的时候在9、目标和中就讲解了，求装满背包有几种方法，公式都是：dp[j] +&#x3D; dp[j - nums[i]];</strong></p><p>3、dp数组初始化</p><p>dp[0] &#x3D;1;凑成金额为0有1种方法，什么都不拿。</p><p>4、遍历顺序有讲究！</p><p>纯完全背包求得装满背包的最大价值是多少，和凑成总和的元素有没有顺序没关系，即：有顺序也行，没有顺序也行！而本题要求凑成总和的组合数，元素之间明确要求没有顺序。所以纯完全背包是能凑成总和就行，不用管怎么凑的。本题是求凑出来的方案个数，且每个方案个数是为组合数。那么本题，两个for循环的先后顺序可就有说法了。</p><p>我们先来看 外层for循环遍历物品（钱币），内层for遍历背包（金钱总额）的情况。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; coins.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = coins[i]; j &lt;= amount; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] += dp[j - coins[i]];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>假设：coins[0] &#x3D; 1，coins[1] &#x3D; 5。</p><p>那么就是先把1加入计算，然后再把5加入计算，得到的方法数量只有{1, 5}这种情况。而不会出现{5, 1}的情况。</p><p><strong>所以这种遍历顺序中dp[j]里计算的是组合数！</strong></p><p>如果把两个for交换顺序，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= amount; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; coins.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>        <span class="hljs-keyword">if</span> (j - coins[i] &gt;= <span class="hljs-number">0</span>) dp[j] += dp[j - coins[i]];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>背包容量的每一个值，都是经过 1 和 5 的计算，包含了{1, 5} 和 {5, 1}两种情况。</p><p><strong>此时dp[j]里算出来的就是排列数！</strong></p><p>本题求得是组合数，为此，先遍历物品，再遍历背包容量。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> amount, vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; coins.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = coins[i]; j &lt;= amount; j++) &#123; <span class="hljs-comment">// 遍历背包</span><br>                dp[j] += dp[j - coins[i]];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[amount];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="13、组合总和4"><a href="#13、组合总和4" class="headerlink" title="13、组合总和4"></a>13、组合总和4</h2><p><a href="https://leetcode.cn/problems/combination-sum-iv/">https://leetcode.cn/problems/combination-sum-iv/</a></p><p>给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。</p><p>示例:</p><ul><li>nums &#x3D; [1, 2, 3]</li><li>target &#x3D; 4</li></ul><p>所有可能的组合为： (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1)</p><p>请注意，<strong>顺序不同的序列</strong>被视作不同的组合。</p><p>由题可知，求的是排列数！</p><p>其余推导和上面的零钱兑换||一致，给出代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">combinationSum4</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(target+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<span class="hljs-comment">//dp数组初始化，凑成和为0有1种方法，就是不取任何数</span><br>        <span class="hljs-comment">// 求排列数，考虑顺序，所以先遍历背包，再遍历物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;=target;i++)&#123;<span class="hljs-comment">//先遍历背包</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;nums.<span class="hljs-built_in">size</span>();j++)&#123;<span class="hljs-comment">//再遍历物品</span><br>            <span class="hljs-keyword">if</span> (i - nums[j] &gt;= <span class="hljs-number">0</span> &amp;&amp; dp[i] &lt; INT_MAX - dp[i - nums[j]]) &#123;<br>                    dp[i] = dp[i] +dp[i-nums[j]];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[target];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>C++测试用例有两个数相加超过int的数据，所以需要在if里加上dp[i] &lt; INT_MAX - dp[i - num]。</p><p>14、零钱兑换</p><p><a href="https://leetcode.cn/problems/coin-change/">https://leetcode.cn/problems/coin-change/</a></p><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p>你可以认为每种硬币的数量是无限的。</p><p>1、确定dp数组以及下标的含义</p><p><strong>dp[j]：凑足总额为j所需钱币的最少个数为dp[j]</strong></p><p>2、确定递推公式</p><p>凑足总额为j - coins[i]的最少个数为dp[j - coins[i]]，那么只需要加上一个钱币coins[i]即dp[j - coins[i]] + 1就是dp[j]（考虑coins[i]）</p><p>所以dp[j] 要取所有 dp[j - coins[i]] + 1 中最小的。</p><p>递推公式：dp[j] &#x3D; min(dp[j - coins[i]] + 1, dp[j]);</p><p>3、dp数组如何初始化</p><p>首先凑足总金额为0所需钱币的个数一定是0，那么dp[0] &#x3D; 0;</p><p>其他下标对应的数值呢？</p><p>考虑到递推公式的特性，dp[j]必须初始化为一个最大的数，否则就会在min(dp[j - coins[i]] + 1, dp[j])比较的过程中被初始值覆盖。</p><p>所以下标非0的元素都是应该是最大值。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>, INT_MAX)</span></span>;<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>4、确定遍历顺序</p><p>本题求钱币最小个数，<strong>那么钱币有顺序和没有顺序都可以，都不影响钱币的最小个数</strong>。</p><p>所以本题并不强调集合是组合还是排列。</p><p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p><p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p><p><strong>所以本题的两个for循环的关系是：外层for循环遍历物品，内层for遍历背包或者外层for遍历背包，内层for循环遍历物品都是可以的！</strong></p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins, <span class="hljs-type">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>, INT_MAX)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; coins.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = coins[i]; j &lt;= amount; j++) &#123; <span class="hljs-comment">// 遍历背包</span><br>                <span class="hljs-keyword">if</span> (dp[j - coins[i]] != INT_MAX) &#123; <span class="hljs-comment">// 如果dp[j - coins[i]]是初始值则跳过</span><br>                    dp[j] = <span class="hljs-built_in">min</span>(dp[j - coins[i]] + <span class="hljs-number">1</span>, dp[j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (dp[amount] == INT_MAX) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> dp[amount];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="14、零钱兑换"><a href="#14、零钱兑换" class="headerlink" title="14、零钱兑换"></a>14、零钱兑换</h2><p><a href="https://leetcode.cn/problems/coin-change/">https://leetcode.cn/problems/coin-change/</a></p><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p>你可以认为每种硬币的数量是无限的。</p><p>1、确定dp数组以及下标的含义</p><p><strong>dp[j]：凑足总额为j所需钱币的最少个数为dp[j]</strong></p><p>2、确定递推公式</p><p>凑足总额为j - coins[i]的最少个数为dp[j - coins[i]]，那么只需要加上一个钱币coins[i]即dp[j - coins[i]] + 1就是dp[j]（考虑coins[i]）</p><p>所以dp[j] 要取所有 dp[j - coins[i]] + 1 中最小的。</p><p>递推公式：dp[j] &#x3D; min(dp[j - coins[i]] + 1, dp[j]);</p><p>3、dp数组如何初始化</p><p>首先凑足总金额为0所需钱币的个数一定是0，那么dp[0] &#x3D; 0;</p><p>其他下标对应的数值呢？</p><p>考虑到递推公式的特性，dp[j]必须初始化为一个最大的数，否则就会在min(dp[j - coins[i]] + 1, dp[j])比较的过程中被初始值覆盖。</p><p>所以下标非0的元素都是应该是最大值。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>, INT_MAX)</span></span>;<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>4、确定遍历顺序</p><p>本题求钱币最小个数，<strong>那么钱币有顺序和没有顺序都可以，都不影响钱币的最小个数</strong>。</p><p>所以本题并不强调集合是组合还是排列。</p><p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p><p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p><p><strong>所以本题的两个for循环的关系是：外层for循环遍历物品，内层for遍历背包或者外层for遍历背包，内层for循环遍历物品都是可以的！</strong></p><p>那么我采用coins放在外循环，target在内循环的方式。</p><p>本题钱币数量可以无限使用，那么是完全背包。所以遍历的内循环是正序</p><p>综上所述，遍历顺序为：coins（物品）放在外循环，target（背包）在内循环。且内循环正序。</p><p>代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins, <span class="hljs-type">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>, INT_MAX)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; coins.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = coins[i]; j &lt;= amount; j++) &#123; <span class="hljs-comment">// 遍历背包</span><br>                <span class="hljs-keyword">if</span> (dp[j - coins[i]] != INT_MAX) &#123; <span class="hljs-comment">// 如果dp[j - coins[i]]是初始值则跳过</span><br>                    dp[j] = <span class="hljs-built_in">min</span>(dp[j - coins[i]] + <span class="hljs-number">1</span>, dp[j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (dp[amount] == INT_MAX) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> dp[amount];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="15、完全平方数"><a href="#15、完全平方数" class="headerlink" title="15、完全平方数"></a>15、完全平方数</h2><p><a href="https://leetcode.cn/problems/perfect-squares/">https://leetcode.cn/problems/perfect-squares/</a></p><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p><p>给你一个整数 n ，返回和为 n 的完全平方数的 最少数量</p><p>1、确定dp数组（dp table）以及下标的含义</p><p><strong>dp[j]：和为j的完全平方数的最少数量为dp[j]</strong></p><p>2、确定递推公式</p><p>dp[j] 可以由dp[j - i * i]推出， dp[j - i * i] + 1 便可以凑成dp[j]。</p><p>此时我们要选择最小的dp[j]，所以递推公式：dp[j] &#x3D; min(dp[j - i * i] + 1, dp[j]);</p><p>3、dp数组如何初始化</p><p>dp[0]表示 和为0的完全平方数的最小数量，那么dp[0]一定是0。</p><p>有同学问题，那0 * 0 也算是一种啊，为啥dp[0] 就是 0呢？</p><p>看题目描述，找到若干个完全平方数（比如 1, 4, 9, 16, …），题目描述中可没说要从0开始，dp[0]&#x3D;0完全是为了递推公式。</p><p>非0下标的dp[j]应该是多少呢？</p><p>从递归公式dp[j] &#x3D; min(dp[j - i * i] + 1, dp[j]);中可以看出每次dp[j]都要选最小的，<strong>所以非0下标的dp[j]一定要初始为最大值，这样dp[j]在递推的时候才不会被初始值覆盖</strong>。</p><p>4、确定遍历顺序</p><p>我们知道这是完全背包，</p><p>如果求组合数就是外层for循环遍历物品，内层for遍历背包。</p><p>如果求排列数就是外层for遍历背包，内层for循环遍历物品。</p><p><strong>所以本题外层for遍历背包，内层for遍历物品，还是外层for遍历物品，内层for遍历背包，都是可以的</strong></p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, INT_MAX)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i * i &lt;= n; i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i * i; j &lt;= n; j++) &#123; <span class="hljs-comment">// 遍历背包</span><br>                dp[j] = <span class="hljs-built_in">min</span>(dp[j - i * i] + <span class="hljs-number">1</span>, dp[j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="16、单词拆分"><a href="#16、单词拆分" class="headerlink" title="16、单词拆分"></a>16、单词拆分</h2><p><a href="https://leetcode.cn/problems/word-break/">https://leetcode.cn/problems/word-break/</a></p><p>单词就是物品，字符串s就是背包，单词能否组成字符串s，就是问物品能不能把背包装满。</p><p>拆分时可以重复使用字典中的单词，说明就是一个完全背包！</p><p>动规五部曲分析如下：</p><p>1、确定dp数组以及下标的含义</p><p><strong>dp[i] : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词</strong>。</p><p>2、确定递推公式</p><p>如果确定dp[j] 是true，且 [j, i] 这个区间的子串出现在字典里，那么dp[i]一定是true。（j &lt; i ）。</p><p>所以递推公式是 if([j, i] 这个区间的子串出现在字典里 &amp;&amp; dp[j]是true) 那么 dp[i] &#x3D; true。</p><p>3、dp数组如何初始化</p><p>从递推公式中可以看出，dp[i] 的状态依靠 dp[j]是否为true，那么dp[0]就是递推的根基，dp[0]一定要为true，否则递推下去后面都都是false了。</p><p>那么dp[0]有没有意义呢？</p><p>dp[0]表示如果字符串为空的话，说明出现在字典里。</p><p>但题目中说了“给定一个非空字符串 s” 所以测试数据中不会出现i为0的情况，那么dp[0]初始为true完全就是为了推导公式。</p><p>下标非0的dp[i]初始化为false，只要没有被覆盖说明都是不可拆分为一个或多个在字典中出现的单词。</p><p>4、确定遍历顺序</p><p>题目中说是拆分为一个或多个在字典中出现的单词，所以这是完全背包。</p><p>而本题其实我们求的是<strong>排列数</strong>，为什么呢。 拿 s &#x3D; “applepenapple”, wordDict &#x3D; [“apple”, “pen”] 举例。</p><p>“apple”, “pen” 是物品，那么我们要求 物品的组合一定是 “apple” + “pen” + “apple” 才能组成 “applepenapple”。</p><p>“apple” + “apple” + “pen” 或者 “pen” + “apple” + “apple” 是不可以的，那么我们就是<strong>强调物品之间顺序</strong>。</p><p>所以说，本题一定是 先遍历 背包，再遍历物品。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;<br>        <span class="hljs-function">unordered_set&lt;string&gt; <span class="hljs-title">wordSet</span><span class="hljs-params">(wordDict.begin(), wordDict.end())</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(s.size() + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= s.<span class="hljs-built_in">size</span>(); i++) &#123;   <span class="hljs-comment">// 遍历背包</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;       <span class="hljs-comment">// 遍历物品</span><br>                string word = s.<span class="hljs-built_in">substr</span>(j, i - j); <span class="hljs-comment">//substr(起始位置，截取的个数)</span><br>                <span class="hljs-keyword">if</span> (wordSet.<span class="hljs-built_in">find</span>(word) != wordSet.<span class="hljs-built_in">end</span>() &amp;&amp; dp[j]) &#123;<br>                    dp[i] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[s.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="背包问题总结"><a href="#背包问题总结" class="headerlink" title="背包问题总结"></a>背包问题总结</h2><p>关于递推公式</p><p>问能否能装满背包（或者最多装多少）：dp[j] &#x3D; max(dp[j], dp[j - nums[i]] + nums[i]); </p><p>问装满背包有几种方法：dp[j] &#x3D; dp[j] + dp[j - nums[i]]</p><p>问背包装满最大价值：dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]); </p><p>问装满背包所有物品的最小个数：dp[j] &#x3D; min(dp[j - coins[i]] + 1, dp[j]);</p><p>关于遍历顺序</p><p>01背包：解二维dp数组01背包先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。一维dp数组01背包只能先遍历物品再遍历背包容量，且第二层for循环是从大到小遍历。</p><p>完全背包：完全背包的一维dp数组实现，先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。</p><p>但是仅仅是纯完全背包的遍历顺序是这样的，题目稍有变化，两个for循环的先后顺序就不一样了。</p><p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p><p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p><h2 id="17、打家劫舍"><a href="#17、打家劫舍" class="headerlink" title="17、打家劫舍"></a>17、打家劫舍</h2><p><a href="https://leetcode.cn/problems/house-robber/">https://leetcode.cn/problems/house-robber/</a></p><p>1、确定dp数组（dp table）以及下标的含义</p><p>**dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]**。</p><p>2、确定递推公式</p><p>决定dp[i]的因素就是第i房间偷还是不偷。</p><p>如果偷第i房间，那么dp[i] &#x3D; dp[i - 2] + nums[i] ，即：第i-1房一定是不考虑的，找出 下标i-2（包括i-2）以内的房屋，最多可以偷窃的金额为dp[i-2] 加上第i房间偷到的钱。</p><p>如果不偷第i房间，那么dp[i] &#x3D; dp[i - 1]，即考 虑i-1房，（<strong>注意这里是考虑，并不是一定要偷i-1房，这是很多同学容易混淆的点</strong>）</p><p>然后dp[i]取最大值，即dp[i] &#x3D; max(dp[i - 2] + nums[i], dp[i - 1]);</p><p>3、dp数组如何初始化</p><p>从递推公式dp[i] &#x3D; max(dp[i - 2] + nums[i], dp[i - 1]);可以看出，递推公式的基础就是dp[0] 和 dp[1]</p><p>从dp[i]的定义上来讲，dp[0] 一定是 nums[0]，dp[1]就是nums[0]和nums[1]的最大值即：dp[1] &#x3D; max(nums[0], nums[1]);</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size())</span></span>;<br>dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br></code></pre></td></tr></table></figure><p>4、确定遍历顺序</p><p>dp[i] 是根据dp[i - 2] 和 dp[i - 1] 推导出来的，那么一定是从前到后遍历！</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">2</span>] + nums[i], dp[i - <span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><p>代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//没有元素，偷不到，返回零</span><br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 只有一个元素，下标零就是最大值</span><br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">dp</span>(nums.<span class="hljs-built_in">size</span>());<span class="hljs-comment">// dp数组</span><br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>],nums[<span class="hljs-number">1</span>]);<span class="hljs-comment">// dp数组的初始化</span><br>        <span class="hljs-comment">// 遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>],dp[i<span class="hljs-number">-2</span>]+nums[i]);<span class="hljs-comment">// 递推公式，偷当前家还是不偷当前家，取最大值</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="18、打家劫舍"><a href="#18、打家劫舍" class="headerlink" title="18、打家劫舍||"></a>18、打家劫舍||</h2><p><a href="https://leetcode.cn/problems/house-robber-ii/">https://leetcode.cn/problems/house-robber-ii/</a></p><p>对比上一题，房屋成环了，也是相邻的不能偷，因此需要分类讨论了。</p><p>情况1：考虑不包含首位元素</p><p>情况2：考虑不包含尾元素</p><p>情况3：考虑不包含首元素</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 注意注释中的情况二情况三，以及把198.打家劫舍的代码抽离出来了</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> result1 = <span class="hljs-built_in">robRange</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>); <span class="hljs-comment">// 情况二</span><br>        <span class="hljs-type">int</span> result2 = <span class="hljs-built_in">robRange</span>(nums, <span class="hljs-number">1</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>); <span class="hljs-comment">// 情况三</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(result1, result2);<br>    &#125;<br>    <span class="hljs-comment">// 198.打家劫舍的逻辑</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">robRange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (end == start) <span class="hljs-keyword">return</span> nums[start];<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size())</span></span>;<br>        dp[start] = nums[start];<br>        dp[start + <span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[start], nums[start + <span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start + <span class="hljs-number">2</span>; i &lt;= end; i++) &#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">2</span>] + nums[i], dp[i - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[end];<br>    &#125;<br>&#125;;<span class="hljs-comment">// 情况2、3包含了情况1，故不必单独写情况1的处理逻辑了。</span><br></code></pre></td></tr></table></figure><h2 id="19、打家劫舍"><a href="#19、打家劫舍" class="headerlink" title="19、打家劫舍|||"></a>19、打家劫舍|||</h2><p><a href="https://leetcode.cn/problems/house-robber-iii/">https://leetcode.cn/problems/house-robber-iii/</a></p><p><strong>树形dp</strong></p><p>所有房屋以二叉树的结构排列，相邻节点不能偷。</p><p>1、确定递归函数的参数和返回值</p><p>这里我们要求一个节点 偷与不偷的两个状态所得到的金钱，那么返回值就是一个长度为2的数组。</p><p>参数为当前节点，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">robTree</span><span class="hljs-params">(TreeNode* cur)</span> </span>&#123;<br></code></pre></td></tr></table></figure><p>其实这里的返回数组就是dp数组。</p><p>所以dp数组（dp table）以及下标的含义：dp[0] 表示下标为0记录不偷该节点所得到的的最大金钱，dp[1]表示下标为1记录偷该节点所得到的的最大金钱。</p><p><strong>所以本题dp数组就是一个长度为2的数组！</strong></p><p>那么有同学可能疑惑，长度为2的数组怎么标记树中每个节点的状态呢？</p><p><strong>别忘了在递归的过程中，系统栈会保存每一层递归的参数</strong>。</p><p>2、确定终止条件</p><p>在遍历的过程中，如果遇到空节点的话，很明显，无论偷还是不偷都是0，所以就返回</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br></code></pre></td></tr></table></figure><p>这也相当于dp数组的初始化</p><p>3、确定遍历顺序</p><p>首先明确的是使用后序遍历。 因为要通过递归函数的返回值来做下一步计算。</p><p>通过递归左节点，得到左节点偷与不偷的金钱。</p><p>通过递归右节点，得到右节点偷与不偷的金钱。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 下标0：不偷，下标1：偷</span><br>vector&lt;<span class="hljs-type">int</span>&gt; left = <span class="hljs-built_in">robTree</span>(cur-&gt;left); <span class="hljs-comment">// 左</span><br>vector&lt;<span class="hljs-type">int</span>&gt; right = <span class="hljs-built_in">robTree</span>(cur-&gt;right); <span class="hljs-comment">// 右</span><br><span class="hljs-comment">// 中</span><br></code></pre></td></tr></table></figure><p>4、确定单层递归的逻辑</p><p>如果是偷当前节点，那么左右孩子就不能偷，val1 &#x3D; cur-&gt;val + left[0] + right[0]; （<strong>如果对下标含义不理解就再回顾一下dp数组的含义</strong>）</p><p>如果不偷当前节点，那么左右孩子就可以偷，至于到底偷不偷一定是选一个最大的，所以：val2 &#x3D; max(left[0], left[1]) + max(right[0], right[1]);</p><p>最后当前节点的状态就是{val2, val1}; 即：{不偷当前节点得到的最大金钱，偷当前节点得到的最大金钱}</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; left = <span class="hljs-built_in">robTree</span>(cur-&gt;left); <span class="hljs-comment">// 左</span><br>vector&lt;<span class="hljs-type">int</span>&gt; right = <span class="hljs-built_in">robTree</span>(cur-&gt;right); <span class="hljs-comment">// 右</span><br><span class="hljs-comment">// 偷cur</span><br><span class="hljs-type">int</span> val1 = cur-&gt;val + left[<span class="hljs-number">0</span>] + right[<span class="hljs-number">0</span>];<br><span class="hljs-comment">// 不偷cur</span><br><span class="hljs-type">int</span> val2 = <span class="hljs-built_in">max</span>(left[<span class="hljs-number">0</span>], left[<span class="hljs-number">1</span>]) + <span class="hljs-built_in">max</span>(right[<span class="hljs-number">0</span>], right[<span class="hljs-number">1</span>]);<br><span class="hljs-keyword">return</span> &#123;val2, val1&#125;;<br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result = <span class="hljs-built_in">robTree</span>(root);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(result[<span class="hljs-number">0</span>],result[<span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">robTree</span><span class="hljs-params">(TreeNode *cur)</span></span>&#123; <span class="hljs-comment">// 二叉树的后序遍历 返回的是dp数组，0代表不偷，1代表偷 // 1、确定返回值和参数</span><br><span class="hljs-comment">// 2、确定终止条件</span><br>    <span class="hljs-keyword">if</span>(cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br><span class="hljs-comment">// 3、确定单层递归的逻辑</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; left = <span class="hljs-built_in">robTree</span>(cur-&gt;left);<span class="hljs-comment">//左，统计左孩偷与不偷的钱币</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; right = <span class="hljs-built_in">robTree</span>(cur-&gt;right);<span class="hljs-comment">// 右，统计右孩子偷与不偷的钱币</span><br>    <span class="hljs-type">int</span> val1 = cur-&gt;val + left[<span class="hljs-number">0</span>] +right[<span class="hljs-number">0</span>];<span class="hljs-comment">//偷当前节点，左右孩子都不能偷 中</span><br>    <span class="hljs-type">int</span> val2 = <span class="hljs-built_in">max</span>(left[<span class="hljs-number">0</span>],left[<span class="hljs-number">1</span>]) + <span class="hljs-built_in">max</span>(right[<span class="hljs-number">0</span>],right[<span class="hljs-number">1</span>]);<span class="hljs-comment">//不偷当前节点，选择孩子偷与不偷的最大钱币数量 中</span><br>    <span class="hljs-keyword">return</span> &#123;val2,val1&#125;;<span class="hljs-comment">// 返回的就是传入的节点不偷与偷的最大金币</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="20、买卖股票的最佳时机"><a href="#20、买卖股票的最佳时机" class="headerlink" title="20、买卖股票的最佳时机"></a>20、买卖股票的最佳时机</h2><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/</a></p><p>只允许买卖一次</p><p>1、确定dp数组（dp table）以及下标的含义</p><p>dp[i] [0] 表示第i天持有股票所得最多利润 ，<strong>这里可能有同学疑惑，本题中只能买卖一次，持有股票之后哪还有现金呢？</strong>–说成利润就好理解了</p><p>其实一开始利润是0，那么加入第i天买入股票利润就是 -prices[i]， 这是一个负数。</p><p>dp[i] [1] 表示第i天不持有股票所得最多利润</p><p><strong>注意这里说的是“持有”，“持有”不代表就是当天“买入”！也有可能是昨天就买入了，今天保持持有的状态</strong></p><p>很多同学把“持有”和“买入”没区分清楚。</p><p>2、确定递推公式</p><p>如果第i天持有股票即dp[i] [0]， 那么可以由两个状态推出来</p><ul><li>第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1] [0]</li><li>第i天买入股票，所得现金就是买入今天的股票后所得利润即：-prices[i]</li></ul><p>那么dp[i] [0]应该选所得现金最大的，所以<strong>dp[i] [0] &#x3D; max(dp[i - 1] [0], -prices[i]);</strong></p><p>如果第i天不持有股票即dp[i] [1]， 也可以由两个状态推出来</p><ul><li>第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1] [1]</li><li>第i天卖出股票，所得现金就是按照今天股票价格卖出后所得利润即：prices[i] + dp[i - 1] [0]</li></ul><p>同样dp[i] [1]取最大的，dp[i] [1] &#x3D; max(dp[i - 1] [1], prices[i] + dp[i - 1] [0]);</p><p>3、dp数组如何初始化</p><p>由递推公式 dp[i] [0] &#x3D; max(dp[i - 1] [0], -prices[i]); 和 dp[i] [1] &#x3D; max(dp[i - 1] [1], prices[i] + dp[i - 1] [0]);可以看出</p><p>其基础都是要从dp[0] [0]和dp[0] [1]推导出来。</p><p>那么dp[0] [0]表示第0天持有股票，此时的持有股票就一定是买入股票了，因为不可能有前一天推出来，所以dp[0] [0] -&#x3D; prices[0];</p><p>dp[0] [1]表示第0天不持有股票，不持有股票那么利润就是0，所以dp[0] [1] &#x3D; 0;</p><p>4、确定遍历顺序</p><p>从递推公式可以看出dp[i]都是由dp[i - 1]推导出来的，那么一定是从前向后遍历。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len = prices.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(len,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] -= prices[<span class="hljs-number">0</span>];<span class="hljs-comment">// dp数组初始化，第0天持有，等于当天买入，所得收益为-prices[0]；</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">// 第0天不持有，收益就是0</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">1</span>; i&lt;len;i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],-prices[i]);<span class="hljs-comment">//当天买入，利润为-prices[0]</span><br>            dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>],prices[i]+dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]);<span class="hljs-comment">// 前一天不持有，和前一天持有今天卖出取最大值</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[len<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;; <span class="hljs-comment">// 为什么最后结果是dp[len-1][1]而不是dp[len-1][0]:因为不持有股票（卖出）一定比持有利润高--只卖买一次。</span><br></code></pre></td></tr></table></figure><h2 id="21、买卖股票的最佳时机"><a href="#21、买卖股票的最佳时机" class="headerlink" title="21、买卖股票的最佳时机||"></a>21、买卖股票的最佳时机||</h2><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/</a></p><p>可以买卖无数次。</p><p>因为一只股票可以买卖多次，所以当第i天买入股票的时候，所持有的现金可能有之前买卖过的利润，<strong>即i-1天有利润。</strong></p><p>所以区别在于递推公式不同，dp[i] [0] &#x3D; max(dp[i - 1] [0], <strong>dp[i - 1] [1] - prices[i]</strong>); 第i天持有股票的利润发生了变化，可以在买入时有之前卖出的利润。</p><p>代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>    <span class="hljs-comment">// 贪心算法</span><br>    <span class="hljs-comment">//     int result = 0;</span><br>    <span class="hljs-comment">//     for(int i = 1;i &lt; prices.size();i++)&#123;</span><br>    <span class="hljs-comment">//         result += max(prices[i]-prices[i-1],0);// 只收集每天的正利润，局部最优得到全局最优</span><br>    <span class="hljs-comment">//     &#125;</span><br>    <span class="hljs-comment">//     return result;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// 动态规划</span><br>    <span class="hljs-type">int</span> len = prices.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(len,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>));<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">1</span>;i&lt;len;i++)&#123;<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]-prices[i]);<span class="hljs-comment">// 要考虑i-1天持有，第i天卖出的收益（因为可以多次买卖，所以第i-1天有收益）</span><br>        dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>],prices[i]+dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[len<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="22、买卖股票的最佳时机"><a href="#22、买卖股票的最佳时机" class="headerlink" title="22、买卖股票的最佳时机|||"></a>22、买卖股票的最佳时机|||</h2><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/</a></p><p>最多买卖两次</p><p>有了多种状态加以区分。</p><p>1、确定dp数组以及下标的含义</p><p>一天一共就有五个状态，</p><ol><li>没有操作 （其实我们也可以不设置这个状态） 0</li><li>第一次持有股票 1</li><li>第一次不持有股票 2</li><li>第二次持有股票 3</li><li>第二次不持有股票 4</li></ol><p>dp[i] [j]中 i表示第i天，j为 [0 - 4] 五个状态，dp[i] [j]表示第i天状态j的收益。</p><p>需要注意：dp[i] [1]，<strong>表示的是第i天，持有股票的状态，并不是说一定要第i天买入股票，这是很多同学容易陷入的误区</strong>。</p><p>例如 dp[i] [1] ，并不是说 第i天一定买入股票，有可能 第 i-1天 就买入了，那么 dp[i] [1] 延续持有股票的这个状态。</p><p>2、确定递推公式</p><p>达到dp[i] [1]状态，有两个具体操作：</p><ul><li>操作一：第i天买入股票了，那么dp[i] [ 1] &#x3D; dp[i-1] [0] - prices[i]</li><li>操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i] [1] &#x3D; dp[i - 1] [1]</li></ul><p>那么dp[i] [1]究竟选 dp[i-1] [0] - prices[i]，还是dp[i - 1] [ 1]呢？</p><p>一定是选最大的，所以 dp[i] [1] &#x3D; max(dp[i-1] [0] - prices[i], dp[i - 1] [1]);</p><p>同理dp[i] [2]也有两个操作：</p><ul><li>操作一：第i天卖出股票了，那么dp[i] [2] &#x3D; dp[i - 1] [1] + prices[i]</li><li>操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp[i] [2] &#x3D; dp[i - 1] [2]</li></ul><p>所以dp[i] [2] &#x3D; max(dp[i - 1] [1] + prices[i], dp[i - 1] [2])</p><p>同理可推出剩下状态部分：</p><p>dp[i] [3] &#x3D; max(dp[i - 1] [3], dp[i - 1] [2] - prices[i]);</p><p>dp[i] [4] &#x3D; max(dp[i - 1] [4], dp[i - 1] [3] + prices[i]);</p><p>3、数组初始化</p><p>0天没有操作，这个最容易想到，就是0，即：dp[0] [0] &#x3D; 0;</p><p>第0天做第一次买入的操作，dp[0] [1] &#x3D; -prices[0];</p><p>第0天做第一次卖出的操作，这个初始值应该是多少呢？</p><p>此时还没有买入，怎么就卖出呢？ 其实大家可以理解当天买入，当天卖出，收益不变，所以dp[0] [2] &#x3D; 0;</p><p>第0天第二次买入操作，初始值应该是多少呢？应该不少同学疑惑，第一次还没买入呢，怎么初始化第二次买入呢？</p><p>第二次买入依赖于第一次卖出的状态，其实相当于第0天第一次买入了，第一次卖出了，然后再买入一次（第二次买入），那么现在手头上没有收益，只要买入，现金就做相应的减少。</p><p>所以第二次买入操作，初始化为：dp[0] [3] &#x3D; -prices[0];</p><p>同理第二次卖出初始化dp[0] [4] &#x3D; 0;当天买入当天卖出</p><p>4、确定遍历顺序</p><p>从递归公式其实已经可以看出，一定是从前向后遍历，因为dp[i]，依靠dp[i - 1]的数值。</p><p>代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (prices.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(prices.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">5</span>, <span class="hljs-number">0</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>            dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);<br>            dp[i][<span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);<br>            dp[i][<span class="hljs-number">3</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>] - prices[i]);<br>            dp[i][<span class="hljs-number">4</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">4</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>] + prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[prices.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][<span class="hljs-number">4</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="23、买卖股票的最佳时机IV"><a href="#23、买卖股票的最佳时机IV" class="headerlink" title="23、买卖股票的最佳时机IV"></a>23、买卖股票的最佳时机IV</h2><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/</a></p><p>最多可以有k次买卖，奇数次是买入，偶数次是卖出</p><p>1、确定dp数组以及下标的含义</p><p>在上一题中，我们定义了一个二维dp数组，本题其实依然可以用一个二维dp数组。</p><p>使用二维数组 dp[i] [j] ：第i天的状态为j，所剩下的最大利润是dp[i] [j]</p><p>j的状态表示为：</p><ul><li>0 表示不操作</li><li>1 第一次买入</li><li>2 第一次卖出</li><li>3 第二次买入</li><li>4 第二次卖出</li><li>…..</li></ul><p><strong>大家应该发现规律了吧 ，除了0以外，偶数就是卖出，奇数就是买入</strong>。</p><p>题目要求是至多有K笔交易，那么j的范围就定义为 2 * k + 1 就可以了。</p><p>所以二维dp数组的C++定义为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(prices.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br></code></pre></td></tr></table></figure><p>2、确定递推公式</p><p>达到dp[i] [1]状态，有两个具体操作：</p><ul><li>操作一：第i天买入股票了，那么dp[i] [1] &#x3D; dp[i - 1] [0] - prices[i]</li><li>操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i] [1] &#x3D; dp[i - 1] [1]</li></ul><p>选最大的，所以 dp[i] [1] &#x3D; max(dp[i - 1] [0] - prices[i], dp[i - 1] [1]);</p><p>同理dp[i] [2]也有两个操作：</p><ul><li>操作一：第i天卖出股票了，那么dp[i] [2] &#x3D; dp[i - 1] [1] + prices[i]</li><li>操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp[i] [2] &#x3D; dp[i - 1] [2]</li></ul><p>所以dp[i] [2] &#x3D; max(dp[i - 1] [1] + prices[i], dp[i - 1] [2])</p><p>同理可以类比剩下的状态，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span> * k - <span class="hljs-number">1</span>; j += <span class="hljs-number">2</span>) &#123;<br>    dp[i][j + <span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j] - prices[i]);<br>    dp[i][j + <span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">2</span>], dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] + prices[i]);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>本题和上一题的最大的区别就是这里要类比j为奇数是买，偶数是卖的状态</strong>。</p><p>3、dp数组如何初始化</p><p>第0天没有操作，这个最容易想到，就是0，即：dp[0] [0] &#x3D; 0;</p><p>第0天做第一次买入的操作，dp[0] [1] &#x3D; -prices[0];</p><p>第0天做第一次卖出的操作，这个初始值应该是多少呢？</p><p>此时还没有买入，怎么就卖出呢？ 其实大家可以理解<strong>当天买入，当天卖出</strong>，所以dp[0] [2] &#x3D; 0;</p><p>第0天第二次买入操作，初始值应该是多少呢？应该不少同学疑惑，第一次还没买入呢，怎么初始化第二次买入呢？</p><p>第二次买入依赖于第一次卖出的状态，其实相当于第0天第一次买入了，第一次卖出了，然后在买入一次（第二次买入），那么现在手头上没有现金，只要买入，现金就做相应的减少。</p><p>所以第二次买入操作，初始化为：dp[0] [3] &#x3D; -prices[0];</p><p>第二次卖出初始化dp[0] [4] &#x3D; 0;</p><p><strong>所以同理可以推出dp[0] [j]当j为奇数的时候都初始化为 -prices[0]</strong></p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">2</span> * k; j += <span class="hljs-number">2</span>) &#123;<br>    dp[<span class="hljs-number">0</span>][j] = -prices[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>4、确定遍历顺序</p><p>从递归公式其实已经可以看出，一定是从前向后遍历，因为dp[i]，依靠dp[i - 1]的数值。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span> k, vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span> (prices.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(prices.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<span class="hljs-comment">// 定义dp数组的大小</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">2</span> * k; j += <span class="hljs-number">2</span>) &#123;<span class="hljs-comment">// dp数组初始化 奇数次是买入，只要是买入 利润均为-prices[0]</span><br>            dp[<span class="hljs-number">0</span>][j] = -prices[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; prices.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span> * k - <span class="hljs-number">1</span>; j += <span class="hljs-number">2</span>) &#123;<br>                dp[i][j + <span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j] - prices[i]);<br>                dp[i][j + <span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">2</span>], dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] + prices[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[prices.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][<span class="hljs-number">2</span> * k];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>24、买卖股票的最佳时机含冷冻期、</p><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/</a></p><ul><li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li></ul><p>1、确定dp数组以及下标的含义</p><p>dp[i] [j]，第i天状态为j，收益为dp[i] [j]。</p><ul><li>状态一：持有股票状态（今天买入股票，或者是之前就买入了股票然后没有操作，一直持有）</li><li>不持有股票状态，这里就有两种卖出股票状态<ul><li>状态二：保持卖出股票的状态（两天前就卖出了股票，度过一天冷冻期。或者是前一天就是卖出股票状态，一直没操作）</li><li>状态三：今天卖出股票</li></ul></li><li>状态四：今天为冷冻期状态，但冷冻期状态不可持续，只有一天</li></ul><p>买卖股票最佳时机 1，2，3，4 的题目讲解中，今天卖出股票」我是没有单独列出一个状态的归类为「不持有股票的状态」，而本题为什么要单独列出「今天卖出股票」 一个状态呢？</p><p>因为本题我们有<strong>冷冻期</strong>，而冷冻期的前一天，只能是 「今天卖出股票」状态，如果是 「不持有股票状态」那么就很模糊，因为不一定是 卖出股票的操作。</p><p>2、确定递推公式</p><p><strong>达到买入股票状态</strong>（状态一）即：dp[i] [0]，有两个具体操作：</p><ul><li>操作一：前一天就是持有股票状态（状态一），<strong>dp[i] [0] &#x3D; dp[i - 1] [0]</strong></li><li>操作二：今天买入了，有两种情况<ul><li>前一天是冷冻期（状态四），dp[i - 1] [3] - prices[i]</li><li>前一天是保持卖出股票的状态（状态二），dp[i - 1] [1] - prices[i]</li></ul></li></ul><p>那么dp[i] [0] &#x3D; max(dp[i - 1] [0], dp[i - 1] [3] - prices[i], dp[i - 1] [1] - prices[i]);</p><p><strong>达到保持卖出股票状态</strong>（状态二）即：dp[i] [1]，有两个具体操作：</p><ul><li>操作一：前一天就是状态二  dp[i] [1] &#x3D; <strong>dp[i-1] [1]</strong></li><li>操作二：前一天是冷冻期（状态四）dp[i] [1] &#x3D;  <strong>dp[i-1] [3]</strong></li></ul><p>dp[i] [1] &#x3D; max(dp[i - 1] [1], dp[i - 1] [3]);</p><p><strong>达到今天就卖出股票状态</strong>（状态三），即：dp[i] [2] ，只有一个操作：</p><p>昨天一定是持有股票状态（状态一），今天卖出</p><p>即：dp[i] [2] &#x3D; <strong>dp[i - 1] [0] + prices[i];</strong></p><p><strong>达到冷冻期状态</strong>（状态四），即：dp[i] [3]，只有一个操作：</p><p>昨天卖出了股票（状态三）</p><p><strong>dp[i] [3] &#x3D; dp[i - 1] [2];</strong></p><p>综上分析，递推代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) - prices[i]);<span class="hljs-comment">//状态1，保持买入状态：前一天冷冻期，今天买入或者前一天是卖出状态。</span><br>dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>]);<span class="hljs-comment">// 状态2，保持卖出状态：前一天就卖出了，或者前一天冷冻期，今天没操作</span><br>dp[i][<span class="hljs-number">2</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i];<span class="hljs-comment">// 状态3，今天卖出股票：前一天持有股票，今天卖出</span><br>dp[i][<span class="hljs-number">3</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]; <span class="hljs-comment">// 状态4 ，处于冷冻期：则昨天卖出了股票</span><br></code></pre></td></tr></table></figure><p>3、dp数组如何初始化</p><p>dp[0] [0] &#x3D; -prices[0] ：当天买入，收益就是-prices[0]。</p><p>dp[0] [1] &#x3D; 0：当天买入当天卖出，收益不变，为0。</p><p>同理，dp[0] [2] 、dp[0] [3] 都初始化为0.</p><p>4、确定遍历顺序</p><p>从递归公式上可以看出，dp[i] 依赖于 dp[i-1]，所以是从前向后遍历。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = prices.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">4</span>, <span class="hljs-number">0</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] -= prices[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 持股票</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>] - prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] - prices[i]));<br>            dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>]);<br>            dp[i][<span class="hljs-number">2</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i];<br>            dp[i][<span class="hljs-number">3</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>], <span class="hljs-built_in">max</span>(dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]));<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>最后结果是取 状态二，状态三，和状态四的最大值，不少同学会把状态四忘了，状态四是冷冻期，最后一天如果是冷冻期也可能是最大值。</strong></p><h2 id="24、买卖股票的最佳时机含手续费"><a href="#24、买卖股票的最佳时机含手续费" class="headerlink" title="24、买卖股票的最佳时机含手续费"></a>24、买卖股票的最佳时机含手续费</h2><p>每次交易需支付一次手续费，无限次交易。</p><p>对比买卖股票的最佳时机||，只是在卖出操作时计算手续费即可，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices, <span class="hljs-type">int</span> fee)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = prices.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] -= prices[<span class="hljs-number">0</span>]; <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] - prices[i]);<br>            dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i] - fee);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="25、最长上升子序列"><a href="#25、最长上升子序列" class="headerlink" title="25、最长上升子序列"></a>25、最长上升子序列</h2><p><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">https://leetcode.cn/problems/longest-increasing-subsequence/</a></p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p>当前下标i的递增子序列长度，其实和i之前的下表j的子序列长度有关系，那又是什么样的关系呢。</p><p>1、dp[i]的定义</p><p>本题中，正确定义dp数组的含义十分重要。</p><p><strong>dp[i]表示i之前包括i的以nums[i]结尾的最长递增子序列的长度</strong></p><p>为什么一定表示 “以nums[i]结尾的最长递增子序” ，因为我们在做“递增比较”的时候，如果比较 nums[j] 和 nums[i] 的大小，那么两个递增子序列一定分别以nums[j]为结尾 和 nums[i]为结尾， 要不然这个比较就没有意义了，不是尾部元素的比较那么 如何算递增呢。</p><p>2、状态转移方程（递推公式）</p><p>位置i的最长升序子序列等于<strong>j从0到i-1各个位置的最长升序子序列</strong> + 1 的最大值。</p><p>i因此：if (nums[i] &gt; nums[j]) dp[i] &#x3D; max(dp[i], dp[j] + 1);</p><p>3、dp[i]的初始化</p><p>每一个i，对应的dp[i]（即最长递增子序列）起始大小至少都是1.</p><p>4、确定遍历顺序</p><p>dp[i] 是有0到i-1各个位置的最长递增子序列 推导而来，那么遍历i一定是从前向后遍历。</p><p>j其实就是遍历0到i-1，那么是从前到后，还是从后到前遍历都无所谓，只要吧 0 到 i-1 的元素都遍历了就行了。 所以默认习惯 从前向后遍历。</p><p>遍历i的循环在外层，遍历j则在内层，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &gt; nums[j]) dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dp[i] &gt; result) result = dp[i]; <span class="hljs-comment">// 取长的子序列</span><br>&#125;<br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size(), <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] &gt; nums[j]) dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (dp[i] &gt; result) result = dp[i]; <span class="hljs-comment">// 取长的子序列</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="26、最长连续递增序列"><a href="#26、最长连续递增序列" class="headerlink" title="26、最长连续递增序列"></a>26、最长连续递增序列</h2><p><a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">https://leetcode.cn/problems/longest-continuous-increasing-subsequence/</a></p><p>本题与上题的区别在于连续。</p><p>1、确定dp数组（dp table）以及下标的含义</p><p>**dp[i]：以下标i为结尾的连续递增的子序列长度为dp[i]**。</p><p>注意这里的定义，一定是以下标i为结尾，并不是说一定以下标0为起始位置。</p><p>2、确定递推公式</p><p>如果 nums[i] &gt; nums[i - 1]，那么以 i 为结尾的连续递增的子序列长度 一定等于 以i - 1为结尾的连续递增的子序列长度 + 1 </p><p>即：<strong>dp[i] &#x3D; dp[i - 1] + 1</strong>;</p><p><strong>注意这里就体现出和上一道题目的区别！</strong></p><p>因为本题要求连续递增子序列，所以就只要比较nums[i]与nums[i - 1]，而不用去比较nums[j]与nums[i] （j是在0到i之间遍历）。</p><p>3、dp数组如何初始化</p><p>以下标i为结尾的连续递增的子序列长度最少也应该是1，即就是nums[i]这一个元素。</p><p>所以dp[i]应该初始1;</p><p>4、遍历顺序</p><p>从递推公式上可以看出， dp[i + 1]依赖dp[i]，所以一定是从前向后遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    <span class="hljs-keyword">if</span> (nums[i] &gt; nums[i - <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 连续记录</span><br>        dp[i] = dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLengthOfLCIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">1</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size() ,<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[i - <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 连续记录</span><br>                dp[i] = dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (dp[i] &gt; result) result = dp[i];<span class="hljs-comment">//取最大的值。</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="27、最长重复子数组"><a href="#27、最长重复子数组" class="headerlink" title="27、最长重复子数组"></a>27、最长重复子数组</h2><p><a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">https://leetcode.cn/problems/maximum-length-of-repeated-subarray/</a></p><p>给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度，其实就是最长公共子序列。</p><p>1、确定dp数组（dp table）以及下标的含义</p><p>dp[i] [j] ：以下标i - 1为结尾的<strong>A</strong>，和以下标j - 1为结尾的<strong>B</strong>，最长重复子数组长度为dp[i] [j]。 （<strong>特别注意</strong>： “以下标i - 1为结尾的A” 标明一定是 以A[i-1]为结尾的字符串 ）</p><p>dp[i] [j]的定义也就决定着，我们在遍历dp[i] [j]的时候i 和 j都要从1开始。为什么要从i-1和j-1开始，是为了初始化方便。</p><p>2、确定递推公式</p><p>根据dp[i] [j]的定义，dp[i] [j]的状态只能由dp[i - 1] [j - 1]推导出来。</p><p>即当A[i - 1] 和B[j - 1]相等的时候，dp[i] [j] &#x3D; dp[i - 1] [j - 1] + 1;</p><p>根据递推公式可以看出，遍历i 和 j 要从1开始！</p><p>3、dp数组如何初始化</p><p>根据dp[i] [j]的定义，dp[i] [0] 和dp[0] [j]其实都是没有意义的！</p><p>但dp[i] [0] 和dp[0] [j]要初始值，因为 为了方便递归公式dp[i] [j] &#x3D; dp[i - 1] [j - 1] + 1;</p><p>所以dp[i] [0] 和dp[0] [j]初始化为0。</p><p>举个例子A[0]如果和B[0]相同的话，dp[1] [1] &#x3D; dp[0] [0] + 1，只有dp[0] [0]初始为0，正好符合递推公式逐步累加起来。</p><p>4、确定遍历顺序</p><p>外层for循环遍历A，内层for循环遍历B。</p><p>那又有同学问了，外层for循环遍历B，内层for循环遍历A。不行么？</p><p>也行，一样的，我这里就用外层for循环遍历A，内层for循环遍历B了。</p><p>同时题目要求长度最长的子数组的长度。所以在遍历的时候顺便把dp[i] [j]的最大值记录下来。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">dp</span>(nums1.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(nums2.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<span class="hljs-comment">// dp数组的定义以及初始化，这里取num.size()+1,是因为dp数组下标的含义是到[i-1]和[j-1]结尾的最长重复子数组</span><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<span class="hljs-comment">// 记录结果，这里初始化为0，是因为后面会被覆盖。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">1</span>;i&lt;=nums1.<span class="hljs-built_in">size</span>();i++)&#123;<span class="hljs-comment">// &lt;=是因为下标含义是到[i-1]结尾</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=nums2.<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums1[i<span class="hljs-number">-1</span>] == nums2[j<span class="hljs-number">-1</span>])&#123;<br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br>                &#125; <br>                <span class="hljs-keyword">if</span>(dp[i][j] &gt; result) result =dp[i][j];<span class="hljs-comment">//要求长度最长的子数组的长度。所以在遍历的时候顺便把dp[i][j]的最大值记录下来</span><br>            &#125; <br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="28、最长公共子序列"><a href="#28、最长公共子序列" class="headerlink" title="28、最长公共子序列"></a>28、最长公共子序列</h2><p><a href="https://leetcode.cn/problems/longest-common-subsequence/">https://leetcode.cn/problems/longest-common-subsequence/</a></p><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</p><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列</p><p>1、确定dp数组（dp table）以及下标的含义</p><p>dp[i] [j]：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列的<strong>长度</strong>（个数）为dp[i] [j]。这么定义下标是为了初始化方便。</p><p>2、确定递推公式</p><p>主要就是两大情况： text1[i - 1] 与 text2[j - 1]相同，text1[i - 1] 与 text2[j - 1]不相同</p><p>如果text1[i - 1] 与 text2[j - 1]相同，那么找到了一个公共元素，所以dp[i] [j] &#x3D; dp[i - 1] [j - 1] + 1;</p><p>如果text1[i - 1] 与 text2[j - 1]不相同，那就看看text1[0, i - 2]与text2[0, j - 1]的最长公共子序列 和 text1[0, i - 1]与text2[0, j - 2]的最长公共子序列，取最大的。</p><p>即：dp[i] [j] &#x3D; max(dp[i - 1] [j], dp[i] [j - 1]);</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (text1[i - <span class="hljs-number">1</span>] == text2[j - <span class="hljs-number">1</span>]) &#123;<br>    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><p>3、dp数组如何初始化</p><p>先看看dp[i] [0]应该是多少呢？</p><p>test1[0, i-1]和空串的最长公共子序列自然是0，所以dp[i] [0] &#x3D; 0;</p><p>同理dp[0] [j]也是0。</p><p>其他下标都是随着递推公式逐步覆盖，初始为多少都可以，那么就统一初始为0。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(text1.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(text2.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br></code></pre></td></tr></table></figure><p>4、遍历顺序</p><p>从递推公式，可以看出，有三个方向可以推出dp[i] [j]，那么为了在递推的过程中，这三个方向都是经过计算的数值，所以要从前向后，从上到下来遍历这个矩阵。</p><p>代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(text1.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(text2.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= text1.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= text2.<span class="hljs-built_in">size</span>(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (text1[i - <span class="hljs-number">1</span>] == text2[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[text1.<span class="hljs-built_in">size</span>()][text2.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>八股基础</title>
    <link href="/2024/05/10/%E5%85%AB%E8%82%A1%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/05/10/%E5%85%AB%E8%82%A1%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="1、从输入URL到页面展示期间发生了什么？"><a href="#1、从输入URL到页面展示期间发生了什么？" class="headerlink" title="1、从输入URL到页面展示期间发生了什么？"></a>1、从输入URL到页面展示期间发生了什么？</h2><p>（1）<strong>检查缓存</strong>：浏览器收到用户请求后，先检查浏览器缓存里是否有该资源，如果有直接返回；如果没有，进入下一步网络请求。</p><p>（2）<strong>DNS域名解析</strong>：进行网络请求之前需要获取请求域名的IP地址，（HTTP协议）。如果是HTTPS，还需要建立TLS连接。DNS解析时会按照本地浏览器缓存-&gt;本地HOST文件-&gt;路由器缓存-&gt;DNS服务器-&gt;根DNS服务器的顺序查询域名对应IP地址，直到找到为止。</p><p>DNS 中的域名都是用<strong>句点</strong>来分隔的，比如 <code>www.server.com.</code>，这里的句点代表了不同层次之间的<strong>界限</strong>。在域名中，<strong>越靠右</strong>的位置表示其层级<strong>越高</strong>。</p><p>（3）<strong>浏览器与服务器IP建立TCP连接</strong>（可靠传输）：建立连接后，浏览器端构建请求行、请求头等信息，并把和该域名相关的Cookie等数据附加到请求头中，向服务器构建请求信息。（由协议栈（TCP、IP)提供可靠传输–&gt;IP（远程定位）–&gt;MAC（两点传输）–&gt;网卡–&gt;交换机–&gt;路由器）</p><p>（4）<strong>服务器收到请求信息，根据请求生成响应数据，发给浏览器</strong>。</p><p>（5）<strong>浏览器解析服务器的响应数据</strong>：若响应头状态码为301、302，会重新定向到新地址（IP中的ICMP、ARP功能）；若响应数据类型是字节流类型，一般会将请求交给下载管理器；若是HTML类型，会进入下一步渲染流程。</p><p>（6）<strong>浏览器解析HTML文件</strong>，创建DOM树，解析CSS进行样式计算，然后将CSS与DOM合并，构建渲染树，最后布局和绘制渲染树，完成页面展示。</p><h2 id="2、HTTP常见面试题"><a href="#2、HTTP常见面试题" class="headerlink" title="2、HTTP常见面试题"></a>2、HTTP常见面试题</h2><h3 id="（1）什么是HTTP（超文本传输协议）"><a href="#（1）什么是HTTP（超文本传输协议）" class="headerlink" title="（1）什么是HTTP（超文本传输协议）"></a>（1）什么是HTTP（超文本传输协议）</h3><p>超文本：文字、图片、视频的混合体</p><p>传输：计算机世界中实现两点之间传输</p><p>协议：计算机世界里的约定和规范</p><p>即<strong>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</strong></p><h3 id="（2）HTTP常见的状态码有哪些"><a href="#（2）HTTP常见的状态码有哪些" class="headerlink" title="（2）HTTP常见的状态码有哪些"></a>（2）HTTP常见的状态码有哪些</h3><p><code>1xx</code> 类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少。</p><p><code>2xx</code> 类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态。</p><ul><li>「<strong>200 OK</strong>」是最常见的成功状态码，表示一切正常。如果是非 <code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据。</li><li>「<strong>204 No Content</strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</li><li>「<strong>206 Partial Content</strong>」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li></ul><p><code>3xx</code> 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</p><ul><li>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</li><li>「<strong>302 Found</strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</li></ul><p>301 和 302 都会在响应头里使用字段 <code>Location</code>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p><ul><li>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。</li></ul><p><code>4xx</code> 类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</p><ul><li>「<strong>400 Bad Request</strong>」表示客户端请求的报文有错误，但只是个笼统的错误。</li><li>「<strong>403 Forbidden</strong>」表示服务器禁止访问资源，并不是客户端的请求出错。</li><li>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li></ul><p><code>5xx</code> 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</p><ul><li>「<strong>500 Internal Server Error</strong>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</li><li>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li><li>「<strong>502 Bad Gateway</strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li><li>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。</li></ul><h3 id="（3）HTTP的常见字段有哪些"><a href="#（3）HTTP的常见字段有哪些" class="headerlink" title="（3）HTTP的常见字段有哪些"></a>（3）HTTP的常见字段有哪些</h3><p>HOST字段：客户端发送请求时，用来指定服务器的域名。</p><p>Content-Length 字段：服务器在返回数据时，会有 <code>Content-Length</code> 字段，表明本次回应的数据长度。</p><p><strong>HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决“粘包”的问题</strong></p><p>Connection 字段：<code>Connection</code> 字段最常用于客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用。</p><p>Content-Type 字段：<code>Content-Type</code> 字段用于服务器回应时，告诉客户端，本次数据是什么格式。</p><p>Content-Encoding 字段：<code>Content-Encoding</code> 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式。</p><h3 id="（4）-GET和POST有什么区别"><a href="#（4）-GET和POST有什么区别" class="headerlink" title="（4） GET和POST有什么区别"></a>（4） GET和POST有什么区别</h3><p>作用不同：GET用于从服务器获取资源；POST一般用来向服务器提交数据。</p><p>参数传递的方式不同：GET请求一般写在URL中，只接受ASCII字符。POST请求参数一般放在请求体中，对于数据类型也没有限制。</p><p>安全性不同：由于传递参数方式不同，GET请求直接暴露在URL中，一般不用来传递敏感信息。</p><p>参数长度限制不同：GET传输量较小，不能大于2KB；POST传递的数据量较大，一般默认不受限制。</p><p>编码方式不同：GET只进行URL编码，POST支持多种编码方式。</p><p>缓存机制不同：GET请求会被浏览器主动cache，POST不会，需要手动设置。GET请求参数会被完整保留在浏览器历史里，POST中的参数不会被保留。GET产生的URL可以被保存为书签，POST不可以。GET在浏览器回退时是无害的，POST会再次提交请求。</p><p>时间消耗不同：GET产生一个TCP数据包，POST产生两个TCP数据包。</p><p>先说明下安全和幂等的概念：</p><ul><li><p>在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。</p></li><li><p>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。</p></li><li><p><strong>GET 方法就是安全且幂等的</strong>，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，<strong>可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签</strong>。</p></li><li><p><strong>POST</strong> 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等</strong>的。所以，<strong>浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签</strong>。</p></li></ul><h3 id="（5）HTTP的缓存方式"><a href="#（5）HTTP的缓存方式" class="headerlink" title="（5）HTTP的缓存方式"></a>（5）HTTP的缓存方式</h3><p>缓存解决什么问题：减少不必要的网络传输，节约带宽；更快地加载页面，提高响应速度；减少服务器的负载，避免服务过载的情况出现。</p><p>强制缓存：浏览器判断请求的目标资源是否有效命中强缓存，如果命中，则直接从缓存中读取目标资源，无需与服务器通信，也就是说决定是否使用缓存的主动性在于浏览器这边。</p><p>Expires强缓存：设置一个强缓存时间，此时间范围内，从内存中读取并返回，但是因为其判断缓存过期的机制是获取本地时间戳，与之前拿到的资源文件的Expires字段时间进行比较，存在漏洞：如果本地时间不准怎么办，目前已被弃用。</p><p>Cache-Control强缓存：</p><ul><li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；</li><li>浏览器再次请求访问服务器中的该资源时，会先<strong>通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期</strong>，如果没有，则使用该缓存，否则重新请求服务器；</li><li>服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control</li></ul><p>max-age决定客户端资源被缓存多久；s-maxage决定代理服务器缓存多长时间；no-cache表示强制进行协商缓存；no-store表示禁止任何缓存策略；public表示资源既可以被浏览器缓存也可以被代理服务器缓存。private表示资源只能被浏览器缓存，默认为private。</p><p>基于Last-modified的协商缓存：</p><p>首先在服务器端读出资源文件的修改时间，将读出来的修改时间赋值给响应头的last-modified字段，然后设置Cache-Control为no-cache（强制协商缓存），当客户端读取到last-modified的时候，会在下次请求的的头部携带一个If-Modified-Since,即服务器第一次修改的时候给他的时间。之后每次对该资源进行请求，都会带上If-Modified-Since字段，服务器会拿着个字段并再次读取该资源的修改时间，进行比较，决定是读取缓存还是返回新资源。</p><p>缺点：根据修改时间做判断，如果内容没修改那也有可能更新文件修改时间（重命名-再改回来），文件内容没修改但缓存失效了；当文件在极短时间内修改完成，文件修改时间以秒为单位未检测到毫秒级的改变，此时文件内容被修改了，但缓存依然可用，并不发送新文件。-<em>-存在的问题</em></p><p>基于Etag的协商缓存：将原先协商缓存的比较时间戳的形式修改成了比较文件指纹（根据文件内容计算的唯一哈希值），解决了Last-Modified存在的问题。</p><p>第一次请求某资源的时候，服务端读取文件并计算文件指纹，将文件指纹放在响应头的Etag字段中跟随资源一起返回给客户端。第二次请求某资源的时候，客户端从缓存中读取上一次服务端返回的Etag（文件指纹），并赋值给请求头的if-none-match字段，让其跟随请求一起发回服务端。服务端接收到请求头中的if-node-match（上一次的文件指纹），并对目标资源文件再次读取并生成文件指纹，两个文件指纹进行对比，如果吻合，则直接返回304状态码和空的响应并return，如果不吻合，将新的文件指纹存储到Etag并返回给客户端。</p><p>缺点：Etag需要计算文件指纹，服务端需要更多的计算开销，如果文件尺寸大且计算频繁，会影响服务器性能。同时，Etag有强验证和弱验证，强验证需要将生成的哈希码深入到每个字节，文件中只有一个字节被改变，也会生成不同的哈希值，非常消耗服务器资源。弱验证通过提取文件的部分属性来生成哈希值，不必精确到每个字节，速度快，但准确率不高，会降低协商缓存的有效性。</p><h3 id="（6）HTTP1-0与HTTP1-1的区别"><a href="#（6）HTTP1-0与HTTP1-1的区别" class="headerlink" title="（6）HTTP1.0与HTTP1.1的区别"></a>（6）HTTP1.0与HTTP1.1的区别</h3><p>1、长连接</p><p>HTTP1.1支持长连接，每一个TCP连接上可以传送多个HTTP请求和响应，默认开启Connection： Keep-Alive。</p><p>HTTP1.0默认是短连接，每次请求都需要建立一个TCP连接。</p><p>2、缓存</p><p>HTTP1.0主要使用If-Modified_Since、Expires来作为缓存判断标准</p><p>HTTP1.1则引入了更多的缓存控制策略 比如Entity tag、If-None-Match等更多可选择的缓存头来控制缓存策略。</p><p>3、管道化</p><p>基于HTTP1.1的长连接，是的请求管道化成为可能，管道化能使得请求并行传输，但响应必须按照请求发出的顺序依次返回，性能在一定程度上得到了改善。</p><p>4、增加了Host字段</p><p>使得一个服务器可以创建多个web站点。</p><p>5、状态码</p><p>新增了24个错误状态响应码</p><p>6、带宽优化</p><p>HTTP1.0中，存在浪费带宽的现象，例如客户端只是需要某个资源的一部分，但服务器将整个资源对象传输过来，不支持断点续传功能。</p><p>HTTP1.1中加入了range头域，它允许之请求资源的某个部分，返回码是<code>206</code>（Partial content）。</p><h3 id="（7）HTTP2-0与HTTP1-1的区别"><a href="#（7）HTTP2-0与HTTP1-1的区别" class="headerlink" title="（7）HTTP2.0与HTTP1.1的区别"></a>（7）HTTP2.0与HTTP1.1的区别</h3><p>1、二进制分帧</p><p>HTTP2.0在应用层和传输层之间增加了一个二进制分帧层，突破了HTTP1.1的性能限制，改进了传输性能，实现低延迟高吞吐量。</p><p>2、多路复用（MultiPlexing）</p><p>允许通过单一的HTTP2.0连接发起多重的请求-响应消息，这个功能基于“二进制分帧”的特性。</p><p>3、首部压缩</p><p>HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header数据进行压缩。减少了数据体积，使得传输更快。高效的压缩算法可以尽量压缩header，减少发送包的数量从而降低延迟。</p><p>4、服务端推送</p><p>HTTP2.0中，服务器可以对客户端的一个请求发送多个响应，即服务器可以额外的向客户端推送资源，无需客户端明确的请求。</p><h3 id="（8）HTTPS的工作原理（HTTPS是怎么建立连接的）"><a href="#（8）HTTPS的工作原理（HTTPS是怎么建立连接的）" class="headerlink" title="（8）HTTPS的工作原理（HTTPS是怎么建立连接的）"></a>（8）HTTPS的工作原理（HTTPS是怎么建立连接的）</h3><p>首先，客户端向服务器发送请求报文，请求与服务端建立连接。服务端产生应一对公私密钥，然后将自己的公钥发送给CA机构，CA机构也有一对公私秘钥，CA机构使用自己的私钥将服务端发送过来的公钥进行加密，产生一个CA数字证书。（客户端–&gt;服务端&lt;–&gt;CA机构)</p><p>服务端响应客户端的请求，将CA机构生成的数字证书发送给客户端。(服务端–&gt;客户端)</p><p>客户端将服务端发送过来的数字证书进行解析，验证数字证书是否合法，不合法会发送警告，如果合法，取出服务端生成的公钥。客户端取出公钥并生成一个随机码key（对称加密中的秘钥），客户端将加密后的随机码key发送给服务端，作为之后对称加密的秘钥。（客户端–&gt;服务端）</p><p>服务端接收到随机码key（秘钥）后，使用服务端自己的私钥对他解密，然后获得这个随机码key。服务端使用这个随机码key对传输的数据进行加密，然后将加密后的内容发送给客户端。（服务端–&gt;客户端）</p><p>客户端使用自己生成的随机码key（密码）解密服务端发送过来的数据，之后客户端和服务端通过  对称加密传输数据，随机码key作为传输的秘钥。</p><p>（9）HTTPS与HTTP的区别</p><p>1、HTTP是明文传输，HTTPS通过SSL&#x2F;TLS进行加密。</p><p>2、HTTP的端口是80，HTTPS的端口是443</p><p>3、HTTPS需要到CA申请证书</p><p>4、HTTP的连接简单，是无状态的，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全。</p><h3 id="（9）DNS及其查询过程"><a href="#（9）DNS及其查询过程" class="headerlink" title="（9）DNS及其查询过程"></a>（9）DNS及其查询过程</h3><p>DNS（域名管理系统），当用户使用浏览器访问网址的时候，使用的第一个重要协议，解决的是域名和IP地址映射的问题。</p><p>用户在浏览器输入URL地址之后，会先在浏览器缓存中查询是否有该域名对应的IP地址。</p><p>如果浏览器缓存中没有，会去计算机本地的Host文件中查询是否有对应的缓存，是否有该域名对应的IP地址。</p><p>如果Host文件中也没有则会向本地DNS服务器发送一个DNS查询请求。本地DNS解析器没有缓存该域名的解析记录，它会向根DNS服务器发出查询请求，根DNS服务器不负责具体的域名解析，它会告诉本地DNS服务器应该向哪个顶级域DNS服务器发送查询请求。</p><p>本地DNS服务器接着向顶级域DNS服务器发送查询请求，顶级域DNS服务器也不负责具体的域名解析，它会告诉本地DNS服务器前往哪个权威域名DNS服务器发送查询请求。</p><p>本地DNS服务器接着向权威DNS服务器发送查询请求，权威DNS服务器是负责存储特定域名和IP地址映射的服务器。当权威DNS服务器收到查询请求是，会查找“example.com”域名对应的IP地址，并将结果返回给本地DNS服务器。</p><p>本地DNS服务器将收到的IP地址返回给浏览器，并将域名解析结果缓存在本地，以便下次更快响应。</p><h2 id="（10）HTTP多个TCP连接怎么实现"><a href="#（10）HTTP多个TCP连接怎么实现" class="headerlink" title="（10）HTTP多个TCP连接怎么实现"></a>（10）HTTP多个TCP连接怎么实现</h2><p>多个tcp连接是靠某些服务器对Connection： keep-alive的Header的支持。即完成这个HTTP请求之后，不要断开HTTP请求使用的TCP连接，这样的好处是连接可以被重复使用，之后发送的HTTP请求不需要重新建立新的TCP连接，并且SSL的开销也可以避免。</p><h2 id="（11）TCP的keepalive和HTTP的keep-alive是一个东西吗"><a href="#（11）TCP的keepalive和HTTP的keep-alive是一个东西吗" class="headerlink" title="（11）TCP的keepalive和HTTP的keep-alive是一个东西吗"></a>（11）TCP的keepalive和HTTP的keep-alive是一个东西吗</h2><p>HTTP的keep-alive，是由应用层（用户态）实现的，成为HTTP长连接：—<strong>保持成为长连接</strong></p><p>每次请求都要经历这样的过程：建立TCP-&gt;请求资源-&gt;响应资源-&gt;释放连接，这是HTTP短连接，但是这样每次建立连接都只能请求一次资源，所以HTTP通过keep-alive实现了使用同一个TCP连接来发送和接收多个HTTP请求，避免了连接建立和释放的开销，即HTTP长连接。</p><p>TCP的keepalive，是由TCP层（内核态）实现的，称为TCP保活机制。—<strong>判断是否存活</strong></p><p>TCP有一个定时任务倒计时，超时后会触发任务，内容是发送一个探测报文给对端，用来判断对端是否存活。</p><h2 id="12、TCP连接如何确保可靠性"><a href="#12、TCP连接如何确保可靠性" class="headerlink" title="12、TCP连接如何确保可靠性"></a>12、TCP连接如何确保可靠性</h2><p>1、数据块大小控制：应用数据被分割成TCP认为最合适发送的数据块，在传输给网络层，数据块被称为报文段或段。</p><p>2、序列号：TCP给每个数据包指定序列号，接收方根据序列号对数据包进行排序，并根据序列号对数据包进行去重。</p><p>3、校验和：TCP将保持首部和数据的校验和，这是一个端到端的校验和，目的是检测数据在传输过程中的任何变化，如果收到的报文的校验和有误，TCP将丢弃这个报文段和不确认收到此报文段（对面要重新发送或采取别的措施）</p><p>4、流量控制：TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据，当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止数据包丢失。TCP利用滑动窗口实现流量控制。</p><p>5、拥塞控制：当网络拥塞时，减少数据的发送。（有其拥塞控制算法）</p><p>6、确认应答：用过ARQ协议实现。基本原理是每发完一个分组就停止发送，等待对方确认。如果没收到确定就重新发送数据包，直到确认后再发送下一个分组。</p><p>7、超时重传：当TCP发出一个数据段后，启动一个定时器，等待目的端的确认收到这个报文段，如果在定时器时间内没收到，将重新发送这个报文段。 <strong>超时重传时间 RTO 的值应该略大于报文往返 RTT 的值</strong></p><p>还有一种实现重传机制的方式叫：<code>SACK</code>（ Selective Acknowledgment）， <strong>选择性确认</strong>。</p><p>这种方式需要在 TCP 头部「选项」字段里加一个 <code>SACK</code> 的东西，它<strong>可以将已收到的数据的信息发送给「发送方」</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong>。</p><h2 id="13、既然提到了拥塞控制，拥塞控制是怎么实现的？"><a href="#13、既然提到了拥塞控制，拥塞控制是怎么实现的？" class="headerlink" title="13、既然提到了拥塞控制，拥塞控制是怎么实现的？"></a>13、既然提到了拥塞控制，拥塞控制是怎么实现的？</h2><p>拥塞控制算法主要有以下几种：</p><p>1、慢启动</p><p>在连接刚开始时，发送方会逐渐增加发送窗口的大小，以指数增长的速度增加发送窗口的数据量。</p><p>2、拥塞避免</p><p>一旦慢启动阶段过去，发送方进入拥塞避免阶段，在这个阶段，发送方会逐渐增加发送窗口的大小，但增加速率较慢，以线性增长的方式，避免过快增加导致网络拥塞。</p><p>3、超时重传</p><p>如果发送方在超时时间内未收到确认，他会认为数据包丢失，并重传这些数据包。这是拥塞控制的最后手段，用于检测和处理网络中的丢包和拥塞情况。</p><p>4、快速重传</p><p>当发送方发送的数据包丢失或者网络出现拥塞时，接收方会重复发送确认通知（ACK）来通知发送方有数据丢失，当发送方收到三次重复确认时，在超时时间到期内立刻重新发送丢失的数据包，而不是等超时之后再发，这样可以减少网络的拥塞程度。</p><p>5、拥塞窗口调整</p><p>发送方根据网络的拥塞程度动态调整发送窗口的大小，通过监测网络延迟和丢包情况来确定合适的发送速率，以避免网络拥塞。</p><h2 id="14、Cookie和Session是什么，有什么区别？"><a href="#14、Cookie和Session是什么，有什么区别？" class="headerlink" title="14、Cookie和Session是什么，有什么区别？"></a>14、Cookie和Session是什么，有什么区别？</h2><p>Cookie和Session都用于管理用户的状态和身份。</p><p>Cookie通过在客户端记录信息来确定用户身份。</p><p>Session通过在服务器端记录信息确定用户身份。</p><p>1、Cookie</p><p>Cook是存储在用户浏览器中的小型文本文件，用于在用户和服务器之间传递数据。通常服务器会将一个或多个Cookie发送到用户浏览器，然后浏览器将这些Cookie存储在本地。</p><p>服务端在接收到来自客户端浏览器的请求之后，能够通过分析存放于请求头中的Cookie得到客户端特有的信息，从而动态生成与该客户端相对应的内容。</p><p>2、Session</p><p>客户端浏览器访问服务器的时候，服务器把客户端信息以某种新式记录在服务器上，即Session。Session主要用于维护用户登录状态、存储用户的临时数据和上下文信息等。</p><p>3、区别</p><p>存储位置：Cookie存储于用户的浏览器中，Session存储于服务器上。</p><p>数据容量：Cookie存储容量较小，一般为几KB，Session存储容量较大，通常没有固定限制，取决于服务器的配置和资源。</p><p>安全性：Cookie存储于用户浏览器中可以被用户读取和篡改。相比之下，Session存储于服务器上更难被访问和修改。</p><p>传输方式：Cookie在每次HTTP请求中会被自动发送到服务器，而Session ID通常通过Cookie或者URL参数传递。</p><h1 id="C-语言基础"><a href="#C-语言基础" class="headerlink" title="C++语言基础"></a>C++语言基础</h1><h2 id="1、虚函数与纯虚函数的区别"><a href="#1、虚函数与纯虚函数的区别" class="headerlink" title="1、虚函数与纯虚函数的区别"></a>1、虚函数与纯虚函数的区别</h2><ol><li>虚函数就是在普通函数之前加上关键字virtual，他有自己具体的实现。纯虚函数是在虚函数的基础上在表达式后面加上&#x3D;0，且纯虚函数没有具体的实现。具有纯虚函数的类被称为抽象类，抽象类不能实例化对象。重写了纯虚函数的派生类才可以实例化对象。</li><li>子类继承父类时，如果父类有虚函数，子类可以重写父类的虚函数，也可以不重写，不重写时调用的是父类的虚函数。如果父类有纯虚函数，子类必须重写。</li><li>虚函数是一个可以被调用的函数，纯虚函数仅仅是一个API，需要被派生类自行定义。</li></ol><h2 id="2、CPP怎么实现多态？"><a href="#2、CPP怎么实现多态？" class="headerlink" title="2、CPP怎么实现多态？"></a>2、CPP怎么实现多态？</h2><p>1、函数重载：通过在同一个作用域内定义多个同名函数，但是参数类型和数量不同，编译器会根据调用时提供的参数来决定调用哪个函数版本。</p><p>2、运算符重载：允许定义或修改大部分运算符的默认行为。</p><p>3、模板：通过模板函数或模板类，可以编写泛型代码，实现对多种类型的操作，而无需知道这些类型的具体细节。</p><p>4、抽象基类：使用包含纯虚函数的类作为接口，强制派生类提供纯虚函数的具体实现。</p><p>5、动态多态：除了虚函数外，还可以通过指针或引用传递基类类型的对象，而在运行时根据对象的实际类型来调用相应的成员函数，这通常与虚函数一起使用。</p><p>6、静态多态：也称为编译时多态，包括函数重载和模版，由于在编译时已经确定了调用哪个函数，所以称为静态多态。</p><h2 id="3、new-和-malloc的区别"><a href="#3、new-和-malloc的区别" class="headerlink" title="3、new 和 malloc的区别"></a>3、new 和 malloc的区别</h2><p>1、new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。</p><p>  2、使⽤new操作符申请内存分配时⽆须指定内存块的⼤⼩，⽽malloc则需要显式地指出所需内存的尺⼨。 </p><p> 3、opeartor new &#x2F;operator delete可以被᯿载，⽽malloc&#x2F;free并不允许᯿载。 </p><p> 4、new&#x2F;delete会调⽤对象的构造函数&#x2F;析构函数以完成对象的构造&#x2F;析构。⽽malloc则不会  </p><p>5、malloc与free是C++&#x2F;C语⾔的标准库函数,new&#x2F;delete是C++的运算符  </p><p>6、new操作符从⾃由存储区上为对象动态分配内存空间，⽽malloc函数从堆上动态分配内存。</p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="1、进程和线程的区别"><a href="#1、进程和线程的区别" class="headerlink" title="1、进程和线程的区别"></a>1、进程和线程的区别</h2><p>进程是系统进行资源分配和调度的基本单位。</p><p>线程是操作系统能够进行运算调度的最小单位。线程是进程的子任务，是进程内的执行单元。一个进程至少有一个线程，一个进程可以运行多个线程，这些线程共享一块内存。</p><p>资源开销：</p><p>进程：由于每个进程都有独立的内存空间，创建和销毁进程的开销较大。进程间切换需要保存和恢复整个进程的状态，因此上下文切换的开销较高。</p><p>线程：线程共享相同的内存空间，创建和销毁线程的开销较小。线程间切换只需保存和恢复少量的线程上下文，因此上下文的切换开销较小。</p><p>通信与同步:</p><p>进程：由于进程间相互隔离，进程之间的通信需要一些特殊机制，如管道、消息队列、共享内存等方式。</p><p>线程：由于线程共享相同的内存空间，他们之间可以直接访问共享数据，线程间通信更加方便。</p><p>安全性：</p><p>进程：由于进程间相互隔离，一个进程的崩溃不会影响其他进程的稳定性。</p><p>线程：由于线程共享相同的内存空间，一个线程的错误可能会影响整个进程的稳定性。</p><h2 id="2、进程的调度算法你了解多少？"><a href="#2、进程的调度算法你了解多少？" class="headerlink" title="2、进程的调度算法你了解多少？"></a>2、进程的调度算法你了解多少？</h2><p>进程都希望自己能够占用 CPU 进行工作，那么这涉及到前面说过的进程上下文切换。</p><p>一旦操作系统把进程切换到运行状态，也就意味着该进程占用着 CPU 在执行，但是当操作系统把进程切换到其他状态时，那就不能在 CPU 中执行了，于是操作系统会选择下一个要运行的进程，选择一个进程运行这一功能是在操作系统中完成的，通常称为<strong>调度程序</strong></p><p>01、先来先服务调度算法（FCFS）</p><p>顾名思义，先来后到，<strong>每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。</strong></p><p>这似乎很公平，但是当一个长作业先运行了，那么后面的短作业等待的时间就会很长，不利于短作业。</p><p>FCFS 对长作业有利，适用于 CPU 繁忙型作业的系统，而不适用于 I&#x2F;O 繁忙型作业的系统。</p><p>02、最短作业优先调度算法</p><p><strong>最短作业优先（*Shortest Job First, SJF*）调度算法</strong>同样也是顾名思义，它会<strong>优先选择运行时间最短的进程来运行</strong>，这有助于提高系统的吞吐量。</p><p>这显然对长作业不利，很容易造成一种极端现象。比如，一个长作业在就绪队列等待运行，而这个就绪队列有非常多的短作业，那么就会使得长作业不断的往后推，周转时间变长，致使长作业长期不会被运行。</p><p>03、高响应比优先调度算法</p><p>前面两种没有权衡长短作业的利弊，那么，<strong>高响应比优先 （*Highest Response Ratio Next, HRRN*）调度算法</strong>主要是权衡了短作业和长作业。<strong>每次进行进程调度时，先计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行</strong>。</p><p>优先权 &#x3D; （等待时间+要求服务时间）&#x2F;要求服务时间</p><ul><li>如果两个进程的「等待时间」相同时，「要求的服务时间」越短，「响应比」就越高，这样短作业的进程容易被选中运行；</li><li>如果两个进程「要求的服务时间」相同时，「等待时间」越长，「响应比」就越高，这就兼顾到了长作业进程，因为进程的响应比可以随时间等待的增加而提高，当其等待时间足够长时，其响应比便可以升到很高，从而获得运行的机会</li></ul><p>一个进程的要求服务时间是不可预估的，所以高响应比优先调度算法是理想算法，现实中实现不了。</p><p>04、时间片轮转调度算法</p><p>最古老、最简单、最公平且使用最广的算法就是<strong>时间片轮转（*Round Robin, RR*）调度算法</strong>。</p><p><strong>每个进程被分配一个时间段，称为时间片（*Quantum*），即允许该进程在该时间段中运行。</strong></p><ul><li>如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配给另外一个进程；</li><li>如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换；</li></ul><p>另外，时间片的长度就是一个很关键的点：</p><ul><li>如果时间片设得太短会导致过多的进程上下文切换，降低了 CPU 效率；</li><li>如果设得太长又可能引起对短作业进程的响应时间变长。</li></ul><p>一般来说，时间片设为 <code>20ms~50ms</code> 通常是一个比较合理的折中值。</p><p>05、最高优先级调度算法</p><p>前面的「时间片轮转算法」做了个假设，即让所有的进程同等重要，也不偏袒谁，大家的运行时间都一样。</p><p>但是，对于多用户计算机系统就有不同的看法了，它们希望调度是有优先级的，即希望调度程序能<strong>从就绪队列中选择最高优先级的进程进行运行，这称为最高优先级（*Highest Priority First，HPF*）调度算法</strong>。</p><p>进程的优先级可以分为，静态优先级和动态优先级：</p><ul><li>静态优先级：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化；</li><li>动态优先级：根据进程的动态变化调整优先级，比如如果进程运行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升高其优先级，也就是<strong>随着时间的推移增加等待进程的优先级</strong>。</li></ul><p>该算法也有两种处理优先级高的方法，非抢占式和抢占式：</p><ul><li>非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程。</li><li>抢占式：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。</li></ul><p>但是依然有缺点，可能会导致低优先级的进程永远不会运行。</p><p>06、多级反馈队列调度算法</p><p><strong>多级反馈队列（*Multilevel Feedback Queue*）调度算法</strong>是「时间片轮转算法」和「最高优先级算法」的综合和发展。</p><p>顾名思义：</p><ul><li><p>「多级」表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短。</p></li><li><p>「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列；</p></li><li><p>设置了多个队列，赋予每个队列不同的优先级，每个<strong>队列优先级从高到低</strong>，同时<strong>优先级越高时间片越短</strong>；</p></li><li><p>新的进程会被放入到第一级队列的末尾，按先来先服务的原则排队等待被调度，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成；</p></li><li><p>当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行；</p></li></ul><p>可以发现，对于短作业可能可以在第一级队列很快被处理完。对于长作业，如果在第一级队列处理不完，可以移入下次队列等待被执行，虽然等待的时间变长了，但是运行时间也变更长了，所以该算法很好的<strong>兼顾了长短作业，同时有较好的响应时间。</strong></p><h2 id="3、进程间有哪些通信方式"><a href="#3、进程间有哪些通信方式" class="headerlink" title="3、进程间有哪些通信方式?"></a>3、进程间有哪些通信方式?</h2><p>每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以进程之间要通信必须通过内核。</p><p>1、管道（匿名管道</p><p>半双工的通信方式，数据只能单向流动而且只能在具有父子进程关系的进程间使用。使用 <code>fork</code> 创建子进程，<strong>创建的子进程会复制父进程的文件描述符</strong>，这样就做到了两个进程各有两个「 <code>fd[0]</code> 与 <code>fd[1]</code>」，两个进程就可以通过各自的 fd 写入和读取同一个管道文件实现跨进程通信了。</p><p>2、命名管道</p><p>也叫做FIFO，也是半双工通信方式，但是允许无亲缘关系的进程之间的提通信。</p><p><strong>管道这种通信方式效率低，不适合进程间频繁地交换数据</strong>。当然，它的好处，自然就是简单，同时也我们很容易得知管道里的数据已经被另一个进程读取了。</p><p>不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循<strong>先进先出</strong>原则，不支持 lseek 之类的文件定位操作</p><p>3、消息队列</p><p>前面说到管道的通信方式是效率低的，因此管道不适合进程间频繁地交换数据。</p><p>对于这个问题，<strong>消息队列</strong>的通信模式就可以解决。比如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。同理，B 进程要给 A 进程发送消息也是如此。</p><p>再来，<strong>消息队列是保存在内核中的消息链表</strong>，在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。</p><p>消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在，而前面提到的匿名管道的生命周期，是随进程的创建而建立，随进程的结束而销毁。</p><p>消息这种模型，两个进程之间的通信就像平时发邮件一样，你来一封，我回一封，可以频繁沟通了。</p><p>但邮件的通信方式存在不足的地方有两点，<strong>一是通信不及时，二是附件也有大小限制</strong>，这同样也是消息队列通信不足的点。</p><p><strong>消息队列不适合比较大数据的传输</strong>，因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限。在 Linux 内核中，会有两个宏定义 <code>MSGMAX</code> 和 <code>MSGMNB</code>，它们以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度。</p><p><strong>消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销</strong>，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。</p><p>4、共享内存</p><p>消息队列的读取和写入的过程，都会有发生用户态与内核态之间的消息拷贝过程。那<strong>共享内存</strong>的方式，就很好的解决了这一问题。</p><p>现代操作系统，对于内存管理，采用的是虚拟内存技术，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程 A 和 进程 B 的虚拟地址是一样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。</p><p><strong>共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中</strong>。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。</p><p>5、信号量</p><p>用了共享内存通信方式，带来新的问题，那就是如果多个进程同时修改同一个共享内存，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。</p><p>为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，<strong>信号量</strong>就实现了这一保护机制。</p><p><strong>信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据</strong>。</p><p>信号量表示资源的数量，控制信号量的方式有两种原子操作：</p><ul><li>一个是 <strong>P 操作</strong>，这个操作会把信号量减去 1，相减后如果信号量 &lt; 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 &gt;&#x3D; 0，则表明还有资源可使用，进程可正常继续执行。</li><li>另一个是 <strong>V 操作</strong>，这个操作会把信号量加上 1，相加后如果信号量 &lt;&#x3D; 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程；</li></ul><p>P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。</p><p>信号初始化为 <code>1</code>，就代表着是<strong>互斥信号量</strong>，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。</p><p>我们可以初始化信号量为 <code>0</code>，就可以用信号量来实现多进程同步的方式，它可以保证进程 A 应在进程 B 之前执行。</p><p>6、信号</p><p>上面说的进程间通信，都是常规状态下的工作模式。<strong>对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。</strong></p><p>信号跟信号量虽然名字相似度 66.66%，但两者用途完全不一样，就好像 Java 和 JavaScript 的区别。</p><p>在 Linux 操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义。我们可以通过 <code>kill -l</code> 命令，查看所有的信号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">kill</span> -l</span><br> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP<br> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1<br>11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM<br>16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP<br>21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ<br>26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR<br>31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3<br>38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8<br>43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13<br>48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12<br>53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7<br>58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2<br>63) SIGRTMAX-1  64) SIGRTMAX<br></code></pre></td></tr></table></figure><p>运行在 shell 终端的进程，我们可以通过键盘输入某些组合键的时候，给进程发送信号。例如</p><ul><li>Ctrl+C 产生 <code>SIGINT</code> 信号，表示终止该进程；</li><li>Ctrl+Z 产生 <code>SIGTSTP</code> 信号，表示停止该进程，但还未结束；</li></ul><p>如果进程在后台运行，可以通过 <code>kill</code> 命令的方式给进程发送信号，但前提需要知道运行中的进程 PID 号，例如：</p><ul><li>kill -9 1050 ，表示给 PID 为 1050 的进程发送 <code>SIGKILL</code> 信号，用来立即结束该进程；</li></ul><p>所以，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令）。</p><p>信号是进程间通信机制中<strong>唯一的异步通信机制</strong>，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。</p><p><strong>1.执行默认操作</strong>。Linux 对每种信号都规定了默认操作，例如，上面列表中的 SIGTERM 信号，就是终止进程的意思。</p><p><strong>2.捕捉信号</strong>。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。</p><p><strong>3.忽略信号</strong>。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 <code>SIGKILL</code> 和 <code>SEGSTOP</code>，它们用于在任何时候中断或结束某一进程。</p><p>7、socket套接字</p><p>前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想<strong>跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。</strong></p><p>实际上，Socket 通信不仅可以跨网络与不同主机的进程间通信，还可以在同主机上进程间通信。</p><p>我们来看看创建 socket 的系统调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">socket</span><span class="hljs-params">(<span class="hljs-type">int</span> domain, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span> protocal)</span><br></code></pre></td></tr></table></figure><p>三个参数分别代表：</p><ul><li>domain 参数用来指定协议族，比如 AF_INET 用于 IPV4、AF_INET6 用于 IPV6、AF_LOCAL&#x2F;AF_UNIX 用于本机；</li><li>type 参数用来指定通信特性，比如 SOCK_STREAM 表示的是字节流，对应 TCP、SOCK_DGRAM 表示的是数据报，对应 UDP、SOCK_RAW 表示的是原始套接字；</li><li>protocal 参数原本是用来指定通信协议的，但现在基本废弃。因为协议已经通过前面两个参数指定完成，protocol 目前一般写成 0 即可；</li></ul><p>根据创建 socket 类型的不同，通信的方式也就不同：</p><ul><li>实现 TCP 字节流通信： socket 类型是 AF_INET 和 SOCK_STREAM；</li><li>实现 UDP 数据报通信：socket 类型是 AF_INET 和 SOCK_DGRAM；</li><li>实现本地进程间通信： 「本地字节流 socket 」类型是 AF_LOCAL 和 SOCK_STREAM，「本地数据报 socket 」类型是 AF_LOCAL 和 SOCK_DGRAM。另外，AF_UNIX 和 AF_LOCAL 是等价的，所以 AF_UNIX 也属于本地 socket；</li></ul><p>总结</p><p>由于每个进程的用户空间都是独立的，不能相互访问，这时就需要借助内核空间来实现进程间通信，原因很简单，每个进程都是共享一个内核空间。</p><p>Linux 内核提供了不少进程间通信的方式，其中最简单的方式就是管道，管道分为「匿名管道」和「命名管道」。</p><p><strong>匿名管道</strong>顾名思义，它没有名字标识，匿名管道是特殊文件只存在于内存，没有存在于文件系统中，shell 命令中的「<code>|</code>」竖线就是匿名管道，通信的数据是<strong>无格式的流并且大小受限</strong>，通信的方式是<strong>单向</strong>的，数据只能在一个方向上流动，如果要双向通信，需要创建两个管道，再来<strong>匿名管道是只能用于存在父子关系的进程间通信</strong>，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失。</p><p><strong>命名管道</strong>突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用命名管道的前提，需要在文件系统创建一个类型为 p 的设备文件，那么毫无关系的进程就可以通过这个设备文件进行通信。另外，不管是匿名管道还是命名管道，进程写入的数据都是<strong>缓存在内核</strong>中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循<strong>先进先出</strong>原则，不支持 lseek 之类的文件定位操作。</p><p><strong>消息队列</strong>克服了管道通信的数据是无格式的字节流的问题，消息队列实际上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数据类型，发送数据时，会被分成一个一个独立的消息体，当然接收数据时，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的数据是正确的。消息队列通信的速度不是最及时的，毕竟<strong>每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程。</strong></p><p><strong>共享内存</strong>可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，<strong>它直接分配一个共享空间，每个进程都可以直接访问</strong>，就像访问进程自己的空间一样快捷方便，不需要陷入内核态或者系统调用，大大提高了通信的速度，享有<strong>最快</strong>的进程间通信方式之名。但是便捷高效的共享内存通信，<strong>带来新的问题，多进程竞争同个共享资源会造成数据的错乱。</strong></p><p>那么，就需要<strong>信号量</strong>来保护共享资源，以确保任何时刻只能有一个进程访问共享资源，这种方式就是互斥访问。<strong>信号量不仅可以实现访问的互斥性，还可以实现进程间的同步</strong>，信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 <strong>P 操作和 V 操作</strong>。</p><p>与信号量名字很相似的叫<strong>信号</strong>，它俩名字虽然相似，但功能一点儿都不一样。信号是<strong>异步通信机制</strong>，信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令），一旦有信号发生，<strong>进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、3. 忽略信号</strong>。有两个信号是应用进程无法捕捉和忽略的，即 <code>SIGKILL</code> 和 <code>SIGSTOP</code>，这是为了方便我们能在任何时候结束或停止某个进程。</p><p>前面说到的通信机制，都是工作于同一台主机，如果<strong>要与不同主机的进程间通信，那么就需要 Socket 通信了</strong>。Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。</p><p>以上，就是进程间通信的主要机制了。你可能会问了，那线程通信间的方式呢？</p><p>同个进程下的线程之间都是共享进程的资源，只要是共享变量都可以做到线程间通信，比如全局变量，所以对于线程间关注的不是通信方式，而是关注多线程竞争共享资源的问题，信号量也同样可以在线程间实现互斥与同步：</p><ul><li>互斥的方式，可保证任意时刻只有一个线程访问共享资源；</li><li>同步的方式，可保证线程 A 应在线程 B 之前执行；</li></ul><h2 id="4、什么是死锁以及如何避免死锁？"><a href="#4、什么是死锁以及如何避免死锁？" class="headerlink" title="4、什么是死锁以及如何避免死锁？"></a>4、什么是死锁以及如何避免死锁？</h2><p><strong>死锁是指两个或多个线程在争夺系统资源时，由于相互等待对方释放资源而无法继续执行的状态。</strong></p><p>在多线程编程中，我们为了防止多线程竞争共享资源而导致数据错乱，都会在操作共享资源之前加上互斥锁，只有成功获得到锁的线程，才能操作共享资源，获取不到锁的线程就只能等待，直到锁被释放。</p><p>那么，当两个线程为了保护两个不同的共享资源而使用了两个互斥锁，那么这两个互斥锁应用不当的时候，可能会造成<strong>两个线程都在等待对方释放锁</strong>，在没有外力的作用下，这些线程会一直相互等待，就没办法继续运行，这种情况就是发生了<strong>死锁</strong></p><p>死锁只有<strong>同时满足</strong>以下四个条件才会发生：</p><ul><li>互斥条件：多个线程不能同时使用同一个资源</li><li>持有并等待条件：一个线程因为请求另外的资源被阻塞的时候，不会释放自己目前持有的资源。</li><li>不可剥夺条件：资源不能被强制性的从一个进程中夺走，只能由持有者资源释放释放。</li><li>环路等待条件：多个进程之间形成一个环形等待资源的链路，每个进程都在等待下一个进程释放自己所占有的资源</li></ul><p>只要破坏上面任意一个条件就可以破坏死锁。</p><p>破坏请求与保持条件：一次性申请所有的资源</p><p>破坏不可剥夺条件：占用资源的线程在申请其他资源被堵塞时，可以主动释放他已经占有的资源。</p><p>破坏循环等待条件：使用资源有序分配法，让所有进程按照相同的顺序请求资源，释放资源则反序释放。</p><p>总结：</p><p>简单来说，死锁问题的产生是由两个或者以上线程并行执行的时候，争夺资源而互相等待造成的。</p><p>死锁只有同时满足互斥、持有并等待、不可剥夺、环路等待这四个条件的时候才会发生。</p><p>所以要避免死锁问题，就是要破坏其中一个条件即可，<strong>最常用的方法就是使用资源有序分配法来破坏环路等待条件</strong></p><h2 id="5、什么是虚拟内存，为什么需要虚拟内存？"><a href="#5、什么是虚拟内存，为什么需要虚拟内存？" class="headerlink" title="5、什么是虚拟内存，为什么需要虚拟内存？"></a><strong>5、什么是虚拟内存，为什么需要虚拟内存？</strong></h2><p>虚拟内存在每一个进程创建加载的过程中，会分配一个连续的虚拟地址空间，他不是真实存在的，而是通过映射与实际地址空间对应，这样就可以是每个进程看起来都有自己独立的连续地址空间，并允许程序访问比物理内存更大的地址空间，每个程序都可以认为它拥有足够大的内存来运行。</p><p>需要虚拟内存有以下原因：</p><p>内存扩展：虚拟内存使得每个程序可以使用比实际可用内存更大的内存，从而允许运行更大的程序或处理更多的数据。</p><p>内存隔离：虚拟内存还提供了进程之间的内存隔离，每个进程都有自己的虚拟地址空间，因此一个进程无法直接访问另一个进程的内存。</p><p>物理内存管理：虚拟内存允许操作系统动态的将数据和程序的部分加载到物理内存中，以满足当前正在运行的进程的需求。当物理内存不足时，操作系统可以将不常用的数据或程序暂时移到硬盘上，从而释放内存，以便其他进程使用。</p><p>页面交换：当物理内存不足时，操作系统可以将一部分数据从物理内存写入到硬盘的虚拟内存中，这个过程被称为页面交换，当需要时，数据可以再次从虚拟内存中加载到物理内存中。这样可以保证系统可以继续运行，尽管物理内存有限。</p><p>内存映射文件：虚拟内存还可以用于将文件映射到内存中，这使得文件的读取和写入可以像访问内存一样高效。</p><h2 id="6、什么是内存分段和内存分页，作用是什么？"><a href="#6、什么是内存分段和内存分页，作用是什么？" class="headerlink" title="6、什么是内存分段和内存分页，作用是什么？"></a>6、什么是内存分段和内存分页，作用是什么？</h2><p><strong>核心功能是管理虚拟地址与物理地址的之间的映射关系</strong>。</p><p><strong>内存分段</strong>：将一个程序的内存空间分为不同的逻辑段（segments），每个段代表程序的一个功能模块或者数据类型，比如代码段、数据段、堆栈段等。每个段都有其自己的大小和权限。</p><p><strong>内存分页</strong>：把整个虚拟和物理空间分成固定大小的页（4KB），这样一个连续且大小固定的内存空间，称之为页。</p><p>作用：</p><p>1、<strong>逻辑隔离</strong>：内存分段和分页都实现了程序的逻辑隔离，使不同的功能模块或数据类型能够被单独的管理和保护，提高了程序的可靠性与安全性。</p><p>2、<strong>内存保护</strong>：通过将不同的段或页面设置为只读、可读写、不可执行等权限，操作系统可以确保程序不会越界访问或修改其他段的内容，从而提高了系统的稳定性。</p><p>3、<strong>虚拟内存</strong>：分段和分页都是为了实现虚拟内存的概念，允许应用程序认为他们使用的是一个比实际物理内存更大的内存空间。</p><p>4、<strong>内存共享</strong>：通过分页，操作系统可以实现内存页面的共享，从而节省内存空间，多个进程可以共享相同的代码段或数据页面。</p><p>5、<strong>内存管理</strong>：分页更加灵活，允许操作系统将不同进程的页面分散存放在物理内存中，从而提高内存利用率。分段则更适用于管理不同的逻辑模块。</p><p>分段和分页的区别：</p><p>分页对用户不可见，分段对用户可见。</p><p>分页的地址空间是一维的，分段的地址空间是二维的。</p><p>分页（单级页表）以及分段访问一个逻辑地址都需要两次访存，分段存储中可以引入快表机制</p><p>分段更容易实现信息的共享和保护</p><p>分段与分页的优缺点：</p><p>分页：内存空间利用率高，不会产生外部碎片，只会有少量的页内碎片，但不方便按照逻辑模块实现信息的共享与保护。</p><p>分段：方便按照逻辑模块实现信息的共享与保护，但是如果段长过大，为其分配很大的连续空间很不方便，且会产生外部碎片。</p><p><strong>7、解释一下用户态和内核态</strong></p><p><strong>用户态和内核态是操作系统中两种不同的执行模式，用于控制进程或程序对计算机硬件资源的访问权限和操作范围。</strong></p><p>用户态：在用户态下，进程或程序只能访问受限的资源和执行受限的指令集，不能直接访问操作系统的核心部分，也不能直接访问硬件资源，用户态下的CPU不能独占，允许被其他程序获取。</p><p>内核态：内核态是操作系统的特权级别，允许进程或程序执行特权指令和访问操作系统的核心部分。在内核态下，进程可以直接访问硬件资源，执行系统调用，管理内存、文件系统等操作。处于内核态的CPU可以从一个程序切换到另一个程序，并且占用CPU不会发生被抢占的情况。</p><p>用户空间的代码只能访问一个局部的内存空间，而内核空间的代码可以访问所有内存空间。因此，当程序使用用户空间时，我们常说该程序在<strong>用户态</strong>执行，而当程序使内核空间时，程序则在<strong>内核态</strong>执行。<strong>应用程序如果需要进入内核空间，就需要通过系统调用</strong>，内核程序执行在内核态，用户程序执行在用户态。<strong>当应用程序使用系统调用时，会产生一个中断</strong>。发生中断后， CPU 会中断当前在执行的用户程序，转而跳转到中断处理程序，也就是开始执行内核程序。内核处理完后，主动触发中断，把 CPU 执行权限交回给用户程序，回到用户态继续工作。</p><p>8、解释一下页面置换算法，例如LRU，FIFO等</p><p>在了解内存页面置换算法前，我们得先谈一下<strong>缺页异常（缺页中断）</strong>。</p><p>当 CPU 访问的页面不在物理内存时，便会产生一个缺页中断，请求操作系统将所缺页调入到物理内存。那它与一般中断的主要区别在于：</p><ul><li>缺页中断在指令执行「期间」产生和处理中断信号，而一般中断在一条指令执行「完成」后检查和处理中断信号。</li><li>缺页中断返回到该指令的开始重新执行「该指令」，而一般中断返回回到该指令的「下一个指令」执行。</li></ul><p><strong>缺页中断的处理流程</strong>：</p><ol><li>在 CPU 里访问一条 Load M 指令，然后 CPU 会去找 M 所对应的页表项。</li><li>如果该页表项的状态位是「有效的」，那 CPU 就可以直接去访问物理内存了，如果状态位是「无效的」，则 CPU 则会发送缺页中断请求。</li><li>操作系统收到了缺页中断，则会执行缺页中断处理函数，先会查找该页面在磁盘中的页面的位置。</li><li>找到磁盘中对应的页面后，需要把该页面换入到物理内存中，但是在换入前，需要在物理内存中找空闲页，如果找到空闲页，就把页面换入到物理内存中。</li><li>页面从磁盘换入到物理内存完成后，则把页表项中的状态位修改为「有效的」。</li><li>最后，CPU 重新执行导致缺页异常的指令。</li></ol><p>上面所说的过程，第 4 步是能在物理内存找到空闲页的情况，那如果找不到呢？</p><p>找不到空闲页的话，就说明此时内存已满了，这时候，就需要「页面置换算法」选择一个物理页，如果该物理页有被修改过（脏页），则把它换出到磁盘，然后把该被置换出去的页表项的状态改成「无效的」，最后把正在访问的页面装入到这个物理页中。如果没有修改，在置换该页时就不需要将该页写回到磁盘上，以减少系统的开销。</p><p>所以，页面置换算法的功能是，<strong>当出现缺页异常，需调入新页面而内存已满时，选择被置换的物理页面</strong>，也就是说选择一个物理页面换出到磁盘，然后把需要访问的页面换入到物理页，算法的目标是尽量减少页面的换入换出次数，减少系统的开销。</p><p>1、最佳置换算法</p><p>根据未来页面的访问情况，选择最长时间内不会被访问到的页面进行置换。那么就产生一个问题了，未来要访问什么页面操作系统如何未卜先知呢？所以该算法属于理想情况，用来衡量算法的优劣，越接近该算法的效率越高。</p><p>2、先进先出置换算法</p><p><strong>选择在内存驻留时间很长的页面进行中置换</strong>，这个就是「先进先出置换」算法的思想。但是FIFO算法可能会淘汰经常被使用的角色，导致切换次数增加。而且FIFO算法有可能出现贝拉迪异常：当分配给内存的空间增加时，切换次数反而增加了。</p><p>3、最近最久未使用算法（最近最少使用）</p><p>最近最久未使用（<em>LRU</em>）的置换算法的基本思路是，发生缺页时，<strong>选择最长时间没有被访问的页面进行置换</strong>，也就是说，该算法假设已经很久没有使用的页面很有可能在未来较长的一段时间内仍然不会被使用。</p><p>虽然 LRU 在理论上是可以实现的，但代价很高。为了完全实现 LRU，需要在内存中维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。困难的是，在每次访问内存时都必须要更新「整个链表」。在链表中找到一个页面，删除它，然后把它移动到表头是一个非常费时的操作。</p><p>所以，LRU 虽然看上去不错，但是由于开销比较大，实际应用中比较少使用。</p><p>4、时钟页面置换算法</p><p>那有没有一种即能优化置换的次数，也能方便实现的算法呢？</p><p><strong>时钟页面置换算法就可以两者兼得，它跟 LRU 近似，又是对 FIFO 的一种改进。</strong></p><p>该算法的思路是，把所有的页面都保存在一个类似钟面的「环形链表」中，一个表针指向最老的页面。</p><p>当发生缺页中断时，算法首先检查表针指向的页面：</p><ul><li>如果它的访问位位是 0 就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置；</li><li>如果访问位是 1 就清除访问位，并把表针前移一个位置，重复这个过程直到找到了一个访问位为 0 的页面为止；</li></ul><p>5、最不常用算法（LFU）</p><p><strong>当发生缺页中断时，选择「访问次数」最少的那个页面，并将其淘汰</strong>。</p><p>它的实现方式是，对每个页面设置一个「访问计数器」，每当一个页面被访问时，该页面的访问计数器就累加 1。在发生缺页中断时，淘汰计数器值最小的那个页面。</p><p>看起来很简单，每个页面加一个计数器就可以实现了，但是在操作系统中实现的时候，我们需要考虑效率和硬件成本的。</p><p>要增加一个计数器来实现，这个硬件成本是比较高的，另外如果要对这个计数器查找哪个页面访问次数最小，查找链表本身，如果链表长度很大，是非常耗时的，效率不高。</p><p>但还有个问题，LFU 算法只考虑了频率问题，没考虑时间的问题，比如有些页面在过去时间里访问的频率很高，但是现在已经没有访问了，而当前频繁访问的页面由于没有这些页面访问的次数高，在发生缺页中断时，就会可能会误伤当前刚开始频繁访问，但访问次数还不高的页面。</p><h2 id="7、解释一下进程同步和互斥，以及解决这些问题的方法？"><a href="#7、解释一下进程同步和互斥，以及解决这些问题的方法？" class="headerlink" title="7、解释一下进程同步和互斥，以及解决这些问题的方法？"></a>7、解释一下进程同步和互斥，以及解决这些问题的方法？</h2><p>互斥：在某一时刻只允许一个进程访问某个共享资源，当一个进程正在使用共享资源时，其他进程不能同时访问改共享资源。</p><p>进程同步：多个并发执行的进程之间协调和管理他们的执行顺序，以确保他们按照一定的顺序或时间间隔执行。</p><ul><li>同步就好比：「操作 A 应在操作 B 之前执行」，「操作 C 必须在操作 A 和操作 B 都完成之后才能执行」等；</li><li>互斥就好比：「操作 A 和操作 B 不能在同一时刻执行」</li></ul><p>临界区：将可能引发互斥问题的代码段称为临界区，为了实现互斥，每个进程在进入临界区前必须获取一个锁，退出临界区后释放该锁。确保同一时间只有一个进程可以进入临界区。</p><p>互斥锁：互斥锁是一种同步机制，用于实现互斥。每个共享资源都关联一个互斥锁，进程在访问该资源前需要获取互斥锁，使用完之后释放互斥锁，只有获得互斥锁的进程才能访问资源。</p><p>信号量：参考3.</p><p>信号初始化为 <code>1</code>，就代表着是<strong>互斥信号量</strong>，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。</p><p>我们可以初始化信号量为 <code>0</code>，就可以用信号量来实现多进程同步的方式，它可以保证进程 A 应在进程 B 之前执行。</p><h2 id="8、什么是中断和异常？二者有何区别？"><a href="#8、什么是中断和异常？二者有何区别？" class="headerlink" title="8、什么是中断和异常？二者有何区别？"></a>8、什么是中断和异常？二者有何区别？</h2><p>中断和异常是两种不同的事件，他们都会导致CPU暂停当前的程序执行，转而去执行一个特定的处理程序。</p><p>区别：</p><p><strong>中断是由外部设备或其他处理器产生的</strong>，通常是异步的，也就是说中断可以在任何时候发生。与当前执行的指令无关，比如键盘输入，鼠标移动等都会触发中断通知CPU去处理这些事件。</p><p><strong>异常是由CPU内部产生的</strong>，通常是同步的，也就是说只会在执行某些指令时发生，与当前执行的指令有关。比如访问非法内存地址，除数为零、执行非法指令等都会产生异常信号，通知CPU去处理这些错误或故障。</p><p><strong>中断可以被屏蔽或者禁止</strong>，意味着CPU可以通过设置某些标志位或寄存器来忽略或延迟响应某些中断信号。可以避免中断过于频繁或干扰重要的任务。</p><p><strong>异常不能被屏蔽或者禁止</strong>，意味着CPU必须立即响应异常信号，并进行相应的处理，这样可以保证程序的正确性和系统的稳定性。</p><p>中断的定义：CPU在执行指令时，收到某个中断信号转而去执行预先设定好的代码，然后再返回到原指令中继续执行，这就是中断机制。</p><p>中断的作用：</p><p>1、外设异步通知CPU，外设发生了什么事情或者完成了什么任务都可以通过中断异步通知CPU。</p><p>2、CPU之间发送消息，在SMP系统中，一个CPU想给另一个CPU发送消息，可以使用IPI（处理器间中断）。</p><p>3、处理CPU异常，CPU在执行指令的过程中遇到了异常会给自己发送中断信号来处理异常。</p><p>4、实现系统调用，早期的系统调用就是靠中断来实现的，后期虽然开发了专用的系统调用指令，但其基本原理还是相似的。</p><p>中断的产生：</p><p>1、外设（硬件中断），外设产生的中断信号时<strong>异步的</strong>，按照是否可以屏蔽分为可屏蔽中断和不可屏蔽中断。网卡、磁盘、定时器都可以产生硬件中断。</p><p>2、CPU，处理器间中断（IPI），可以看做一种特殊的硬件中断，<strong>异步</strong>。</p><p>3、CPU异常，<strong>同步的</strong>，在处理指令的过程中发现异常，会向自己发送中断信号，也叫做软件中断。CPU异常分为三类：</p><p>陷阱：不需要修复，中断处理完成后重新执行之前的指令。</p><p>故障：需要修复也有可能修复，中断处理完成后重新执行之前的指令。</p><p>中止：需要修复但是无法修复，中断处理完成后，进程或者内核将会崩溃。</p><p>4、中断指令，直接用CPU指令来产生中断信号，这种中断和CPU异常一样是<strong>同步的</strong>，也也可以叫做软件中断。</p><h2 id="9、介绍一下几种典型的锁"><a href="#9、介绍一下几种典型的锁" class="headerlink" title="9、介绍一下几种典型的锁"></a>9、介绍一下几种典型的锁</h2><p>加锁的目的就是保证共享资源在任意时间里，只有一个线程访问，这样就可以避免多线程导致共享数据错乱的问题。</p><p>两个基本的锁</p><p>1、互斥锁：一种最常见的锁类型，用于实现互斥访问共享资源。在任何时刻，只有一个线程可以持有互斥锁，其他线程必须等待直到锁被释放，确保了同一时间只有一个线程能够访问被保护的资源。</p><p>2、自旋锁：基于忙等待的锁，线程在尝试获取锁时会不断轮训，直到锁被释放。</p><ul><li><strong>互斥锁</strong>加锁失败后，线程会<strong>释放 CPU</strong> ，给其他线程；</li><li><strong>自旋锁</strong>加锁失败后，线程会<strong>忙等待</strong>，直到它拿到锁；</li></ul><p>其他的锁基于这两种锁</p><p>3、读写锁：允许多个线程同时共享资源，只允许一个线程进行写操作，读（共享）写（独占）两种状态。</p><p>4、悲观锁：认为多线程同时修改共享资源的概率比较高，所以访问资源时要上锁。</p><p>5、乐观锁：先不管，修改了共享资源再说，如果出现同时修改的情况，放弃本次操作。</p><p><strong>总结：</strong></p><p>开发过程中，最常见的就是互斥锁的了，互斥锁加锁失败时，会用「线程切换」来应对，当加锁失败的线程再次加锁成功后的这一过程，会有两次线程上下文切换的成本，性能损耗比较大。</p><p>如果我们明确知道被锁住的代码的执行时间很短，那我们应该选择开销比较小的自旋锁，因为自旋锁加锁失败时，并不会主动产生线程切换，而是一直忙等待，直到获取到锁，那么如果被锁住的代码执行时间很短，那这个忙等待的时间相对应也很短。</p><p>如果能区分读操作和写操作的场景，那读写锁就更合适了，它允许多个读线程可以同时持有读锁，提高了读的并发性。根据偏袒读方还是写方，可以分为读优先锁和写优先锁，读优先锁并发性很强，但是写线程会被饿死，而写优先锁会优先服务写线程，读线程也可能会被饿死，那为了避免饥饿的问题，于是就有了公平读写锁，它是用队列把请求锁的线程排队，并保证先入先出的原则来对线程加锁，这样便保证了某种线程不会被饿死，通用性也更好点。</p><p>互斥锁和自旋锁都是最基本的锁，读写锁可以根据场景来选择这两种锁其中的一个进行实现。</p><p>另外，互斥锁、自旋锁、读写锁都属于悲观锁，悲观锁认为并发访问共享资源时，冲突概率可能非常高，所以在访问共享资源前，都需要先加锁。</p><p>相反的，如果并发访问共享资源时，冲突概率非常低的话，就可以使用乐观锁，它的工作方式是，在访问共享资源时，不用先加锁，修改完共享资源后，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。</p><p>但是，一旦冲突概率上升，就不适合使用乐观锁了，因为它解决冲突的重试成本非常高。</p><p>不管使用的哪种锁，我们的加锁的代码范围应该尽可能的小，也就是加锁的粒度要小，这样执行速度会比较快。再来，使用上了合适的锁，就会快上加快了。</p><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="1、一条SQL查询语句是如何执行的？"><a href="#1、一条SQL查询语句是如何执行的？" class="headerlink" title="1、一条SQL查询语句是如何执行的？"></a>1、一条SQL查询语句是如何执行的？</h2><p>1、连接器：负责跟客户端建立连接，获取权限、维持和管理连接。</p><ul><li><p>与客户端进行 TCP 三次握手建立连接；</p></li><li><p>校验客户端的用户名和密码，如果用户名或密码不对，则会报错；</p></li><li><p>如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限；</p></li></ul><p>2、查询缓存：如果 SQL 是查询语句（select 语句），MySQL 就会先去查询缓存（ Query Cache ）里查找缓存数据，看看之前有没有执行过这一条命令，这个查询缓存是以 key-value 形式保存在内存中的，key 为 SQL 查询语句，value 为 SQL 语句查询的结果。</p><p>如果查询的语句命中查询缓存，那么就会直接返回 value 给客户端。如果查询的语句没有命中查询缓存中，那么就要往下继续执行，等执行完后，查询的结果就会被存入查询缓存中。</p><p>PS：对于更新比较频繁的表，查询缓存的命中率很低的，因为只要一个表有更新操作，那么这个表的查询缓存就会被清空。如果刚缓存了一个查询结果很大的数据，还没被使用的时候，刚好这个表有更新操作，查询缓冲就被清空了，相当于缓存了个寂寞。<strong>所以，MySQL 8.0 版本直接将查询缓存删掉了，也就是说 MySQL 8.0 开始，执行一条 SQL 查询语句，不会再走到查询缓存这个阶段了</strong>。</p><p>3、解析SQL：解析器做的第一件事情，<strong>词法分析</strong>。MySQL 会根据你输入的字符串识别出关键字出来，第二件事情，<strong>语法分析</strong>，根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法，如果没问题就会构建出 SQL 语法树，这样方便后面模块获取 SQL 类型、表名、字段名、 where 条件等等。</p><p>4、执行SQL：</p><p>经过解析器后，接着就要进入执行 SQL 查询语句的流程了，每条<code>SELECT</code> 查询语句流程主要可以分为下面这三个阶段：</p><ul><li>prepare 阶段，也就是预处理阶段；</li><li>optimize 阶段，也就是优化阶段；</li><li>execute 阶段，也就是执行阶段；</li></ul><p><strong>预处理器</strong>：我们先来说说预处理阶段做了什么事情。</p><ul><li><p>检查 SQL 查询语句中的表或者字段是否存在；</p></li><li><p>将 <code>select *</code> 中的 <code>*</code> 符号，扩展为表上的所有列；</p></li></ul><p><strong>优化器</strong>：经过预处理阶段后，还需要为 SQL 查询语句先制定一个执行计划，这个工作交由「优化器」来完成的。</p><p><strong>优化器主要负责将 SQL 查询语句的执行方案确定下来</strong>，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。</p><p>举例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> product <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span>  <span class="hljs-keyword">and</span> name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;i%&#x27;</span>;<br></code></pre></td></tr></table></figure><p>这条查询语句的结果既可以使用主键索引，也可以使用普通索引，但是执行的效率会不同。这时，就需要优化器来决定使用哪个索引了。</p><p>很显然这条查询语句是<strong>覆盖索引</strong>，直接在二级索引就能查找到结果（因为二级索引的 B+ 树的叶子节点的数据存储的是主键值），就没必要在主键索引查找了，<strong>因为查询主键索引的 B+ 树的成本会比查询二级索引的 B+ 的成本大</strong>，优化器基于查询成本的考虑，会选择查询代价小的普通索引。</p><p><strong>执行器</strong>：经历完优化器后，就确定了执行方案，接下来 MySQL 就真正开始执行语句了，这个工作是由「执行器」完成的。在执行的过程中，执行器就会和存储引擎交互了，交互是以记录为单位的。</p><p>总结：</p><p>执行一条 SQL 查询语句，期间发生了什么？</p><ul><li>连接器：建立连接，管理连接、校验用户身份；</li><li>查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；</li><li>解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；</li><li>执行 SQL：执行 SQL 共有三个阶段：<ul><li>预处理阶段：检查表或字段是否存在；将 <code>select *</code> 中的 <code>*</code> 符号扩展为表上的所有列。</li><li>优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；</li><li>执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</li></ul></li></ul><h2 id="2、什么是索引"><a href="#2、什么是索引" class="headerlink" title="2、什么是索引"></a>2、什么是索引</h2><p>索引的定义就是帮助存储引擎快速获取数据的一种数据结构，形象的说就是索引是数据的目录。</p><h2 id="3、索引的分类"><a href="#3、索引的分类" class="headerlink" title="3、索引的分类"></a>3、索引的分类</h2><p>我们可以按照四个角度来分类索引。</p><ul><li><p>按「数据结构」分类：</p><p><strong>B+tree索引</strong>:所有数据存放在叶子结点，适合范围查询。</p><p><strong>Hash索引</strong>：适合等值查询，检索效率高，一次到位。</p><p><strong>Full-text索引</strong>：一般在文本类型char、text、varchar上创建。</p></li><li><p>按「物理存储」分类：</p><p><strong>聚簇索引（主键索引）</strong>：主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；</p><p><strong>二级索引（辅助索引）</strong>：二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。</p><p>所以，在查询时使用了二级索引，如果查询的数据能在二级索引里查询的到，那么就不需要回表，这个过程就是<strong>覆盖索引</strong>。如果查询的数据不在二级索引里，就会先检索二级索引，找到对应的叶子节点，获取到主键值后，然后再检索主键索引，就能查询到数据了，这个过程就是<strong>回表</strong>。</p></li><li><p>按「字段特性」分类：</p><p><strong>主键索引</strong>：主键索引就是建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值。</p><p><strong>唯一索引</strong>：唯一索引建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值。</p><p><strong>普通索引</strong>：普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE，允许空值和重复值。</p><p><strong>前缀索引</strong>：前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。</p></li><li><p>按「字段个数」分类：</p><p><strong>单列索引</strong>：立在单列上的索引称为单列索引，比如主键索引。</p><p><strong>联合索引</strong>：通过将多个字段组合成一个索引，该索引就被称为联合索引。使用联合索引时，存在<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配。在使用联合索引进行查询的时候，如果不遵循「最左匹配原则」，联合索引会失效，这样就无法利用到索引快速查询的特性了。</p><p>注意：联合索引有一些特殊情况，<strong>并不是查询过程使用了联合索引查询，就代表联合索引中的所有字段都用到了联合索引进行索引查询</strong>，也就是可能存在部分字段用到联合索引的 B+Tree，部分字段没有用到联合索引的 B+Tree 的情况。</p><p>这种特殊情况就发生在范围查询。联合索引的最左匹配原则会一直向右匹配直到遇到「范围查询」就会停止匹配。<strong>也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引</strong>。</p></li></ul><h2 id="4、什么时候需要索引，什么时候不需要索引？"><a href="#4、什么时候需要索引，什么时候不需要索引？" class="headerlink" title="4、什么时候需要索引，什么时候不需要索引？"></a>4、什么时候需要索引，什么时候不需要索引？</h2><p>索引最大的好处是提高查询速度，但是索引也是有缺点的，比如：</p><ul><li>需要占用物理空间，数量越大，占用空间越大；</li><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增大；</li><li>会降低表的增删改的效率，因为每次增删改索引，B+ 树为了维护索引有序性，都需要进行动态维护。</li></ul><p>所以，索引不是万能钥匙，它也是根据场景来使用的。</p><h4 id="什么时候适用索引？"><a href="#什么时候适用索引？" class="headerlink" title="什么时候适用索引？"></a>什么时候适用索引？</h4><ul><li><strong>字段有唯一性限制的</strong>，比如商品编码；</li><li><strong>经常用于 <code>WHERE</code> 查询条件的字段</strong>，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。</li><li><strong>经常用于 <code>GROUP BY</code> 和 <code>ORDER BY</code> 的字段</strong>，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。</li></ul><h4 id="什么时候不需要创建索引？"><a href="#什么时候不需要创建索引？" class="headerlink" title="什么时候不需要创建索引？"></a>什么时候不需要创建索引？</h4><ul><li><strong><code>WHERE</code> 条件，<code>GROUP BY</code>，<code>ORDER BY</code> 里用不到的字段</strong>，索引的价值是快速定位，如果起不到定位的字段通常是<strong>不需要创建索引</strong>的，因为索引是会占用物理空间的。</li><li><strong>字段中存在大量重复数据，不需要创建索引</strong>，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。</li><li><strong>表数据太少的时候，不需要创建索引</strong>；（小表）</li><li><strong>经常更新的字段不用创建索引</strong>，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>水下机器人岸基客户端开发</title>
    <link href="/2024/05/09/%E6%B0%B4%E4%B8%8B%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%B2%B8%E5%9F%BA%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    <url>/2024/05/09/%E6%B0%B4%E4%B8%8B%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%B2%B8%E5%9F%BA%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h1 id="水下机器人岸基客户端"><a href="#水下机器人岸基客户端" class="headerlink" title="水下机器人岸基客户端"></a>水下机器人岸基客户端</h1><p>背景概述：2023.7–2024.5 任职青岛澎湃海洋科技有限公司，软件开发工程师，负责水下机器人岸基客户端的开发与维护。</p><h2 id="1、项目概述与角色"><a href="#1、项目概述与角色" class="headerlink" title="1、项目概述与角色"></a>1、项目概述与角色</h2><p>（1）项目的背景和目标：公司主要经营自主式水下机器人（潜航器）的研发与生产，对于水下机器人的控制与监测需要一套岸基操作系统，开发和设计岸基操作软件的客户端，实现对水下机器人的远程控制与数据传输。</p><p>（2）我所担任的角色（我在项目中承担的任务）：作为项目的主要开发者与维护者，负责设计和实现岸基界面，使用C++和Qt框架，在linux环境下基于MOOS框架开发。设计、实现、优化岸基界面及其与水下机器人的人机交互。</p><h2 id="2、技术栈与工具"><a href="#2、技术栈与工具" class="headerlink" title="2、技术栈与工具"></a>2、技术栈与工具</h2><p>所用技术与工具：C++、Qt、Mysql、网络编程、多线程、Linux、MOSS框架</p><p>C++用于实现项目的核心功能，包括数据处理、通信模块以及控制逻辑等。Qt作为界面开发的主要工具，能够支持创建直观、清晰快速响应的岸基界面，提供丰富的用户交互体验。另外，Qt的跨平台移植能力较强，适用于各种操作系统。</p><p>公司研发的水下潜航器是基于MOOS框架搭建的，MOOS为水下机器人系统提供了必要的通信和数据处理能力，其中MOOSDB提供了消息的订阅与转发机制，通过岸基界面与MOOSDB进行数据通信与交互，从而实现岸基客户端与水下机器人的数据交换和控制指令的发送。</p><h2 id="3、项目过程中遇到的挑战"><a href="#3、项目过程中遇到的挑战" class="headerlink" title="3、项目过程中遇到的挑战"></a>3、项目过程中遇到的挑战</h2><p>（持续优化，想到在写，结合实际情况具体阐述）</p><p>在项目开发过程中，我面临了多个挑战，其中一个主要挑战是处理实时数据和保证系统的稳定性。由于水下机器人的操作需要高度的准确性和实时性，我需要设计高效的数据处理算法，并优化系统的资源利用，以确保岸基客户端能够及时、准确地与水下机器人进行通信和控制。</p><p>另外，界面的设计和交互体验也是一个挑战，因为要考虑到操作人员在实际使用中的需求和习惯，我通过用户反馈和不断优化，逐步提升了岸基界面的易用性和效率。</p><p>地图功能的实现，地图选点、发送到地图等功能也可以结合HTML来描述。</p><p>在项目中，有一个挑战是确保岸基客户端与水下机器人之间稳定可靠的通信和数据交换。我通过深入学习MOOS框架和利用Qt的多线程技术，设计了可靠的数据传输机制，确保实时性和准确性。</p><h2 id="4、项目成果和贡献"><a href="#4、项目成果和贡献" class="headerlink" title="4、项目成果和贡献"></a>4、项目成果和贡献</h2><p>我的工作使得水下机器人岸基客户端功能更加完善和稳定，为水下机器人操作人员提供了便利和高效的使用环境。我设计和实现的岸基界面大大提升了操作员的操作体验，使得控制水下机器人变得更加直观和可靠。</p><p>另外，我还负责优化数据传输和处理流程，通过引入异步处理机制和内存管理技术，提高了系统的性能和稳定性，确保了水下机器人的实时响应和数据准确性。</p><p>这个项目使我能够深入理解水下机器人控制系统的开发和应用，通过开发岸基客户端，成功实现了对水下机器人的远程监控和控制。这种技术对于海洋科学研究和工业应用具有重要意义，为水下机器人的智能化控制提供了可行性和可靠性。</p><p>5、团队协作与沟通</p><p>在实际开发过程中，需要与水下机器人团队密切合作，与硬件工程师、算法工程师和控制组成员以及其他开发者共同商讨需求和解决方案。我们使用Git进行版本控制和团队协作，保证代码的一致性和可维护性。通过定期的沟通会议和协作工具，我能够及时了解用户需求，并将其转化为具体的界面设计和功能开发。公司搭建了服务器，可以将代码和相关程序部署到服务器，以便成员使用和访问。</p><h2 id="5、相关问题积累"><a href="#5、相关问题积累" class="headerlink" title="5、相关问题积累"></a>5、相关问题积累</h2><p>（1）在项目中使用的Qt框架是用来实现哪些功能的</p><p>Qt框架在项目中主要用于图形用户界面（GUI）开发，包括设计和实现岸基控制界面，显示水下机器人的状态和数据，以及与MOOS通信和数据交互。</p><p>（2）请介绍一下MOOS框架在你的项目中的作用和应用场景</p><p>MOOS是一种用于海洋操作的开源软件平台，我在项目中利用MOOS框架实现了与水下机器人的通信和数据交换。通过MOOS，岸基客户端可以发送控制指令和接收水下机器人的传感器数据，实现对机器人的监控和控制。</p><h2 id="遇到的问题："><a href="#遇到的问题：" class="headerlink" title="遇到的问题："></a>遇到的问题：</h2><p>最近在调整水下机器人内部架构，启用新架构实现AUV的控制。需要一版新的岸基界面提供控制与指令的下发。在此之前是由另一位员工开发的，实现了基本功能，代码实现方式比较复杂，结构相对混乱，还影响了现有的基本功能的实现，比如发送路径点到地图，从地图选点发送到文本框等。现在交由我负责相关功能的开发与实现，现在存在的问题是，他在航渡任务参数配置的构造函数中保存了路径点的信息，而创建航渡任务配置窗口的是在另一个类里构造的，为此，外界访问不到他保存的路径信息，也就无法获取到路径点以供外界访问和使用。基于路径点的地图相关功能目前无法实现，正在考虑如何解决。</p><p>解决方法：</p><p>我发现每个任务信息的发送功能都是正常的，因此，去探索发送任务信息的流程，发现了通过view视图，将新创建的窗口内容发送出去，供外界调用和访问，为此，可以模拟发送任务消息的形式实现发送路径点信息到地图。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">std::string <span class="hljs-title">WayPointView::getPointDate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>    QString way_points = <span class="hljs-built_in">QString</span>(<span class="hljs-string">&quot;;;points=&quot;</span>);<br>    <span class="hljs-type">int</span> waypoint_count = point_list_.point_list.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> current_waypoint_index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;waypoint : point_list_.point_list)<br>    &#123;<br>        way_points += <span class="hljs-built_in">QString</span>(<span class="hljs-string">&quot;%1,%2&quot;</span>).<span class="hljs-built_in">arg</span>(waypoint.second.longitude, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-number">6</span>).<span class="hljs-built_in">arg</span>(waypoint.second.latitude, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-number">6</span>);<br>        <span class="hljs-keyword">if</span> (++current_waypoint_index &lt; waypoint_count) &#123;<br>            way_points += <span class="hljs-string">&quot;:&quot;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> way_points.<span class="hljs-built_in">toStdString</span>()+ <span class="hljs-string">&quot;;&quot;</span>;<br>&#125;<span class="hljs-comment">// 获取路径点信息以供调用。</span><br><span class="hljs-function">std::string <span class="hljs-title">mission::sendWaypointsToMap</span><span class="hljs-params">(QTreeWidgetItem* item)</span></span><br><span class="hljs-function"></span>&#123;<br>    QWidget* way_widget;<br>    QWidget* traversal_widget;<br>    <span class="hljs-keyword">if</span> (!item)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;no points!&quot;</span>;<br>    QString point_str;<br>    <span class="hljs-keyword">auto</span> way_item = waypointLayout-&gt;<span class="hljs-built_in">itemAtPosition</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">auto</span> traversal_item = traversalLayout-&gt;<span class="hljs-built_in">itemAtPosition</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-type">bool</span> is_waypoint_;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; item-&gt;<span class="hljs-built_in">childCount</span>(); ++i) &#123;<br>        QTreeWidgetItem *childItem = item-&gt;<span class="hljs-built_in">child</span>(i);<br>        <span class="hljs-keyword">if</span> (childItem-&gt;<span class="hljs-built_in">text</span>(<span class="hljs-number">0</span>) == <span class="hljs-string">&quot;航渡平台参数配置&quot;</span>) &#123;<br>           is_waypoint_ = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(childItem-&gt;<span class="hljs-built_in">text</span>(<span class="hljs-number">0</span>) == <span class="hljs-string">&quot;遍历平台参数配置&quot;</span>)<br>        &#123;<br>            is_waypoint_ = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">break</span>;<br><br>        &#125; <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> point_str.<span class="hljs-built_in">toStdString</span>();<br>        &#125;<br>    &#125;<br>        <span class="hljs-keyword">if</span> (is_waypoint_)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!way_item)<br>        &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;sadfsad&quot;</span> &lt;&lt; std::endl;<br>            <span class="hljs-keyword">return</span> point_str.<span class="hljs-built_in">toStdString</span>();<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            way_widget = way_item-&gt;<span class="hljs-built_in">widget</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">qobject_cast</span>&lt;WayPointView*&gt;(way_widget)!= <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">auto</span> view =treeWidget-&gt;<span class="hljs-built_in">getViewMap</span>()[item-&gt;<span class="hljs-built_in">text</span>(<span class="hljs-number">0</span>)];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; item-&gt;<span class="hljs-built_in">childCount</span>(); ++i) &#123;<br>                QTreeWidgetItem *childItem = item-&gt;<span class="hljs-built_in">child</span>(i);<br>                <span class="hljs-keyword">if</span> (childItem-&gt;<span class="hljs-built_in">text</span>(<span class="hljs-number">0</span>) == <span class="hljs-string">&quot;航渡平台参数配置&quot;</span>) &#123;<br>                    <span class="hljs-keyword">auto</span> way_view = <span class="hljs-built_in">qobject_cast</span>&lt;WayPointView*&gt;(view);<br>                    point_str += way_view-&gt;<span class="hljs-built_in">getPointDate</span>().<span class="hljs-built_in">c_str</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( !is_waypoint_)&#123;<br><br>        <span class="hljs-keyword">if</span> (!traversal_item)<br>        &#123;<br>            <span class="hljs-keyword">return</span> point_str.<span class="hljs-built_in">toStdString</span>();<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            traversal_widget = traversal_item-&gt;<span class="hljs-built_in">widget</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">qobject_cast</span>&lt;TraversalView*&gt;(traversal_widget)!= <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">auto</span> view =treeWidget-&gt;<span class="hljs-built_in">getViewMap</span>()[item-&gt;<span class="hljs-built_in">text</span>(<span class="hljs-number">0</span>)];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; item-&gt;<span class="hljs-built_in">childCount</span>(); ++i) &#123;<br>                QTreeWidgetItem *childItem = item-&gt;<span class="hljs-built_in">child</span>(i);<br>                <span class="hljs-keyword">if</span> (childItem-&gt;<span class="hljs-built_in">text</span>(<span class="hljs-number">0</span>) == <span class="hljs-string">&quot;遍历平台参数配置&quot;</span>) &#123;<br>                    <span class="hljs-keyword">auto</span> way_view = <span class="hljs-built_in">qobject_cast</span>&lt;TraversalView*&gt;(view);<br>                    point_str += way_view-&gt;<span class="hljs-built_in">getStrData</span>().<span class="hljs-built_in">c_str</span>() + <span class="hljs-built_in">QString</span>(<span class="hljs-string">&quot;;&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> point_str.<span class="hljs-built_in">toStdString</span>();<br>&#125;<span class="hljs-comment">// 外界整合路径点信息</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mission::sendTomapClicked</span><span class="hljs-params">(QTreeWidgetItem* item)</span><span class="hljs-comment">// 0514 byz ds</span></span><br><span class="hljs-function"></span>&#123;<br>    QMessageBox::StandardButton reply;<br>    reply = QMessageBox::<span class="hljs-built_in">question</span>(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">tr</span>( <span class="hljs-string">&quot;是否发送到地图&quot;</span> ),  <span class="hljs-built_in">tr</span>( <span class="hljs-string">&quot;确认发送&quot;</span> ),<br>                                    QMessageBox::Yes | QMessageBox::No );<br>    <span class="hljs-keyword">if</span>( reply == QMessageBox::Yes )<br>    &#123;<br>        sendToMap = <span class="hljs-literal">true</span>;<br>        <span class="hljs-function">emit <span class="hljs-title">snedPointparameter</span><span class="hljs-params">(sendWaypointsToMap(item))</span></span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( reply == QMessageBox::No )<br>    &#123;<br>        sendToMap = <span class="hljs-literal">false</span>;<br>    &#125; <br>&#125;<span class="hljs-comment">// 发送到地图槽函数</span><br><span class="hljs-built_in">connect</span>(treeWidget,&amp;TaskTreeWidget::send_to_map, <span class="hljs-keyword">this</span>, &amp;mission::sendTomapClicked);<span class="hljs-comment">//触发信号</span><br></code></pre></td></tr></table></figure><p>实现了发送路径点到地图功能后，还需要实现地图选点功能，即从地图上标记好路径点之后，点击确认选点会将路径点信息填充到表格中。同样存在操作不同实例化对象的问题，为此，我将每次创建新窗口时新建的实例化对象通过信号与槽的机制将其传出来，在外面定义一个实例化对象接收，确保我操作的路径点表格是当前创建窗口的。</p><p>首先，定义操作路径点窗口信息的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WayPointView::getPointFromMap</span><span class="hljs-params">(std::string points)</span></span>&#123;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt;<span class="hljs-string">&quot;获取航渡点&quot;</span> &lt;&lt;QString::<span class="hljs-built_in">fromStdString</span>(points) &lt;&lt; endl;<br>    QStringList pointList = QString::<span class="hljs-built_in">fromStdString</span>(points).<span class="hljs-built_in">split</span>(<span class="hljs-string">&#x27;:&#x27;</span>);<br>    <span class="hljs-comment">// 获取路径点数目，最多处理表格行数</span><br>    <span class="hljs-type">int</span> numPoints = std::<span class="hljs-built_in">min</span>(pointList.<span class="hljs-built_in">size</span>(), model_-&gt;<span class="hljs-built_in">rowCount</span>());<br>    <span class="hljs-comment">// 填充经纬度信息到表格中</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numPoints; ++i) &#123;<br>        QStringList lngLat = pointList[i].<span class="hljs-built_in">split</span>(<span class="hljs-string">&#x27;,&#x27;</span>);<br>        <span class="hljs-keyword">if</span> (lngLat.<span class="hljs-built_in">size</span>() &gt;= <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-comment">// 设置经度和纬度到对应的单元格中</span><br>            QString longitude = QString::<span class="hljs-built_in">number</span>(lngLat[<span class="hljs-number">0</span>].<span class="hljs-built_in">toFloat</span>(), <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-number">6</span>);<br>            QString latitude = QString::<span class="hljs-built_in">number</span>(lngLat[<span class="hljs-number">1</span>].<span class="hljs-built_in">toFloat</span>(), <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-number">6</span>);<br>            model_-&gt;<span class="hljs-built_in">setData</span>(model_-&gt;<span class="hljs-built_in">index</span>(i, <span class="hljs-number">0</span>), longitude); <span class="hljs-comment">// 经度</span><br>            model_-&gt;<span class="hljs-built_in">setData</span>(model_-&gt;<span class="hljs-built_in">index</span>(i, <span class="hljs-number">1</span>), latitude); <span class="hljs-comment">// 纬度</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在mission类里定义全局的waypointview的对象WayPointView* way_View; 用来接收传出来的实例化对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TaskTreeWidget::addFerryPlatform</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; current_item_-&gt;<span class="hljs-built_in">childCount</span>(); ++i) &#123;<br>        QTreeWidgetItem *childItem = current_item_-&gt;<span class="hljs-built_in">child</span>(i);<br>        <span class="hljs-keyword">if</span> (childItem-&gt;<span class="hljs-built_in">text</span>(<span class="hljs-number">0</span>) == <span class="hljs-string">&quot;航渡平台参数配置&quot;</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">auto</span> ferry_item = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QTreeWidgetItem</span>(current_item_);<br>    ferry_item-&gt;<span class="hljs-built_in">setText</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;航渡平台参数配置&quot;</span>);<br>    ferry_item-&gt;<span class="hljs-built_in">setData</span>(<span class="hljs-number">0</span>, Qt::UserRole, <span class="hljs-number">0</span>);<br>    current_item_-&gt;<span class="hljs-built_in">addChild</span>(ferry_item);<br>    current_item_-&gt;<span class="hljs-built_in">setExpanded</span>(<span class="hljs-literal">true</span>);<br><br>    <span class="hljs-keyword">auto</span> way_point_view = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WayPointView</span>();<br>    ViewMap.<span class="hljs-built_in">insert</span>(current_item_-&gt;<span class="hljs-built_in">text</span>(<span class="hljs-number">0</span>), way_point_view);<span class="hljs-comment">// 0515 by</span><br>    <span class="hljs-function">emit <span class="hljs-title">showFerryPlatformConfig</span><span class="hljs-params">(way_point_view)</span></span>;<br>    <span class="hljs-function">emit <span class="hljs-title">getcurrentwaypointview</span><span class="hljs-params">(way_point_view)</span></span>;<br>&#125;<span class="hljs-comment">// 创建窗口时就将实例化对象通过信号传出去</span><br><br><span class="hljs-built_in">connect</span>(treeWidget, &amp;TaskTreeWidget::getcurrentwaypointview, <span class="hljs-keyword">this</span>, &amp;mission::getCurrentWayView);<br><span class="hljs-comment">//信号与槽机制，收到传出的信号，将实例化对象传给way_View</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mission::getCurrentWayView</span><span class="hljs-params">(WayPointView* view)</span></span>&#123;<br>    way_View = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WayPointView</span>(<span class="hljs-keyword">this</span>);<br>    way_View= view;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;获取新窗口的view&quot;</span> &lt;&lt; endl;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>通过上述操作，我们就获取到了需要操作的实例化对象，通过这个对象去调用相关的成员函数，实现地图选点功能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mission::getpointsfromMap</span><span class="hljs-params">(std::string points)</span></span>&#123;<span class="hljs-comment">// 0515 by zds</span><br><br>    <span class="hljs-keyword">if</span> (way_View) &#123;<br>        <span class="hljs-comment">// 调用 WayPointView 的 getPointFromMap 方法</span><br>        way_View-&gt;<span class="hljs-built_in">getPointFromMap</span>(points);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 处理转换失败的情况</span><br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;Failed to cast view to WayPointView&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">// 输出调试信息</span><br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;地图选点功能测试: &quot;</span> &lt;&lt; QString::<span class="hljs-built_in">fromStdString</span>(points);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>demo</title>
    <link href="/2024/05/08/Git%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/05/08/Git%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>1、熟悉git的相关命令<br>操作类似于Linux相关指令，通过git init 将创建好的文件夹变成git可以管理的仓库（版本库）<br>git add readme.txt 添加文件到暂存区<br>git commit 将文件提交到仓库（-m可以添加备注）<br>git status 查看文件提交状态<br>git diff rademe.txt 查看文件修改了什么内容<br>git log 查看历史记录<br>git reset -hard HEAD^ 版本回退<br>git reflog 获取所有记录的版本号<br>git reset -hard 版本号，恢复指定版本<br>git restore– readme.txt 撤销未提交的工作（– 很重要！）<br>git push origin master 本地代码推送到github上<br>git checkout -b dev 创建并切换到该分支&#x3D;&#x3D;git branh dev + git<br>checkout dev<br>git branch 查看分支<br>git branch -d dev 删除分支dev<br>2、github远程仓库搭建<br>ssh加密同步方式</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>张登胜的博客</title>
    <link href="/2024/05/08/%E5%BC%A0%E7%99%BB%E8%83%9C%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <url>/2024/05/08/%E5%BC%A0%E7%99%BB%E8%83%9C%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>这是我的个人博客，欢迎大家访问！</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>

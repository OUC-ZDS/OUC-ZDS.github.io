

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/icon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="ZDS">
  <meta name="keywords" content="">
  
    <meta name="description" content="计算机网络1、从输入URL到页面展示期间发生了什么？（1）检查缓存：浏览器收到用户请求后，先检查浏览器缓存里是否有该资源，如果有直接返回；如果没有，进入下一步网络请求。 （2）DNS域名解析：进行网络请求之前需要获取请求域名的IP地址，（HTTP协议）。如果是HTTPS，还需要建立TLS连接。DNS解析时会按照本地浏览器缓存-&gt;本地HOST文件-&gt;路由器缓存-&gt;DNS服务器-&amp;g">
<meta property="og:type" content="article">
<meta property="og:title" content="八股基础">
<meta property="og:url" content="http://example.com/2024/05/10/%E5%85%AB%E8%82%A1%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="佑安的个人博客">
<meta property="og:description" content="计算机网络1、从输入URL到页面展示期间发生了什么？（1）检查缓存：浏览器收到用户请求后，先检查浏览器缓存里是否有该资源，如果有直接返回；如果没有，进入下一步网络请求。 （2）DNS域名解析：进行网络请求之前需要获取请求域名的IP地址，（HTTP协议）。如果是HTTPS，还需要建立TLS连接。DNS解析时会按照本地浏览器缓存-&gt;本地HOST文件-&gt;路由器缓存-&gt;DNS服务器-&amp;g">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-05-10T11:48:02.000Z">
<meta property="article:modified_time" content="2024-05-21T07:28:14.397Z">
<meta property="article:author" content="ZDS">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>八股基础 - 佑安的个人博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>佑安的个人博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="八股基础"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-05-10 19:48" pubdate>
          2024年5月10日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          17k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          143 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">八股基础</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="1、从输入URL到页面展示期间发生了什么？"><a href="#1、从输入URL到页面展示期间发生了什么？" class="headerlink" title="1、从输入URL到页面展示期间发生了什么？"></a>1、从输入URL到页面展示期间发生了什么？</h2><p>（1）<strong>检查缓存</strong>：浏览器收到用户请求后，先检查浏览器缓存里是否有该资源，如果有直接返回；如果没有，进入下一步网络请求。</p>
<p>（2）<strong>DNS域名解析</strong>：进行网络请求之前需要获取请求域名的IP地址，（HTTP协议）。如果是HTTPS，还需要建立TLS连接。DNS解析时会按照本地浏览器缓存-&gt;本地HOST文件-&gt;路由器缓存-&gt;DNS服务器-&gt;根DNS服务器的顺序查询域名对应IP地址，直到找到为止。</p>
<p>DNS 中的域名都是用<strong>句点</strong>来分隔的，比如 <code>www.server.com.</code>，这里的句点代表了不同层次之间的<strong>界限</strong>。在域名中，<strong>越靠右</strong>的位置表示其层级<strong>越高</strong>。</p>
<p>（3）<strong>浏览器与服务器IP建立TCP连接</strong>（可靠传输）：建立连接后，浏览器端构建请求行、请求头等信息，并把和该域名相关的Cookie等数据附加到请求头中，向服务器构建请求信息。（由协议栈（TCP、IP)提供可靠传输–&gt;IP（远程定位）–&gt;MAC（两点传输）–&gt;网卡–&gt;交换机–&gt;路由器）</p>
<p>（4）<strong>服务器收到请求信息，根据请求生成响应数据，发给浏览器</strong>。</p>
<p>（5）<strong>浏览器解析服务器的响应数据</strong>：若响应头状态码为301、302，会重新定向到新地址（IP中的ICMP、ARP功能）；若响应数据类型是字节流类型，一般会将请求交给下载管理器；若是HTML类型，会进入下一步渲染流程。</p>
<p>（6）<strong>浏览器解析HTML文件</strong>，创建DOM树，解析CSS进行样式计算，然后将CSS与DOM合并，构建渲染树，最后布局和绘制渲染树，完成页面展示。</p>
<h2 id="2、HTTP常见面试题"><a href="#2、HTTP常见面试题" class="headerlink" title="2、HTTP常见面试题"></a>2、HTTP常见面试题</h2><h3 id="（1）什么是HTTP（超文本传输协议）"><a href="#（1）什么是HTTP（超文本传输协议）" class="headerlink" title="（1）什么是HTTP（超文本传输协议）"></a>（1）什么是HTTP（超文本传输协议）</h3><p>超文本：文字、图片、视频的混合体</p>
<p>传输：计算机世界中实现两点之间传输</p>
<p>协议：计算机世界里的约定和规范</p>
<p>即<strong>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</strong></p>
<h3 id="（2）HTTP常见的状态码有哪些"><a href="#（2）HTTP常见的状态码有哪些" class="headerlink" title="（2）HTTP常见的状态码有哪些"></a>（2）HTTP常见的状态码有哪些</h3><p><code>1xx</code> 类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少。</p>
<p><code>2xx</code> 类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态。</p>
<ul>
<li>「<strong>200 OK</strong>」是最常见的成功状态码，表示一切正常。如果是非 <code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据。</li>
<li>「<strong>204 No Content</strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</li>
<li>「<strong>206 Partial Content</strong>」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li>
</ul>
<p><code>3xx</code> 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</p>
<ul>
<li>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</li>
<li>「<strong>302 Found</strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</li>
</ul>
<p>301 和 302 都会在响应头里使用字段 <code>Location</code>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p>
<ul>
<li>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。</li>
</ul>
<p><code>4xx</code> 类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</p>
<ul>
<li>「<strong>400 Bad Request</strong>」表示客户端请求的报文有错误，但只是个笼统的错误。</li>
<li>「<strong>403 Forbidden</strong>」表示服务器禁止访问资源，并不是客户端的请求出错。</li>
<li>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li>
</ul>
<p><code>5xx</code> 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</p>
<ul>
<li>「<strong>500 Internal Server Error</strong>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</li>
<li>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li>
<li>「<strong>502 Bad Gateway</strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li>
<li>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。</li>
</ul>
<h3 id="（3）HTTP的常见字段有哪些"><a href="#（3）HTTP的常见字段有哪些" class="headerlink" title="（3）HTTP的常见字段有哪些"></a>（3）HTTP的常见字段有哪些</h3><p>HOST字段：客户端发送请求时，用来指定服务器的域名。</p>
<p>Content-Length 字段：服务器在返回数据时，会有 <code>Content-Length</code> 字段，表明本次回应的数据长度。</p>
<p><strong>HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决“粘包”的问题</strong></p>
<p>Connection 字段：<code>Connection</code> 字段最常用于客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用。</p>
<p>Content-Type 字段：<code>Content-Type</code> 字段用于服务器回应时，告诉客户端，本次数据是什么格式。</p>
<p>Content-Encoding 字段：<code>Content-Encoding</code> 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式。</p>
<h3 id="（4）-GET和POST有什么区别"><a href="#（4）-GET和POST有什么区别" class="headerlink" title="（4） GET和POST有什么区别"></a>（4） GET和POST有什么区别</h3><p>作用不同：GET用于从服务器获取资源；POST一般用来向服务器提交数据。</p>
<p>参数传递的方式不同：GET请求一般写在URL中，只接受ASCII字符。POST请求参数一般放在请求体中，对于数据类型也没有限制。</p>
<p>安全性不同：由于传递参数方式不同，GET请求直接暴露在URL中，一般不用来传递敏感信息。</p>
<p>参数长度限制不同：GET传输量较小，不能大于2KB；POST传递的数据量较大，一般默认不受限制。</p>
<p>编码方式不同：GET只进行URL编码，POST支持多种编码方式。</p>
<p>缓存机制不同：GET请求会被浏览器主动cache，POST不会，需要手动设置。GET请求参数会被完整保留在浏览器历史里，POST中的参数不会被保留。GET产生的URL可以被保存为书签，POST不可以。GET在浏览器回退时是无害的，POST会再次提交请求。</p>
<p>时间消耗不同：GET产生一个TCP数据包，POST产生两个TCP数据包。</p>
<p>先说明下安全和幂等的概念：</p>
<ul>
<li><p>在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。</p>
</li>
<li><p>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。</p>
</li>
<li><p><strong>GET 方法就是安全且幂等的</strong>，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，<strong>可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签</strong>。</p>
</li>
<li><p><strong>POST</strong> 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等</strong>的。所以，<strong>浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签</strong>。</p>
</li>
</ul>
<h3 id="（5）HTTP的缓存方式"><a href="#（5）HTTP的缓存方式" class="headerlink" title="（5）HTTP的缓存方式"></a>（5）HTTP的缓存方式</h3><p>缓存解决什么问题：减少不必要的网络传输，节约带宽；更快地加载页面，提高响应速度；减少服务器的负载，避免服务过载的情况出现。</p>
<p>强制缓存：浏览器判断请求的目标资源是否有效命中强缓存，如果命中，则直接从缓存中读取目标资源，无需与服务器通信，也就是说决定是否使用缓存的主动性在于浏览器这边。</p>
<p>Expires强缓存：设置一个强缓存时间，此时间范围内，从内存中读取并返回，但是因为其判断缓存过期的机制是获取本地时间戳，与之前拿到的资源文件的Expires字段时间进行比较，存在漏洞：如果本地时间不准怎么办，目前已被弃用。</p>
<p>Cache-Control强缓存：</p>
<ul>
<li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；</li>
<li>浏览器再次请求访问服务器中的该资源时，会先<strong>通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期</strong>，如果没有，则使用该缓存，否则重新请求服务器；</li>
<li>服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control</li>
</ul>
<p>max-age决定客户端资源被缓存多久；s-maxage决定代理服务器缓存多长时间；no-cache表示强制进行协商缓存；no-store表示禁止任何缓存策略；public表示资源既可以被浏览器缓存也可以被代理服务器缓存。private表示资源只能被浏览器缓存，默认为private。</p>
<p>基于Last-modified的协商缓存：</p>
<p>首先在服务器端读出资源文件的修改时间，将读出来的修改时间赋值给响应头的last-modified字段，然后设置Cache-Control为no-cache（强制协商缓存），当客户端读取到last-modified的时候，会在下次请求的的头部携带一个If-Modified-Since,即服务器第一次修改的时候给他的时间。之后每次对该资源进行请求，都会带上If-Modified-Since字段，服务器会拿着个字段并再次读取该资源的修改时间，进行比较，决定是读取缓存还是返回新资源。</p>
<p>缺点：根据修改时间做判断，如果内容没修改那也有可能更新文件修改时间（重命名-再改回来），文件内容没修改但缓存失效了；当文件在极短时间内修改完成，文件修改时间以秒为单位未检测到毫秒级的改变，此时文件内容被修改了，但缓存依然可用，并不发送新文件。-<em>-存在的问题</em></p>
<p>基于Etag的协商缓存：将原先协商缓存的比较时间戳的形式修改成了比较文件指纹（根据文件内容计算的唯一哈希值），解决了Last-Modified存在的问题。</p>
<p>第一次请求某资源的时候，服务端读取文件并计算文件指纹，将文件指纹放在响应头的Etag字段中跟随资源一起返回给客户端。第二次请求某资源的时候，客户端从缓存中读取上一次服务端返回的Etag（文件指纹），并赋值给请求头的if-none-match字段，让其跟随请求一起发回服务端。服务端接收到请求头中的if-node-match（上一次的文件指纹），并对目标资源文件再次读取并生成文件指纹，两个文件指纹进行对比，如果吻合，则直接返回304状态码和空的响应并return，如果不吻合，将新的文件指纹存储到Etag并返回给客户端。</p>
<p>缺点：Etag需要计算文件指纹，服务端需要更多的计算开销，如果文件尺寸大且计算频繁，会影响服务器性能。同时，Etag有强验证和弱验证，强验证需要将生成的哈希码深入到每个字节，文件中只有一个字节被改变，也会生成不同的哈希值，非常消耗服务器资源。弱验证通过提取文件的部分属性来生成哈希值，不必精确到每个字节，速度快，但准确率不高，会降低协商缓存的有效性。</p>
<h3 id="（6）HTTP1-0与HTTP1-1的区别"><a href="#（6）HTTP1-0与HTTP1-1的区别" class="headerlink" title="（6）HTTP1.0与HTTP1.1的区别"></a>（6）HTTP1.0与HTTP1.1的区别</h3><p>1、长连接</p>
<p>HTTP1.1支持长连接，每一个TCP连接上可以传送多个HTTP请求和响应，默认开启Connection： Keep-Alive。</p>
<p>HTTP1.0默认是短连接，每次请求都需要建立一个TCP连接。</p>
<p>2、缓存</p>
<p>HTTP1.0主要使用If-Modified_Since、Expires来作为缓存判断标准</p>
<p>HTTP1.1则引入了更多的缓存控制策略 比如Entity tag、If-None-Match等更多可选择的缓存头来控制缓存策略。</p>
<p>3、管道化</p>
<p>基于HTTP1.1的长连接，是的请求管道化成为可能，管道化能使得请求并行传输，但响应必须按照请求发出的顺序依次返回，性能在一定程度上得到了改善。</p>
<p>4、增加了Host字段</p>
<p>使得一个服务器可以创建多个web站点。</p>
<p>5、状态码</p>
<p>新增了24个错误状态响应码</p>
<p>6、带宽优化</p>
<p>HTTP1.0中，存在浪费带宽的现象，例如客户端只是需要某个资源的一部分，但服务器将整个资源对象传输过来，不支持断点续传功能。</p>
<p>HTTP1.1中加入了range头域，它允许之请求资源的某个部分，返回码是<code>206</code>（Partial content）。</p>
<h3 id="（7）HTTP2-0与HTTP1-1的区别"><a href="#（7）HTTP2-0与HTTP1-1的区别" class="headerlink" title="（7）HTTP2.0与HTTP1.1的区别"></a>（7）HTTP2.0与HTTP1.1的区别</h3><p>1、二进制分帧</p>
<p>HTTP2.0在应用层和传输层之间增加了一个二进制分帧层，突破了HTTP1.1的性能限制，改进了传输性能，实现低延迟高吞吐量。</p>
<p>2、多路复用（MultiPlexing）</p>
<p>允许通过单一的HTTP2.0连接发起多重的请求-响应消息，这个功能基于“二进制分帧”的特性。</p>
<p>3、首部压缩</p>
<p>HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header数据进行压缩。减少了数据体积，使得传输更快。高效的压缩算法可以尽量压缩header，减少发送包的数量从而降低延迟。</p>
<p>4、服务端推送</p>
<p>HTTP2.0中，服务器可以对客户端的一个请求发送多个响应，即服务器可以额外的向客户端推送资源，无需客户端明确的请求。</p>
<h3 id="（8）HTTPS的工作原理（HTTPS是怎么建立连接的）"><a href="#（8）HTTPS的工作原理（HTTPS是怎么建立连接的）" class="headerlink" title="（8）HTTPS的工作原理（HTTPS是怎么建立连接的）"></a>（8）HTTPS的工作原理（HTTPS是怎么建立连接的）</h3><p>首先，客户端向服务器发送请求报文，请求与服务端建立连接。服务端产生应一对公私密钥，然后将自己的公钥发送给CA机构，CA机构也有一对公私秘钥，CA机构使用自己的私钥将服务端发送过来的公钥进行加密，产生一个CA数字证书。（客户端–&gt;服务端&lt;–&gt;CA机构)</p>
<p>服务端响应客户端的请求，将CA机构生成的数字证书发送给客户端。(服务端–&gt;客户端)</p>
<p>客户端将服务端发送过来的数字证书进行解析，验证数字证书是否合法，不合法会发送警告，如果合法，取出服务端生成的公钥。客户端取出公钥并生成一个随机码key（对称加密中的秘钥），客户端将加密后的随机码key发送给服务端，作为之后对称加密的秘钥。（客户端–&gt;服务端）</p>
<p>服务端接收到随机码key（秘钥）后，使用服务端自己的私钥对他解密，然后获得这个随机码key。服务端使用这个随机码key对传输的数据进行加密，然后将加密后的内容发送给客户端。（服务端–&gt;客户端）</p>
<p>客户端使用自己生成的随机码key（密码）解密服务端发送过来的数据，之后客户端和服务端通过  对称加密传输数据，随机码key作为传输的秘钥。</p>
<p>（9）HTTPS与HTTP的区别</p>
<p>1、HTTP是明文传输，HTTPS通过SSL&#x2F;TLS进行加密。</p>
<p>2、HTTP的端口是80，HTTPS的端口是443</p>
<p>3、HTTPS需要到CA申请证书</p>
<p>4、HTTP的连接简单，是无状态的，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全。</p>
<h3 id="（9）DNS及其查询过程"><a href="#（9）DNS及其查询过程" class="headerlink" title="（9）DNS及其查询过程"></a>（9）DNS及其查询过程</h3><p>DNS（域名管理系统），当用户使用浏览器访问网址的时候，使用的第一个重要协议，解决的是域名和IP地址映射的问题。</p>
<p>用户在浏览器输入URL地址之后，会先在浏览器缓存中查询是否有该域名对应的IP地址。</p>
<p>如果浏览器缓存中没有，会去计算机本地的Host文件中查询是否有对应的缓存，是否有该域名对应的IP地址。</p>
<p>如果Host文件中也没有则会向本地DNS服务器发送一个DNS查询请求。本地DNS解析器没有缓存该域名的解析记录，它会向根DNS服务器发出查询请求，根DNS服务器不负责具体的域名解析，它会告诉本地DNS服务器应该向哪个顶级域DNS服务器发送查询请求。</p>
<p>本地DNS服务器接着向顶级域DNS服务器发送查询请求，顶级域DNS服务器也不负责具体的域名解析，它会告诉本地DNS服务器前往哪个权威域名DNS服务器发送查询请求。</p>
<p>本地DNS服务器接着向权威DNS服务器发送查询请求，权威DNS服务器是负责存储特定域名和IP地址映射的服务器。当权威DNS服务器收到查询请求是，会查找“example.com”域名对应的IP地址，并将结果返回给本地DNS服务器。</p>
<p>本地DNS服务器将收到的IP地址返回给浏览器，并将域名解析结果缓存在本地，以便下次更快响应。</p>
<h2 id="（10）HTTP多个TCP连接怎么实现"><a href="#（10）HTTP多个TCP连接怎么实现" class="headerlink" title="（10）HTTP多个TCP连接怎么实现"></a>（10）HTTP多个TCP连接怎么实现</h2><p>多个tcp连接是靠某些服务器对Connection： keep-alive的Header的支持。即完成这个HTTP请求之后，不要断开HTTP请求使用的TCP连接，这样的好处是连接可以被重复使用，之后发送的HTTP请求不需要重新建立新的TCP连接，并且SSL的开销也可以避免。</p>
<h2 id="（11）TCP的keepalive和HTTP的keep-alive是一个东西吗"><a href="#（11）TCP的keepalive和HTTP的keep-alive是一个东西吗" class="headerlink" title="（11）TCP的keepalive和HTTP的keep-alive是一个东西吗"></a>（11）TCP的keepalive和HTTP的keep-alive是一个东西吗</h2><p>HTTP的keep-alive，是由应用层（用户态）实现的，成为HTTP长连接：—<strong>保持成为长连接</strong></p>
<p>每次请求都要经历这样的过程：建立TCP-&gt;请求资源-&gt;响应资源-&gt;释放连接，这是HTTP短连接，但是这样每次建立连接都只能请求一次资源，所以HTTP通过keep-alive实现了使用同一个TCP连接来发送和接收多个HTTP请求，避免了连接建立和释放的开销，即HTTP长连接。</p>
<p>TCP的keepalive，是由TCP层（内核态）实现的，称为TCP保活机制。—<strong>判断是否存活</strong></p>
<p>TCP有一个定时任务倒计时，超时后会触发任务，内容是发送一个探测报文给对端，用来判断对端是否存活。</p>
<h2 id="12、TCP连接如何确保可靠性"><a href="#12、TCP连接如何确保可靠性" class="headerlink" title="12、TCP连接如何确保可靠性"></a>12、TCP连接如何确保可靠性</h2><p>1、数据块大小控制：应用数据被分割成TCP认为最合适发送的数据块，在传输给网络层，数据块被称为报文段或段。</p>
<p>2、序列号：TCP给每个数据包指定序列号，接收方根据序列号对数据包进行排序，并根据序列号对数据包进行去重。</p>
<p>3、校验和：TCP将保持首部和数据的校验和，这是一个端到端的校验和，目的是检测数据在传输过程中的任何变化，如果收到的报文的校验和有误，TCP将丢弃这个报文段和不确认收到此报文段（对面要重新发送或采取别的措施）</p>
<p>4、流量控制：TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据，当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止数据包丢失。TCP利用滑动窗口实现流量控制。</p>
<p>5、拥塞控制：当网络拥塞时，减少数据的发送。（有其拥塞控制算法）</p>
<p>6、确认应答：用过ARQ协议实现。基本原理是每发完一个分组就停止发送，等待对方确认。如果没收到确定就重新发送数据包，直到确认后再发送下一个分组。</p>
<p>7、超时重传：当TCP发出一个数据段后，启动一个定时器，等待目的端的确认收到这个报文段，如果在定时器时间内没收到，将重新发送这个报文段。 <strong>超时重传时间 RTO 的值应该略大于报文往返 RTT 的值</strong></p>
<p>还有一种实现重传机制的方式叫：<code>SACK</code>（ Selective Acknowledgment）， <strong>选择性确认</strong>。</p>
<p>这种方式需要在 TCP 头部「选项」字段里加一个 <code>SACK</code> 的东西，它<strong>可以将已收到的数据的信息发送给「发送方」</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong>。</p>
<h2 id="13、既然提到了拥塞控制，拥塞控制是怎么实现的？"><a href="#13、既然提到了拥塞控制，拥塞控制是怎么实现的？" class="headerlink" title="13、既然提到了拥塞控制，拥塞控制是怎么实现的？"></a>13、既然提到了拥塞控制，拥塞控制是怎么实现的？</h2><p>拥塞控制算法主要有以下几种：</p>
<p>1、慢启动</p>
<p>在连接刚开始时，发送方会逐渐增加发送窗口的大小，以指数增长的速度增加发送窗口的数据量。</p>
<p>2、拥塞避免</p>
<p>一旦慢启动阶段过去，发送方进入拥塞避免阶段，在这个阶段，发送方会逐渐增加发送窗口的大小，但增加速率较慢，以线性增长的方式，避免过快增加导致网络拥塞。</p>
<p>3、超时重传</p>
<p>如果发送方在超时时间内未收到确认，他会认为数据包丢失，并重传这些数据包。这是拥塞控制的最后手段，用于检测和处理网络中的丢包和拥塞情况。</p>
<p>4、快速重传</p>
<p>当发送方发送的数据包丢失或者网络出现拥塞时，接收方会重复发送确认通知（ACK）来通知发送方有数据丢失，当发送方收到三次重复确认时，在超时时间到期内立刻重新发送丢失的数据包，而不是等超时之后再发，这样可以减少网络的拥塞程度。</p>
<p>5、拥塞窗口调整</p>
<p>发送方根据网络的拥塞程度动态调整发送窗口的大小，通过监测网络延迟和丢包情况来确定合适的发送速率，以避免网络拥塞。</p>
<h2 id="14、Cookie和Session是什么，有什么区别？"><a href="#14、Cookie和Session是什么，有什么区别？" class="headerlink" title="14、Cookie和Session是什么，有什么区别？"></a>14、Cookie和Session是什么，有什么区别？</h2><p>Cookie和Session都用于管理用户的状态和身份。</p>
<p>Cookie通过在客户端记录信息来确定用户身份。</p>
<p>Session通过在服务器端记录信息确定用户身份。</p>
<p>1、Cookie</p>
<p>Cook是存储在用户浏览器中的小型文本文件，用于在用户和服务器之间传递数据。通常服务器会将一个或多个Cookie发送到用户浏览器，然后浏览器将这些Cookie存储在本地。</p>
<p>服务端在接收到来自客户端浏览器的请求之后，能够通过分析存放于请求头中的Cookie得到客户端特有的信息，从而动态生成与该客户端相对应的内容。</p>
<p>2、Session</p>
<p>客户端浏览器访问服务器的时候，服务器把客户端信息以某种新式记录在服务器上，即Session。Session主要用于维护用户登录状态、存储用户的临时数据和上下文信息等。</p>
<p>3、区别</p>
<p>存储位置：Cookie存储于用户的浏览器中，Session存储于服务器上。</p>
<p>数据容量：Cookie存储容量较小，一般为几KB，Session存储容量较大，通常没有固定限制，取决于服务器的配置和资源。</p>
<p>安全性：Cookie存储于用户浏览器中可以被用户读取和篡改。相比之下，Session存储于服务器上更难被访问和修改。</p>
<p>传输方式：Cookie在每次HTTP请求中会被自动发送到服务器，而Session ID通常通过Cookie或者URL参数传递。</p>
<h1 id="C-语言基础"><a href="#C-语言基础" class="headerlink" title="C++语言基础"></a>C++语言基础</h1><h2 id="1、虚函数与纯虚函数的区别"><a href="#1、虚函数与纯虚函数的区别" class="headerlink" title="1、虚函数与纯虚函数的区别"></a>1、虚函数与纯虚函数的区别</h2><ol>
<li>虚函数就是在普通函数之前加上关键字virtual，他有自己具体的实现。纯虚函数是在虚函数的基础上在表达式后面加上&#x3D;0，且纯虚函数没有具体的实现。具有纯虚函数的类被称为抽象类，抽象类不能实例化对象。重写了纯虚函数的派生类才可以实例化对象。</li>
<li>子类继承父类时，如果父类有虚函数，子类可以重写父类的虚函数，也可以不重写，不重写时调用的是父类的虚函数。如果父类有纯虚函数，子类必须重写。</li>
<li>虚函数是一个可以被调用的函数，纯虚函数仅仅是一个API，需要被派生类自行定义。</li>
</ol>
<h2 id="2、CPP怎么实现多态？"><a href="#2、CPP怎么实现多态？" class="headerlink" title="2、CPP怎么实现多态？"></a>2、CPP怎么实现多态？</h2><p>1、函数重载：通过在同一个作用域内定义多个同名函数，但是参数类型和数量不同，编译器会根据调用时提供的参数来决定调用哪个函数版本。</p>
<p>2、运算符重载：允许定义或修改大部分运算符的默认行为。</p>
<p>3、模板：通过模板函数或模板类，可以编写泛型代码，实现对多种类型的操作，而无需知道这些类型的具体细节。</p>
<p>4、抽象基类：使用包含纯虚函数的类作为接口，强制派生类提供纯虚函数的具体实现。</p>
<p>5、动态多态：除了虚函数外，还可以通过指针或引用传递基类类型的对象，而在运行时根据对象的实际类型来调用相应的成员函数，这通常与虚函数一起使用。</p>
<p>6、静态多态：也称为编译时多态，包括函数重载和模版，由于在编译时已经确定了调用哪个函数，所以称为静态多态。</p>
<h2 id="3、new-和-malloc的区别"><a href="#3、new-和-malloc的区别" class="headerlink" title="3、new 和 malloc的区别"></a>3、new 和 malloc的区别</h2><p>1、new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。</p>
<p>  2、使⽤new操作符申请内存分配时⽆须指定内存块的⼤⼩，⽽malloc则需要显式地指出所需内存的尺⼨。 </p>
<p> 3、opeartor new &#x2F;operator delete可以被᯿载，⽽malloc&#x2F;free并不允许᯿载。 </p>
<p> 4、new&#x2F;delete会调⽤对象的构造函数&#x2F;析构函数以完成对象的构造&#x2F;析构。⽽malloc则不会  </p>
<p>5、malloc与free是C++&#x2F;C语⾔的标准库函数,new&#x2F;delete是C++的运算符  </p>
<p>6、new操作符从⾃由存储区上为对象动态分配内存空间，⽽malloc函数从堆上动态分配内存。</p>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="1、进程和线程的区别"><a href="#1、进程和线程的区别" class="headerlink" title="1、进程和线程的区别"></a>1、进程和线程的区别</h2><p>进程是系统进行资源分配和调度的基本单位。</p>
<p>线程是操作系统能够进行运算调度的最小单位。线程是进程的子任务，是进程内的执行单元。一个进程至少有一个线程，一个进程可以运行多个线程，这些线程共享一块内存。</p>
<p>资源开销：</p>
<p>进程：由于每个进程都有独立的内存空间，创建和销毁进程的开销较大。进程间切换需要保存和恢复整个进程的状态，因此上下文切换的开销较高。</p>
<p>线程：线程共享相同的内存空间，创建和销毁线程的开销较小。线程间切换只需保存和恢复少量的线程上下文，因此上下文的切换开销较小。</p>
<p>通信与同步:</p>
<p>进程：由于进程间相互隔离，进程之间的通信需要一些特殊机制，如管道、消息队列、共享内存等方式。</p>
<p>线程：由于线程共享相同的内存空间，他们之间可以直接访问共享数据，线程间通信更加方便。</p>
<p>安全性：</p>
<p>进程：由于进程间相互隔离，一个进程的崩溃不会影响其他进程的稳定性。</p>
<p>线程：由于线程共享相同的内存空间，一个线程的错误可能会影响整个进程的稳定性。</p>
<h2 id="2、进程的调度算法你了解多少？"><a href="#2、进程的调度算法你了解多少？" class="headerlink" title="2、进程的调度算法你了解多少？"></a>2、进程的调度算法你了解多少？</h2><p>进程都希望自己能够占用 CPU 进行工作，那么这涉及到前面说过的进程上下文切换。</p>
<p>一旦操作系统把进程切换到运行状态，也就意味着该进程占用着 CPU 在执行，但是当操作系统把进程切换到其他状态时，那就不能在 CPU 中执行了，于是操作系统会选择下一个要运行的进程，选择一个进程运行这一功能是在操作系统中完成的，通常称为<strong>调度程序</strong></p>
<p>01、先来先服务调度算法（FCFS）</p>
<p>顾名思义，先来后到，<strong>每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。</strong></p>
<p>这似乎很公平，但是当一个长作业先运行了，那么后面的短作业等待的时间就会很长，不利于短作业。</p>
<p>FCFS 对长作业有利，适用于 CPU 繁忙型作业的系统，而不适用于 I&#x2F;O 繁忙型作业的系统。</p>
<p>02、最短作业优先调度算法</p>
<p><strong>最短作业优先（*Shortest Job First, SJF*）调度算法</strong>同样也是顾名思义，它会<strong>优先选择运行时间最短的进程来运行</strong>，这有助于提高系统的吞吐量。</p>
<p>这显然对长作业不利，很容易造成一种极端现象。比如，一个长作业在就绪队列等待运行，而这个就绪队列有非常多的短作业，那么就会使得长作业不断的往后推，周转时间变长，致使长作业长期不会被运行。</p>
<p>03、高响应比优先调度算法</p>
<p>前面两种没有权衡长短作业的利弊，那么，<strong>高响应比优先 （*Highest Response Ratio Next, HRRN*）调度算法</strong>主要是权衡了短作业和长作业。<strong>每次进行进程调度时，先计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行</strong>。</p>
<p>优先权 &#x3D; （等待时间+要求服务时间）&#x2F;要求服务时间</p>
<ul>
<li>如果两个进程的「等待时间」相同时，「要求的服务时间」越短，「响应比」就越高，这样短作业的进程容易被选中运行；</li>
<li>如果两个进程「要求的服务时间」相同时，「等待时间」越长，「响应比」就越高，这就兼顾到了长作业进程，因为进程的响应比可以随时间等待的增加而提高，当其等待时间足够长时，其响应比便可以升到很高，从而获得运行的机会</li>
</ul>
<p>一个进程的要求服务时间是不可预估的，所以高响应比优先调度算法是理想算法，现实中实现不了。</p>
<p>04、时间片轮转调度算法</p>
<p>最古老、最简单、最公平且使用最广的算法就是<strong>时间片轮转（*Round Robin, RR*）调度算法</strong>。</p>
<p><strong>每个进程被分配一个时间段，称为时间片（*Quantum*），即允许该进程在该时间段中运行。</strong></p>
<ul>
<li>如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配给另外一个进程；</li>
<li>如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换；</li>
</ul>
<p>另外，时间片的长度就是一个很关键的点：</p>
<ul>
<li>如果时间片设得太短会导致过多的进程上下文切换，降低了 CPU 效率；</li>
<li>如果设得太长又可能引起对短作业进程的响应时间变长。</li>
</ul>
<p>一般来说，时间片设为 <code>20ms~50ms</code> 通常是一个比较合理的折中值。</p>
<p>05、最高优先级调度算法</p>
<p>前面的「时间片轮转算法」做了个假设，即让所有的进程同等重要，也不偏袒谁，大家的运行时间都一样。</p>
<p>但是，对于多用户计算机系统就有不同的看法了，它们希望调度是有优先级的，即希望调度程序能<strong>从就绪队列中选择最高优先级的进程进行运行，这称为最高优先级（*Highest Priority First，HPF*）调度算法</strong>。</p>
<p>进程的优先级可以分为，静态优先级和动态优先级：</p>
<ul>
<li>静态优先级：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化；</li>
<li>动态优先级：根据进程的动态变化调整优先级，比如如果进程运行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升高其优先级，也就是<strong>随着时间的推移增加等待进程的优先级</strong>。</li>
</ul>
<p>该算法也有两种处理优先级高的方法，非抢占式和抢占式：</p>
<ul>
<li>非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程。</li>
<li>抢占式：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。</li>
</ul>
<p>但是依然有缺点，可能会导致低优先级的进程永远不会运行。</p>
<p>06、多级反馈队列调度算法</p>
<p><strong>多级反馈队列（*Multilevel Feedback Queue*）调度算法</strong>是「时间片轮转算法」和「最高优先级算法」的综合和发展。</p>
<p>顾名思义：</p>
<ul>
<li><p>「多级」表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短。</p>
</li>
<li><p>「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列；</p>
</li>
<li><p>设置了多个队列，赋予每个队列不同的优先级，每个<strong>队列优先级从高到低</strong>，同时<strong>优先级越高时间片越短</strong>；</p>
</li>
<li><p>新的进程会被放入到第一级队列的末尾，按先来先服务的原则排队等待被调度，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成；</p>
</li>
<li><p>当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行；</p>
</li>
</ul>
<p>可以发现，对于短作业可能可以在第一级队列很快被处理完。对于长作业，如果在第一级队列处理不完，可以移入下次队列等待被执行，虽然等待的时间变长了，但是运行时间也变更长了，所以该算法很好的<strong>兼顾了长短作业，同时有较好的响应时间。</strong></p>
<h2 id="3、进程间有哪些通信方式"><a href="#3、进程间有哪些通信方式" class="headerlink" title="3、进程间有哪些通信方式?"></a>3、进程间有哪些通信方式?</h2><p>每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以进程之间要通信必须通过内核。</p>
<p>1、管道（匿名管道</p>
<p>半双工的通信方式，数据只能单向流动而且只能在具有父子进程关系的进程间使用。使用 <code>fork</code> 创建子进程，<strong>创建的子进程会复制父进程的文件描述符</strong>，这样就做到了两个进程各有两个「 <code>fd[0]</code> 与 <code>fd[1]</code>」，两个进程就可以通过各自的 fd 写入和读取同一个管道文件实现跨进程通信了。</p>
<p>2、命名管道</p>
<p>也叫做FIFO，也是半双工通信方式，但是允许无亲缘关系的进程之间的提通信。</p>
<p><strong>管道这种通信方式效率低，不适合进程间频繁地交换数据</strong>。当然，它的好处，自然就是简单，同时也我们很容易得知管道里的数据已经被另一个进程读取了。</p>
<p>不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循<strong>先进先出</strong>原则，不支持 lseek 之类的文件定位操作</p>
<p>3、消息队列</p>
<p>前面说到管道的通信方式是效率低的，因此管道不适合进程间频繁地交换数据。</p>
<p>对于这个问题，<strong>消息队列</strong>的通信模式就可以解决。比如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。同理，B 进程要给 A 进程发送消息也是如此。</p>
<p>再来，<strong>消息队列是保存在内核中的消息链表</strong>，在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。</p>
<p>消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在，而前面提到的匿名管道的生命周期，是随进程的创建而建立，随进程的结束而销毁。</p>
<p>消息这种模型，两个进程之间的通信就像平时发邮件一样，你来一封，我回一封，可以频繁沟通了。</p>
<p>但邮件的通信方式存在不足的地方有两点，<strong>一是通信不及时，二是附件也有大小限制</strong>，这同样也是消息队列通信不足的点。</p>
<p><strong>消息队列不适合比较大数据的传输</strong>，因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限。在 Linux 内核中，会有两个宏定义 <code>MSGMAX</code> 和 <code>MSGMNB</code>，它们以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度。</p>
<p><strong>消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销</strong>，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。</p>
<p>4、共享内存</p>
<p>消息队列的读取和写入的过程，都会有发生用户态与内核态之间的消息拷贝过程。那<strong>共享内存</strong>的方式，就很好的解决了这一问题。</p>
<p>现代操作系统，对于内存管理，采用的是虚拟内存技术，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程 A 和 进程 B 的虚拟地址是一样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。</p>
<p><strong>共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中</strong>。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。</p>
<p>5、信号量</p>
<p>用了共享内存通信方式，带来新的问题，那就是如果多个进程同时修改同一个共享内存，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。</p>
<p>为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，<strong>信号量</strong>就实现了这一保护机制。</p>
<p><strong>信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据</strong>。</p>
<p>信号量表示资源的数量，控制信号量的方式有两种原子操作：</p>
<ul>
<li>一个是 <strong>P 操作</strong>，这个操作会把信号量减去 1，相减后如果信号量 &lt; 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 &gt;&#x3D; 0，则表明还有资源可使用，进程可正常继续执行。</li>
<li>另一个是 <strong>V 操作</strong>，这个操作会把信号量加上 1，相加后如果信号量 &lt;&#x3D; 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程；</li>
</ul>
<p>P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。</p>
<p>信号初始化为 <code>1</code>，就代表着是<strong>互斥信号量</strong>，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。</p>
<p>我们可以初始化信号量为 <code>0</code>，就可以用信号量来实现多进程同步的方式，它可以保证进程 A 应在进程 B 之前执行。</p>
<p>6、信号</p>
<p>上面说的进程间通信，都是常规状态下的工作模式。<strong>对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。</strong></p>
<p>信号跟信号量虽然名字相似度 66.66%，但两者用途完全不一样，就好像 Java 和 JavaScript 的区别。</p>
<p>在 Linux 操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义。我们可以通过 <code>kill -l</code> 命令，查看所有的信号：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">kill</span> -l</span><br> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP<br> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1<br>11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM<br>16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP<br>21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ<br>26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR<br>31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3<br>38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8<br>43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13<br>48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12<br>53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7<br>58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2<br>63) SIGRTMAX-1  64) SIGRTMAX<br></code></pre></td></tr></table></figure>

<p>运行在 shell 终端的进程，我们可以通过键盘输入某些组合键的时候，给进程发送信号。例如</p>
<ul>
<li>Ctrl+C 产生 <code>SIGINT</code> 信号，表示终止该进程；</li>
<li>Ctrl+Z 产生 <code>SIGTSTP</code> 信号，表示停止该进程，但还未结束；</li>
</ul>
<p>如果进程在后台运行，可以通过 <code>kill</code> 命令的方式给进程发送信号，但前提需要知道运行中的进程 PID 号，例如：</p>
<ul>
<li>kill -9 1050 ，表示给 PID 为 1050 的进程发送 <code>SIGKILL</code> 信号，用来立即结束该进程；</li>
</ul>
<p>所以，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令）。</p>
<p>信号是进程间通信机制中<strong>唯一的异步通信机制</strong>，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。</p>
<p><strong>1.执行默认操作</strong>。Linux 对每种信号都规定了默认操作，例如，上面列表中的 SIGTERM 信号，就是终止进程的意思。</p>
<p><strong>2.捕捉信号</strong>。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。</p>
<p><strong>3.忽略信号</strong>。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 <code>SIGKILL</code> 和 <code>SEGSTOP</code>，它们用于在任何时候中断或结束某一进程。</p>
<p>7、socket套接字</p>
<p>前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想<strong>跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。</strong></p>
<p>实际上，Socket 通信不仅可以跨网络与不同主机的进程间通信，还可以在同主机上进程间通信。</p>
<p>我们来看看创建 socket 的系统调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">socket</span><span class="hljs-params">(<span class="hljs-type">int</span> domain, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span> protocal)</span><br></code></pre></td></tr></table></figure>

<p>三个参数分别代表：</p>
<ul>
<li>domain 参数用来指定协议族，比如 AF_INET 用于 IPV4、AF_INET6 用于 IPV6、AF_LOCAL&#x2F;AF_UNIX 用于本机；</li>
<li>type 参数用来指定通信特性，比如 SOCK_STREAM 表示的是字节流，对应 TCP、SOCK_DGRAM 表示的是数据报，对应 UDP、SOCK_RAW 表示的是原始套接字；</li>
<li>protocal 参数原本是用来指定通信协议的，但现在基本废弃。因为协议已经通过前面两个参数指定完成，protocol 目前一般写成 0 即可；</li>
</ul>
<p>根据创建 socket 类型的不同，通信的方式也就不同：</p>
<ul>
<li>实现 TCP 字节流通信： socket 类型是 AF_INET 和 SOCK_STREAM；</li>
<li>实现 UDP 数据报通信：socket 类型是 AF_INET 和 SOCK_DGRAM；</li>
<li>实现本地进程间通信： 「本地字节流 socket 」类型是 AF_LOCAL 和 SOCK_STREAM，「本地数据报 socket 」类型是 AF_LOCAL 和 SOCK_DGRAM。另外，AF_UNIX 和 AF_LOCAL 是等价的，所以 AF_UNIX 也属于本地 socket；</li>
</ul>
<p>总结</p>
<p>由于每个进程的用户空间都是独立的，不能相互访问，这时就需要借助内核空间来实现进程间通信，原因很简单，每个进程都是共享一个内核空间。</p>
<p>Linux 内核提供了不少进程间通信的方式，其中最简单的方式就是管道，管道分为「匿名管道」和「命名管道」。</p>
<p><strong>匿名管道</strong>顾名思义，它没有名字标识，匿名管道是特殊文件只存在于内存，没有存在于文件系统中，shell 命令中的「<code>|</code>」竖线就是匿名管道，通信的数据是<strong>无格式的流并且大小受限</strong>，通信的方式是<strong>单向</strong>的，数据只能在一个方向上流动，如果要双向通信，需要创建两个管道，再来<strong>匿名管道是只能用于存在父子关系的进程间通信</strong>，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失。</p>
<p><strong>命名管道</strong>突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用命名管道的前提，需要在文件系统创建一个类型为 p 的设备文件，那么毫无关系的进程就可以通过这个设备文件进行通信。另外，不管是匿名管道还是命名管道，进程写入的数据都是<strong>缓存在内核</strong>中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循<strong>先进先出</strong>原则，不支持 lseek 之类的文件定位操作。</p>
<p><strong>消息队列</strong>克服了管道通信的数据是无格式的字节流的问题，消息队列实际上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数据类型，发送数据时，会被分成一个一个独立的消息体，当然接收数据时，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的数据是正确的。消息队列通信的速度不是最及时的，毕竟<strong>每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程。</strong></p>
<p><strong>共享内存</strong>可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，<strong>它直接分配一个共享空间，每个进程都可以直接访问</strong>，就像访问进程自己的空间一样快捷方便，不需要陷入内核态或者系统调用，大大提高了通信的速度，享有<strong>最快</strong>的进程间通信方式之名。但是便捷高效的共享内存通信，<strong>带来新的问题，多进程竞争同个共享资源会造成数据的错乱。</strong></p>
<p>那么，就需要<strong>信号量</strong>来保护共享资源，以确保任何时刻只能有一个进程访问共享资源，这种方式就是互斥访问。<strong>信号量不仅可以实现访问的互斥性，还可以实现进程间的同步</strong>，信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 <strong>P 操作和 V 操作</strong>。</p>
<p>与信号量名字很相似的叫<strong>信号</strong>，它俩名字虽然相似，但功能一点儿都不一样。信号是<strong>异步通信机制</strong>，信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令），一旦有信号发生，<strong>进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、3. 忽略信号</strong>。有两个信号是应用进程无法捕捉和忽略的，即 <code>SIGKILL</code> 和 <code>SIGSTOP</code>，这是为了方便我们能在任何时候结束或停止某个进程。</p>
<p>前面说到的通信机制，都是工作于同一台主机，如果<strong>要与不同主机的进程间通信，那么就需要 Socket 通信了</strong>。Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。</p>
<p>以上，就是进程间通信的主要机制了。你可能会问了，那线程通信间的方式呢？</p>
<p>同个进程下的线程之间都是共享进程的资源，只要是共享变量都可以做到线程间通信，比如全局变量，所以对于线程间关注的不是通信方式，而是关注多线程竞争共享资源的问题，信号量也同样可以在线程间实现互斥与同步：</p>
<ul>
<li>互斥的方式，可保证任意时刻只有一个线程访问共享资源；</li>
<li>同步的方式，可保证线程 A 应在线程 B 之前执行；</li>
</ul>
<h2 id="4、什么是死锁以及如何避免死锁？"><a href="#4、什么是死锁以及如何避免死锁？" class="headerlink" title="4、什么是死锁以及如何避免死锁？"></a>4、什么是死锁以及如何避免死锁？</h2><p><strong>死锁是指两个或多个线程在争夺系统资源时，由于相互等待对方释放资源而无法继续执行的状态。</strong></p>
<p>在多线程编程中，我们为了防止多线程竞争共享资源而导致数据错乱，都会在操作共享资源之前加上互斥锁，只有成功获得到锁的线程，才能操作共享资源，获取不到锁的线程就只能等待，直到锁被释放。</p>
<p>那么，当两个线程为了保护两个不同的共享资源而使用了两个互斥锁，那么这两个互斥锁应用不当的时候，可能会造成<strong>两个线程都在等待对方释放锁</strong>，在没有外力的作用下，这些线程会一直相互等待，就没办法继续运行，这种情况就是发生了<strong>死锁</strong></p>
<p>死锁只有<strong>同时满足</strong>以下四个条件才会发生：</p>
<ul>
<li>互斥条件：多个线程不能同时使用同一个资源</li>
<li>持有并等待条件：一个线程因为请求另外的资源被阻塞的时候，不会释放自己目前持有的资源。</li>
<li>不可剥夺条件：资源不能被强制性的从一个进程中夺走，只能由持有者资源释放释放。</li>
<li>环路等待条件：多个进程之间形成一个环形等待资源的链路，每个进程都在等待下一个进程释放自己所占有的资源</li>
</ul>
<p>只要破坏上面任意一个条件就可以破坏死锁。</p>
<p>破坏请求与保持条件：一次性申请所有的资源</p>
<p>破坏不可剥夺条件：占用资源的线程在申请其他资源被堵塞时，可以主动释放他已经占有的资源。</p>
<p>破坏循环等待条件：使用资源有序分配法，让所有进程按照相同的顺序请求资源，释放资源则反序释放。</p>
<p>总结：</p>
<p>简单来说，死锁问题的产生是由两个或者以上线程并行执行的时候，争夺资源而互相等待造成的。</p>
<p>死锁只有同时满足互斥、持有并等待、不可剥夺、环路等待这四个条件的时候才会发生。</p>
<p>所以要避免死锁问题，就是要破坏其中一个条件即可，<strong>最常用的方法就是使用资源有序分配法来破坏环路等待条件</strong></p>
<h2 id="5、什么是虚拟内存，为什么需要虚拟内存？"><a href="#5、什么是虚拟内存，为什么需要虚拟内存？" class="headerlink" title="5、什么是虚拟内存，为什么需要虚拟内存？"></a><strong>5、什么是虚拟内存，为什么需要虚拟内存？</strong></h2><p>虚拟内存在每一个进程创建加载的过程中，会分配一个连续的虚拟地址空间，他不是真实存在的，而是通过映射与实际地址空间对应，这样就可以是每个进程看起来都有自己独立的连续地址空间，并允许程序访问比物理内存更大的地址空间，每个程序都可以认为它拥有足够大的内存来运行。</p>
<p>需要虚拟内存有以下原因：</p>
<p>内存扩展：虚拟内存使得每个程序可以使用比实际可用内存更大的内存，从而允许运行更大的程序或处理更多的数据。</p>
<p>内存隔离：虚拟内存还提供了进程之间的内存隔离，每个进程都有自己的虚拟地址空间，因此一个进程无法直接访问另一个进程的内存。</p>
<p>物理内存管理：虚拟内存允许操作系统动态的将数据和程序的部分加载到物理内存中，以满足当前正在运行的进程的需求。当物理内存不足时，操作系统可以将不常用的数据或程序暂时移到硬盘上，从而释放内存，以便其他进程使用。</p>
<p>页面交换：当物理内存不足时，操作系统可以将一部分数据从物理内存写入到硬盘的虚拟内存中，这个过程被称为页面交换，当需要时，数据可以再次从虚拟内存中加载到物理内存中。这样可以保证系统可以继续运行，尽管物理内存有限。</p>
<p>内存映射文件：虚拟内存还可以用于将文件映射到内存中，这使得文件的读取和写入可以像访问内存一样高效。</p>
<h2 id="6、什么是内存分段和内存分页，作用是什么？"><a href="#6、什么是内存分段和内存分页，作用是什么？" class="headerlink" title="6、什么是内存分段和内存分页，作用是什么？"></a>6、什么是内存分段和内存分页，作用是什么？</h2><p><strong>核心功能是管理虚拟地址与物理地址的之间的映射关系</strong>。</p>
<p><strong>内存分段</strong>：将一个程序的内存空间分为不同的逻辑段（segments），每个段代表程序的一个功能模块或者数据类型，比如代码段、数据段、堆栈段等。每个段都有其自己的大小和权限。</p>
<p><strong>内存分页</strong>：把整个虚拟和物理空间分成固定大小的页（4KB），这样一个连续且大小固定的内存空间，称之为页。</p>
<p>作用：</p>
<p>1、<strong>逻辑隔离</strong>：内存分段和分页都实现了程序的逻辑隔离，使不同的功能模块或数据类型能够被单独的管理和保护，提高了程序的可靠性与安全性。</p>
<p>2、<strong>内存保护</strong>：通过将不同的段或页面设置为只读、可读写、不可执行等权限，操作系统可以确保程序不会越界访问或修改其他段的内容，从而提高了系统的稳定性。</p>
<p>3、<strong>虚拟内存</strong>：分段和分页都是为了实现虚拟内存的概念，允许应用程序认为他们使用的是一个比实际物理内存更大的内存空间。</p>
<p>4、<strong>内存共享</strong>：通过分页，操作系统可以实现内存页面的共享，从而节省内存空间，多个进程可以共享相同的代码段或数据页面。</p>
<p>5、<strong>内存管理</strong>：分页更加灵活，允许操作系统将不同进程的页面分散存放在物理内存中，从而提高内存利用率。分段则更适用于管理不同的逻辑模块。</p>
<p>分段和分页的区别：</p>
<p>分页对用户不可见，分段对用户可见。</p>
<p>分页的地址空间是一维的，分段的地址空间是二维的。</p>
<p>分页（单级页表）以及分段访问一个逻辑地址都需要两次访存，分段存储中可以引入快表机制</p>
<p>分段更容易实现信息的共享和保护</p>
<p>分段与分页的优缺点：</p>
<p>分页：内存空间利用率高，不会产生外部碎片，只会有少量的页内碎片，但不方便按照逻辑模块实现信息的共享与保护。</p>
<p>分段：方便按照逻辑模块实现信息的共享与保护，但是如果段长过大，为其分配很大的连续空间很不方便，且会产生外部碎片。</p>
<p><strong>7、解释一下用户态和内核态</strong></p>
<p><strong>用户态和内核态是操作系统中两种不同的执行模式，用于控制进程或程序对计算机硬件资源的访问权限和操作范围。</strong></p>
<p>用户态：在用户态下，进程或程序只能访问受限的资源和执行受限的指令集，不能直接访问操作系统的核心部分，也不能直接访问硬件资源，用户态下的CPU不能独占，允许被其他程序获取。</p>
<p>内核态：内核态是操作系统的特权级别，允许进程或程序执行特权指令和访问操作系统的核心部分。在内核态下，进程可以直接访问硬件资源，执行系统调用，管理内存、文件系统等操作。处于内核态的CPU可以从一个程序切换到另一个程序，并且占用CPU不会发生被抢占的情况。</p>
<p>用户空间的代码只能访问一个局部的内存空间，而内核空间的代码可以访问所有内存空间。因此，当程序使用用户空间时，我们常说该程序在<strong>用户态</strong>执行，而当程序使内核空间时，程序则在<strong>内核态</strong>执行。<strong>应用程序如果需要进入内核空间，就需要通过系统调用</strong>，内核程序执行在内核态，用户程序执行在用户态。<strong>当应用程序使用系统调用时，会产生一个中断</strong>。发生中断后， CPU 会中断当前在执行的用户程序，转而跳转到中断处理程序，也就是开始执行内核程序。内核处理完后，主动触发中断，把 CPU 执行权限交回给用户程序，回到用户态继续工作。</p>
<p>8、解释一下页面置换算法，例如LRU，FIFO等</p>
<p>在了解内存页面置换算法前，我们得先谈一下<strong>缺页异常（缺页中断）</strong>。</p>
<p>当 CPU 访问的页面不在物理内存时，便会产生一个缺页中断，请求操作系统将所缺页调入到物理内存。那它与一般中断的主要区别在于：</p>
<ul>
<li>缺页中断在指令执行「期间」产生和处理中断信号，而一般中断在一条指令执行「完成」后检查和处理中断信号。</li>
<li>缺页中断返回到该指令的开始重新执行「该指令」，而一般中断返回回到该指令的「下一个指令」执行。</li>
</ul>
<p><strong>缺页中断的处理流程</strong>：</p>
<ol>
<li>在 CPU 里访问一条 Load M 指令，然后 CPU 会去找 M 所对应的页表项。</li>
<li>如果该页表项的状态位是「有效的」，那 CPU 就可以直接去访问物理内存了，如果状态位是「无效的」，则 CPU 则会发送缺页中断请求。</li>
<li>操作系统收到了缺页中断，则会执行缺页中断处理函数，先会查找该页面在磁盘中的页面的位置。</li>
<li>找到磁盘中对应的页面后，需要把该页面换入到物理内存中，但是在换入前，需要在物理内存中找空闲页，如果找到空闲页，就把页面换入到物理内存中。</li>
<li>页面从磁盘换入到物理内存完成后，则把页表项中的状态位修改为「有效的」。</li>
<li>最后，CPU 重新执行导致缺页异常的指令。</li>
</ol>
<p>上面所说的过程，第 4 步是能在物理内存找到空闲页的情况，那如果找不到呢？</p>
<p>找不到空闲页的话，就说明此时内存已满了，这时候，就需要「页面置换算法」选择一个物理页，如果该物理页有被修改过（脏页），则把它换出到磁盘，然后把该被置换出去的页表项的状态改成「无效的」，最后把正在访问的页面装入到这个物理页中。如果没有修改，在置换该页时就不需要将该页写回到磁盘上，以减少系统的开销。</p>
<p>所以，页面置换算法的功能是，<strong>当出现缺页异常，需调入新页面而内存已满时，选择被置换的物理页面</strong>，也就是说选择一个物理页面换出到磁盘，然后把需要访问的页面换入到物理页，算法的目标是尽量减少页面的换入换出次数，减少系统的开销。</p>
<p>1、最佳置换算法</p>
<p>根据未来页面的访问情况，选择最长时间内不会被访问到的页面进行置换。那么就产生一个问题了，未来要访问什么页面操作系统如何未卜先知呢？所以该算法属于理想情况，用来衡量算法的优劣，越接近该算法的效率越高。</p>
<p>2、先进先出置换算法</p>
<p><strong>选择在内存驻留时间很长的页面进行中置换</strong>，这个就是「先进先出置换」算法的思想。但是FIFO算法可能会淘汰经常被使用的角色，导致切换次数增加。而且FIFO算法有可能出现贝拉迪异常：当分配给内存的空间增加时，切换次数反而增加了。</p>
<p>3、最近最久未使用算法（最近最少使用）</p>
<p>最近最久未使用（<em>LRU</em>）的置换算法的基本思路是，发生缺页时，<strong>选择最长时间没有被访问的页面进行置换</strong>，也就是说，该算法假设已经很久没有使用的页面很有可能在未来较长的一段时间内仍然不会被使用。</p>
<p>虽然 LRU 在理论上是可以实现的，但代价很高。为了完全实现 LRU，需要在内存中维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。困难的是，在每次访问内存时都必须要更新「整个链表」。在链表中找到一个页面，删除它，然后把它移动到表头是一个非常费时的操作。</p>
<p>所以，LRU 虽然看上去不错，但是由于开销比较大，实际应用中比较少使用。</p>
<p>4、时钟页面置换算法</p>
<p>那有没有一种即能优化置换的次数，也能方便实现的算法呢？</p>
<p><strong>时钟页面置换算法就可以两者兼得，它跟 LRU 近似，又是对 FIFO 的一种改进。</strong></p>
<p>该算法的思路是，把所有的页面都保存在一个类似钟面的「环形链表」中，一个表针指向最老的页面。</p>
<p>当发生缺页中断时，算法首先检查表针指向的页面：</p>
<ul>
<li>如果它的访问位位是 0 就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置；</li>
<li>如果访问位是 1 就清除访问位，并把表针前移一个位置，重复这个过程直到找到了一个访问位为 0 的页面为止；</li>
</ul>
<p>5、最不常用算法（LFU）</p>
<p><strong>当发生缺页中断时，选择「访问次数」最少的那个页面，并将其淘汰</strong>。</p>
<p>它的实现方式是，对每个页面设置一个「访问计数器」，每当一个页面被访问时，该页面的访问计数器就累加 1。在发生缺页中断时，淘汰计数器值最小的那个页面。</p>
<p>看起来很简单，每个页面加一个计数器就可以实现了，但是在操作系统中实现的时候，我们需要考虑效率和硬件成本的。</p>
<p>要增加一个计数器来实现，这个硬件成本是比较高的，另外如果要对这个计数器查找哪个页面访问次数最小，查找链表本身，如果链表长度很大，是非常耗时的，效率不高。</p>
<p>但还有个问题，LFU 算法只考虑了频率问题，没考虑时间的问题，比如有些页面在过去时间里访问的频率很高，但是现在已经没有访问了，而当前频繁访问的页面由于没有这些页面访问的次数高，在发生缺页中断时，就会可能会误伤当前刚开始频繁访问，但访问次数还不高的页面。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>八股基础</div>
      <div>http://example.com/2024/05/10/八股基础/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>ZDS</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年5月10日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/05/09/%E6%B0%B4%E4%B8%8B%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%B2%B8%E5%9F%BA%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91/" title="水下机器人岸基客户端开发">
                        <span class="hidden-mobile">水下机器人岸基客户端开发</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>

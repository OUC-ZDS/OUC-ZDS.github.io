

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/icon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="ZDS">
  <meta name="keywords" content="">
  
    <meta name="description" content="计算机网络1、从输入URL到页面展示期间发生了什么？（1）检查缓存：浏览器收到用户请求后，先检查浏览器缓存里是否有该资源，如果有直接返回；如果没有，进入下一步网络请求。 （2）DNS域名解析：进行网络请求之前需要获取请求域名的IP地址，（HTTP协议）。如果是HTTPS，还需要建立TLS连接。DNS解析时会按照本地浏览器缓存-&gt;本地HOST文件-&gt;路由器缓存-&gt;DNS服务器-&amp;g">
<meta property="og:type" content="article">
<meta property="og:title" content="八股基础">
<meta property="og:url" content="http://example.com/2024/05/10/%E5%85%AB%E8%82%A1%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="佑安的个人博客">
<meta property="og:description" content="计算机网络1、从输入URL到页面展示期间发生了什么？（1）检查缓存：浏览器收到用户请求后，先检查浏览器缓存里是否有该资源，如果有直接返回；如果没有，进入下一步网络请求。 （2）DNS域名解析：进行网络请求之前需要获取请求域名的IP地址，（HTTP协议）。如果是HTTPS，还需要建立TLS连接。DNS解析时会按照本地浏览器缓存-&gt;本地HOST文件-&gt;路由器缓存-&gt;DNS服务器-&amp;g">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-05-10T11:48:02.000Z">
<meta property="article:modified_time" content="2024-05-28T03:07:42.736Z">
<meta property="article:author" content="ZDS">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>八股基础 - 佑安的个人博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>佑安的个人博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="八股基础"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-05-10 19:48" pubdate>
          2024年5月10日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          34k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          283 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">八股基础</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="1、从输入URL到页面展示期间发生了什么？"><a href="#1、从输入URL到页面展示期间发生了什么？" class="headerlink" title="1、从输入URL到页面展示期间发生了什么？"></a>1、从输入URL到页面展示期间发生了什么？</h2><p>（1）<strong>检查缓存</strong>：浏览器收到用户请求后，先检查浏览器缓存里是否有该资源，如果有直接返回；如果没有，进入下一步网络请求。</p>
<p>（2）<strong>DNS域名解析</strong>：进行网络请求之前需要获取请求域名的IP地址，（HTTP协议）。如果是HTTPS，还需要建立TLS连接。DNS解析时会按照本地浏览器缓存-&gt;本地HOST文件-&gt;路由器缓存-&gt;DNS服务器-&gt;根DNS服务器的顺序查询域名对应IP地址，直到找到为止。</p>
<p>DNS 中的域名都是用<strong>句点</strong>来分隔的，比如 <code>www.server.com.</code>，这里的句点代表了不同层次之间的<strong>界限</strong>。在域名中，<strong>越靠右</strong>的位置表示其层级<strong>越高</strong>。</p>
<p>（3）<strong>浏览器与服务器IP建立TCP连接</strong>（可靠传输）：建立连接后，浏览器端构建请求行、请求头等信息，并把和该域名相关的Cookie等数据附加到请求头中，向服务器构建请求信息。（由协议栈（TCP、IP)提供可靠传输–&gt;IP（远程定位）–&gt;MAC（两点传输）–&gt;网卡–&gt;交换机–&gt;路由器）</p>
<p>（4）<strong>服务器收到请求信息，根据请求生成响应数据，发给浏览器</strong>。</p>
<p>（5）<strong>浏览器解析服务器的响应数据</strong>：若响应头状态码为301、302，会重新定向到新地址（IP中的ICMP、ARP功能）；若响应数据类型是字节流类型，一般会将请求交给下载管理器；若是HTML类型，会进入下一步渲染流程。</p>
<p>（6）<strong>浏览器解析HTML文件</strong>，创建DOM树，解析CSS进行样式计算，然后将CSS与DOM合并，构建渲染树，最后布局和绘制渲染树，完成页面展示。</p>
<h2 id="2、HTTP常见面试题"><a href="#2、HTTP常见面试题" class="headerlink" title="2、HTTP常见面试题"></a>2、HTTP常见面试题</h2><h3 id="（1）什么是HTTP（超文本传输协议）"><a href="#（1）什么是HTTP（超文本传输协议）" class="headerlink" title="（1）什么是HTTP（超文本传输协议）"></a>（1）什么是HTTP（超文本传输协议）</h3><p>超文本：文字、图片、视频的混合体</p>
<p>传输：计算机世界中实现两点之间传输</p>
<p>协议：计算机世界里的约定和规范</p>
<p>即<strong>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</strong></p>
<h3 id="（2）HTTP常见的状态码有哪些"><a href="#（2）HTTP常见的状态码有哪些" class="headerlink" title="（2）HTTP常见的状态码有哪些"></a>（2）HTTP常见的状态码有哪些</h3><p><code>1xx</code> 类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少。</p>
<p><code>2xx</code> 类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态。</p>
<ul>
<li>「<strong>200 OK</strong>」是最常见的成功状态码，表示一切正常。如果是非 <code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据。</li>
<li>「<strong>204 No Content</strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</li>
<li>「<strong>206 Partial Content</strong>」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li>
</ul>
<p><code>3xx</code> 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</p>
<ul>
<li>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</li>
<li>「<strong>302 Found</strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</li>
</ul>
<p>301 和 302 都会在响应头里使用字段 <code>Location</code>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p>
<ul>
<li>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。</li>
</ul>
<p><code>4xx</code> 类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</p>
<ul>
<li>「<strong>400 Bad Request</strong>」表示客户端请求的报文有错误，但只是个笼统的错误。</li>
<li>「<strong>403 Forbidden</strong>」表示服务器禁止访问资源，并不是客户端的请求出错。</li>
<li>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li>
</ul>
<p><code>5xx</code> 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</p>
<ul>
<li>「<strong>500 Internal Server Error</strong>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</li>
<li>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li>
<li>「<strong>502 Bad Gateway</strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li>
<li>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。</li>
</ul>
<h3 id="（3）HTTP的常见字段有哪些"><a href="#（3）HTTP的常见字段有哪些" class="headerlink" title="（3）HTTP的常见字段有哪些"></a>（3）HTTP的常见字段有哪些</h3><p>HOST字段：客户端发送请求时，用来指定服务器的域名。</p>
<p>Content-Length 字段：服务器在返回数据时，会有 <code>Content-Length</code> 字段，表明本次回应的数据长度。</p>
<p><strong>HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决“粘包”的问题</strong></p>
<p>Connection 字段：<code>Connection</code> 字段最常用于客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用。</p>
<p>Content-Type 字段：<code>Content-Type</code> 字段用于服务器回应时，告诉客户端，本次数据是什么格式。</p>
<p>Content-Encoding 字段：<code>Content-Encoding</code> 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式。</p>
<h3 id="（4）-GET和POST有什么区别"><a href="#（4）-GET和POST有什么区别" class="headerlink" title="（4） GET和POST有什么区别"></a>（4） GET和POST有什么区别</h3><p>作用不同：GET用于从服务器获取资源；POST一般用来向服务器提交数据。</p>
<p>参数传递的方式不同：GET请求一般写在URL中，只接受ASCII字符。POST请求参数一般放在请求体中，对于数据类型也没有限制。</p>
<p>安全性不同：由于传递参数方式不同，GET请求直接暴露在URL中，一般不用来传递敏感信息。</p>
<p>参数长度限制不同：GET传输量较小，不能大于2KB；POST传递的数据量较大，一般默认不受限制。</p>
<p>编码方式不同：GET只进行URL编码，POST支持多种编码方式。</p>
<p>缓存机制不同：GET请求会被浏览器主动cache，POST不会，需要手动设置。GET请求参数会被完整保留在浏览器历史里，POST中的参数不会被保留。GET产生的URL可以被保存为书签，POST不可以。GET在浏览器回退时是无害的，POST会再次提交请求。</p>
<p>时间消耗不同：GET产生一个TCP数据包，POST产生两个TCP数据包。</p>
<p>先说明下安全和幂等的概念：</p>
<ul>
<li><p>在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。</p>
</li>
<li><p>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。</p>
</li>
<li><p><strong>GET 方法就是安全且幂等的</strong>，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，<strong>可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签</strong>。</p>
</li>
<li><p><strong>POST</strong> 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等</strong>的。所以，<strong>浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签</strong>。</p>
</li>
</ul>
<h3 id="（5）HTTP的缓存方式"><a href="#（5）HTTP的缓存方式" class="headerlink" title="（5）HTTP的缓存方式"></a>（5）HTTP的缓存方式</h3><p>缓存解决什么问题：减少不必要的网络传输，节约带宽；更快地加载页面，提高响应速度；减少服务器的负载，避免服务过载的情况出现。</p>
<p>强制缓存：浏览器判断请求的目标资源是否有效命中强缓存，如果命中，则直接从缓存中读取目标资源，无需与服务器通信，也就是说决定是否使用缓存的主动性在于浏览器这边。</p>
<p>Expires强缓存：设置一个强缓存时间，此时间范围内，从内存中读取并返回，但是因为其判断缓存过期的机制是获取本地时间戳，与之前拿到的资源文件的Expires字段时间进行比较，存在漏洞：如果本地时间不准怎么办，目前已被弃用。</p>
<p>Cache-Control强缓存：</p>
<ul>
<li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；</li>
<li>浏览器再次请求访问服务器中的该资源时，会先<strong>通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期</strong>，如果没有，则使用该缓存，否则重新请求服务器；</li>
<li>服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control</li>
</ul>
<p>max-age决定客户端资源被缓存多久；s-maxage决定代理服务器缓存多长时间；no-cache表示强制进行协商缓存；no-store表示禁止任何缓存策略；public表示资源既可以被浏览器缓存也可以被代理服务器缓存。private表示资源只能被浏览器缓存，默认为private。</p>
<p>基于Last-modified的协商缓存：</p>
<p>首先在服务器端读出资源文件的修改时间，将读出来的修改时间赋值给响应头的last-modified字段，然后设置Cache-Control为no-cache（强制协商缓存），当客户端读取到last-modified的时候，会在下次请求的的头部携带一个If-Modified-Since,即服务器第一次修改的时候给他的时间。之后每次对该资源进行请求，都会带上If-Modified-Since字段，服务器会拿着个字段并再次读取该资源的修改时间，进行比较，决定是读取缓存还是返回新资源。</p>
<p>缺点：根据修改时间做判断，如果内容没修改那也有可能更新文件修改时间（重命名-再改回来），文件内容没修改但缓存失效了；当文件在极短时间内修改完成，文件修改时间以秒为单位未检测到毫秒级的改变，此时文件内容被修改了，但缓存依然可用，并不发送新文件。-<em>-存在的问题</em></p>
<p>基于Etag的协商缓存：将原先协商缓存的比较时间戳的形式修改成了比较文件指纹（根据文件内容计算的唯一哈希值），解决了Last-Modified存在的问题。</p>
<p>第一次请求某资源的时候，服务端读取文件并计算文件指纹，将文件指纹放在响应头的Etag字段中跟随资源一起返回给客户端。第二次请求某资源的时候，客户端从缓存中读取上一次服务端返回的Etag（文件指纹），并赋值给请求头的if-none-match字段，让其跟随请求一起发回服务端。服务端接收到请求头中的if-node-match（上一次的文件指纹），并对目标资源文件再次读取并生成文件指纹，两个文件指纹进行对比，如果吻合，则直接返回304状态码和空的响应并return，如果不吻合，将新的文件指纹存储到Etag并返回给客户端。</p>
<p>缺点：Etag需要计算文件指纹，服务端需要更多的计算开销，如果文件尺寸大且计算频繁，会影响服务器性能。同时，Etag有强验证和弱验证，强验证需要将生成的哈希码深入到每个字节，文件中只有一个字节被改变，也会生成不同的哈希值，非常消耗服务器资源。弱验证通过提取文件的部分属性来生成哈希值，不必精确到每个字节，速度快，但准确率不高，会降低协商缓存的有效性。</p>
<h3 id="（6）HTTP1-0与HTTP1-1的区别"><a href="#（6）HTTP1-0与HTTP1-1的区别" class="headerlink" title="（6）HTTP1.0与HTTP1.1的区别"></a>（6）HTTP1.0与HTTP1.1的区别</h3><p>1、长连接</p>
<p>HTTP1.1支持长连接，每一个TCP连接上可以传送多个HTTP请求和响应，默认开启Connection： Keep-Alive。</p>
<p>HTTP1.0默认是短连接，每次请求都需要建立一个TCP连接。</p>
<p>2、缓存</p>
<p>HTTP1.0主要使用If-Modified_Since、Expires来作为缓存判断标准</p>
<p>HTTP1.1则引入了更多的缓存控制策略 比如Entity tag、If-None-Match等更多可选择的缓存头来控制缓存策略。</p>
<p>3、管道化</p>
<p>基于HTTP1.1的长连接，是的请求管道化成为可能，管道化能使得请求并行传输，但响应必须按照请求发出的顺序依次返回，性能在一定程度上得到了改善。</p>
<p>4、增加了Host字段</p>
<p>使得一个服务器可以创建多个web站点。</p>
<p>5、状态码</p>
<p>新增了24个错误状态响应码</p>
<p>6、带宽优化</p>
<p>HTTP1.0中，存在浪费带宽的现象，例如客户端只是需要某个资源的一部分，但服务器将整个资源对象传输过来，不支持断点续传功能。</p>
<p>HTTP1.1中加入了range头域，它允许之请求资源的某个部分，返回码是<code>206</code>（Partial content）。</p>
<h3 id="（7）HTTP2-0与HTTP1-1的区别"><a href="#（7）HTTP2-0与HTTP1-1的区别" class="headerlink" title="（7）HTTP2.0与HTTP1.1的区别"></a>（7）HTTP2.0与HTTP1.1的区别</h3><p>1、二进制分帧</p>
<p>HTTP2.0在应用层和传输层之间增加了一个二进制分帧层，突破了HTTP1.1的性能限制，改进了传输性能，实现低延迟高吞吐量。</p>
<p>2、多路复用（MultiPlexing）</p>
<p>允许通过单一的HTTP2.0连接发起多重的请求-响应消息，这个功能基于“二进制分帧”的特性。</p>
<p>3、首部压缩</p>
<p>HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header数据进行压缩。减少了数据体积，使得传输更快。高效的压缩算法可以尽量压缩header，减少发送包的数量从而降低延迟。</p>
<p>4、服务端推送</p>
<p>HTTP2.0中，服务器可以对客户端的一个请求发送多个响应，即服务器可以额外的向客户端推送资源，无需客户端明确的请求。</p>
<h3 id="（8）HTTPS的工作原理（HTTPS是怎么建立连接的）"><a href="#（8）HTTPS的工作原理（HTTPS是怎么建立连接的）" class="headerlink" title="（8）HTTPS的工作原理（HTTPS是怎么建立连接的）"></a>（8）HTTPS的工作原理（HTTPS是怎么建立连接的）</h3><p>首先，客户端向服务器发送请求报文，请求与服务端建立连接。服务端产生应一对公私密钥，然后将自己的公钥发送给CA机构，CA机构也有一对公私秘钥，CA机构使用自己的私钥将服务端发送过来的公钥进行加密，产生一个CA数字证书。（客户端–&gt;服务端&lt;–&gt;CA机构)</p>
<p>服务端响应客户端的请求，将CA机构生成的数字证书发送给客户端。(服务端–&gt;客户端)</p>
<p>客户端将服务端发送过来的数字证书进行解析，验证数字证书是否合法，不合法会发送警告，如果合法，取出服务端生成的公钥。客户端取出公钥并生成一个随机码key（对称加密中的秘钥），客户端将加密后的随机码key发送给服务端，作为之后对称加密的秘钥。（客户端–&gt;服务端）</p>
<p>服务端接收到随机码key（秘钥）后，使用服务端自己的私钥对他解密，然后获得这个随机码key。服务端使用这个随机码key对传输的数据进行加密，然后将加密后的内容发送给客户端。（服务端–&gt;客户端）</p>
<p>客户端使用自己生成的随机码key（密码）解密服务端发送过来的数据，之后客户端和服务端通过  对称加密传输数据，随机码key作为传输的秘钥。</p>
<p>（9）HTTPS与HTTP的区别</p>
<p>1、HTTP是明文传输，HTTPS通过SSL&#x2F;TLS进行加密。</p>
<p>2、HTTP的端口是80，HTTPS的端口是443</p>
<p>3、HTTPS需要到CA申请证书</p>
<p>4、HTTP的连接简单，是无状态的，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全。</p>
<h3 id="（9）DNS及其查询过程"><a href="#（9）DNS及其查询过程" class="headerlink" title="（9）DNS及其查询过程"></a>（9）DNS及其查询过程</h3><p>DNS（域名管理系统），当用户使用浏览器访问网址的时候，使用的第一个重要协议，解决的是域名和IP地址映射的问题。</p>
<p>用户在浏览器输入URL地址之后，会先在浏览器缓存中查询是否有该域名对应的IP地址。</p>
<p>如果浏览器缓存中没有，会去计算机本地的Host文件中查询是否有对应的缓存，是否有该域名对应的IP地址。</p>
<p>如果Host文件中也没有则会向本地DNS服务器发送一个DNS查询请求。本地DNS解析器没有缓存该域名的解析记录，它会向根DNS服务器发出查询请求，根DNS服务器不负责具体的域名解析，它会告诉本地DNS服务器应该向哪个顶级域DNS服务器发送查询请求。</p>
<p>本地DNS服务器接着向顶级域DNS服务器发送查询请求，顶级域DNS服务器也不负责具体的域名解析，它会告诉本地DNS服务器前往哪个权威域名DNS服务器发送查询请求。</p>
<p>本地DNS服务器接着向权威DNS服务器发送查询请求，权威DNS服务器是负责存储特定域名和IP地址映射的服务器。当权威DNS服务器收到查询请求是，会查找“example.com”域名对应的IP地址，并将结果返回给本地DNS服务器。</p>
<p>本地DNS服务器将收到的IP地址返回给浏览器，并将域名解析结果缓存在本地，以便下次更快响应。</p>
<h3 id="（10）HTTP多个TCP连接怎么实现"><a href="#（10）HTTP多个TCP连接怎么实现" class="headerlink" title="（10）HTTP多个TCP连接怎么实现"></a>（10）HTTP多个TCP连接怎么实现</h3><p>多个tcp连接是靠某些服务器对Connection： keep-alive的Header的支持。即完成这个HTTP请求之后，不要断开HTTP请求使用的TCP连接，这样的好处是连接可以被重复使用，之后发送的HTTP请求不需要重新建立新的TCP连接，并且SSL的开销也可以避免。</p>
<h3 id="（11）TCP的keepalive和HTTP的keep-alive是一个东西吗"><a href="#（11）TCP的keepalive和HTTP的keep-alive是一个东西吗" class="headerlink" title="（11）TCP的keepalive和HTTP的keep-alive是一个东西吗"></a>（11）TCP的keepalive和HTTP的keep-alive是一个东西吗</h3><p>HTTP的keep-alive，是由应用层（用户态）实现的，成为HTTP长连接：—<strong>保持成为长连接</strong></p>
<p>每次请求都要经历这样的过程：建立TCP-&gt;请求资源-&gt;响应资源-&gt;释放连接，这是HTTP短连接，但是这样每次建立连接都只能请求一次资源，所以HTTP通过keep-alive实现了使用同一个TCP连接来发送和接收多个HTTP请求，避免了连接建立和释放的开销，即HTTP长连接。</p>
<p>TCP的keepalive，是由TCP层（内核态）实现的，称为TCP保活机制。—<strong>判断是否存活</strong></p>
<p>TCP有一个定时任务倒计时，超时后会触发任务，内容是发送一个探测报文给对端，用来判断对端是否存活。</p>
<h2 id="3、TCP连接如何确保可靠性"><a href="#3、TCP连接如何确保可靠性" class="headerlink" title="3、TCP连接如何确保可靠性"></a>3、TCP连接如何确保可靠性</h2><p>1、数据块大小控制：应用数据被分割成TCP认为最合适发送的数据块，在传输给网络层，数据块被称为报文段或段。</p>
<p>2、序列号：TCP给每个数据包指定序列号，接收方根据序列号对数据包进行排序，并根据序列号对数据包进行去重。</p>
<p>3、校验和：TCP将保持首部和数据的校验和，这是一个端到端的校验和，目的是检测数据在传输过程中的任何变化，如果收到的报文的校验和有误，TCP将丢弃这个报文段和不确认收到此报文段（对面要重新发送或采取别的措施）</p>
<p>4、流量控制：TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据，当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止数据包丢失。TCP利用滑动窗口实现流量控制。</p>
<p>5、拥塞控制：当网络拥塞时，减少数据的发送。（有其拥塞控制算法）</p>
<p>6、确认应答：用过ARQ协议实现。基本原理是每发完一个分组就停止发送，等待对方确认。如果没收到确定就重新发送数据包，直到确认后再发送下一个分组。</p>
<p>7、超时重传：当TCP发出一个数据段后，启动一个定时器，等待目的端的确认收到这个报文段，如果在定时器时间内没收到，将重新发送这个报文段。 <strong>超时重传时间 RTO 的值应该略大于报文往返 RTT 的值</strong></p>
<p>还有一种实现重传机制的方式叫：<code>SACK</code>（ Selective Acknowledgment）， <strong>选择性确认</strong>。</p>
<p>这种方式需要在 TCP 头部「选项」字段里加一个 <code>SACK</code> 的东西，它<strong>可以将已收到的数据的信息发送给「发送方」</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong>。</p>
<h2 id="4、既然提到了拥塞控制，拥塞控制是怎么实现的？"><a href="#4、既然提到了拥塞控制，拥塞控制是怎么实现的？" class="headerlink" title="4、既然提到了拥塞控制，拥塞控制是怎么实现的？"></a>4、既然提到了拥塞控制，拥塞控制是怎么实现的？</h2><p>拥塞控制算法主要有以下几种：</p>
<p>1、慢启动</p>
<p>在连接刚开始时，发送方会逐渐增加发送窗口的大小，以指数增长的速度增加发送窗口的数据量。</p>
<p>2、拥塞避免</p>
<p>一旦慢启动阶段过去，发送方进入拥塞避免阶段，在这个阶段，发送方会逐渐增加发送窗口的大小，但增加速率较慢，以线性增长的方式，避免过快增加导致网络拥塞。</p>
<p>3、超时重传</p>
<p>如果发送方在超时时间内未收到确认，他会认为数据包丢失，并重传这些数据包。这是拥塞控制的最后手段，用于检测和处理网络中的丢包和拥塞情况。</p>
<p>4、快速重传</p>
<p>当发送方发送的数据包丢失或者网络出现拥塞时，接收方会重复发送确认通知（ACK）来通知发送方有数据丢失，当发送方收到三次重复确认时，在超时时间到期内立刻重新发送丢失的数据包，而不是等超时之后再发，这样可以减少网络的拥塞程度。</p>
<p>5、拥塞窗口调整</p>
<p>发送方根据网络的拥塞程度动态调整发送窗口的大小，通过监测网络延迟和丢包情况来确定合适的发送速率，以避免网络拥塞。</p>
<h2 id="5、Cookie和Session是什么，有什么区别？"><a href="#5、Cookie和Session是什么，有什么区别？" class="headerlink" title="5、Cookie和Session是什么，有什么区别？"></a>5、Cookie和Session是什么，有什么区别？</h2><p>Cookie和Session都用于管理用户的状态和身份。</p>
<p>Cookie通过在客户端记录信息来确定用户身份。</p>
<p>Session通过在服务器端记录信息确定用户身份。</p>
<p>1、Cookie</p>
<p>Cook是存储在用户浏览器中的小型文本文件，用于在用户和服务器之间传递数据。通常服务器会将一个或多个Cookie发送到用户浏览器，然后浏览器将这些Cookie存储在本地。</p>
<p>服务端在接收到来自客户端浏览器的请求之后，能够通过分析存放于请求头中的Cookie得到客户端特有的信息，从而动态生成与该客户端相对应的内容。</p>
<p>2、Session</p>
<p>客户端浏览器访问服务器的时候，服务器把客户端信息以某种新式记录在服务器上，即Session。Session主要用于维护用户登录状态、存储用户的临时数据和上下文信息等。</p>
<p>3、区别</p>
<p>存储位置：Cookie存储于用户的浏览器中，Session存储于服务器上。</p>
<p>数据容量：Cookie存储容量较小，一般为几KB，Session存储容量较大，通常没有固定限制，取决于服务器的配置和资源。</p>
<p>安全性：Cookie存储于用户浏览器中可以被用户读取和篡改。相比之下，Session存储于服务器上更难被访问和修改。</p>
<p>传输方式：Cookie在每次HTTP请求中会被自动发送到服务器，而Session ID通常通过Cookie或者URL参数传递。</p>
<h1 id="C-语言基础"><a href="#C-语言基础" class="headerlink" title="C++语言基础"></a>C++语言基础</h1><h2 id="1、虚函数与纯虚函数的区别"><a href="#1、虚函数与纯虚函数的区别" class="headerlink" title="1、虚函数与纯虚函数的区别"></a>1、虚函数与纯虚函数的区别</h2><ol>
<li>虚函数就是在普通函数之前加上关键字virtual，他有自己具体的实现。纯虚函数是在虚函数的基础上在表达式后面加上&#x3D;0，且纯虚函数没有具体的实现。具有纯虚函数的类被称为抽象类，抽象类不能实例化对象。重写了纯虚函数的派生类才可以实例化对象。</li>
<li>子类继承父类时，如果父类有虚函数，子类可以重写父类的虚函数，也可以不重写，不重写时调用的是父类的虚函数。如果父类有纯虚函数，子类必须重写。</li>
<li>虚函数是一个可以被调用的函数，纯虚函数仅仅是一个API，需要被派生类自行定义。</li>
</ol>
<h2 id="2、CPP怎么实现多态？"><a href="#2、CPP怎么实现多态？" class="headerlink" title="2、CPP怎么实现多态？"></a>2、CPP怎么实现多态？</h2><p>1、函数重载：通过在同一个作用域内定义多个同名函数，但是参数类型和数量不同，编译器会根据调用时提供的参数来决定调用哪个函数版本。</p>
<p>2、运算符重载：允许定义或修改大部分运算符的默认行为。</p>
<p>3、模板：通过模板函数或模板类，可以编写泛型代码，实现对多种类型的操作，而无需知道这些类型的具体细节。</p>
<p>4、抽象基类：使用包含纯虚函数的类作为接口，强制派生类提供纯虚函数的具体实现。</p>
<p>5、动态多态：除了虚函数外，还可以通过指针或引用传递基类类型的对象，而在运行时根据对象的实际类型来调用相应的成员函数，这通常与虚函数一起使用。</p>
<p>6、静态多态：也称为编译时多态，包括函数重载和模版，由于在编译时已经确定了调用哪个函数，所以称为静态多态。</p>
<h2 id="3、new-和-malloc的区别"><a href="#3、new-和-malloc的区别" class="headerlink" title="3、new 和 malloc的区别"></a>3、new 和 malloc的区别</h2><p>1、new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。</p>
<p>  2、使⽤new操作符申请内存分配时⽆须指定内存块的⼤⼩，⽽malloc则需要显式地指出所需内存的尺⼨。 </p>
<p> 3、opeartor new &#x2F;operator delete可以被重载，⽽malloc&#x2F;free并不允许重载。 </p>
<p> 4、new&#x2F;delete会调⽤对象的构造函数&#x2F;析构函数以完成对象的构造&#x2F;析构。⽽malloc则不会  </p>
<p>5、malloc与free是C++&#x2F;C语⾔的标准库函数,new&#x2F;delete是C++的运算符  </p>
<p>6、new操作符从⾃由存储区上为对象动态分配内存空间，⽽malloc函数从堆上动态分配内存。</p>
<h2 id="4、讲一讲封装、继承、多态是什么？"><a href="#4、讲一讲封装、继承、多态是什么？" class="headerlink" title="4、讲一讲封装、继承、多态是什么？"></a>4、讲一讲封装、继承、多态是什么？</h2><p><strong>封装：</strong>将一个功能或者方法的实现过程以及所需要的数据封装成一个函数，对外提供一个公共的访问接口以供其他程序调用，降低耦合性。这么做使得类成为一个具有内部数据自我隐藏能力、功能独立的软件模块。</p>
<p>意义：保护类中的成员，保护或者防止代码在无意中被破坏，避免了让类外成员直接访问或修改类中的数据，只能通过类提供的接口进行访问。</p>
<p><strong>继承：</strong>子类可以继承父类的特征和行为，可以复用基类（父类）的全体数据和成员函数具有从基类（父类）复制而来的成员数据和成员函数。（基类的私有成员可以被继承，但是无法被访问）。其中<strong>构造函数、析构函数、友元函数、静态数据成员、静态成员函数</strong>都不能被继承。基类中成员的访问方式只能决定派生类能否访问它们。增强了代码耦合性，当父类中的成员变量或者类本身被final关键字修饰时，修饰的类不能被继承，修饰的成员变量不能重写或修改。</p>
<p>意义：基类的程序代码可以被派生类服用，提高了软件复用的效率，缩短了软件开发的周期。</p>
<p><strong>多态：</strong>不同继承类的对象对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现形式。</p>
<p>意义：对已存在的代码具有可替代性，对代码具有可扩充性，新增子类不会影响已存在类的各种性质，在程序中体现了灵活多样的操作，提高了使用效率，简化了对应用代码的编写和修改过程。</p>
<h2 id="5、多态的实现原理（实现方式）是什么？以及多态的优点（特点）？"><a href="#5、多态的实现原理（实现方式）是什么？以及多态的优点（特点）？" class="headerlink" title="5、多态的实现原理（实现方式）是什么？以及多态的优点（特点）？"></a>5、多态的实现原理（实现方式）是什么？以及多态的优点（特点）？</h2><p>实现方式：多态分为动态多态（动态多态是利用虚函数实现运行时的多态，即在系统编译的时候并不知道程序将要调用哪一个函数，只有在运行到这里的时候才能确定接下来会跳转到哪一个函数。）和静态多态（又称编译期多态，即在系统编译期间就可以确定程序将要执行哪个函数），其中动态多态是通过虚函数实现的，虚函数是类的成员函数，存在存储虚函数指针的表叫做虚函数表，虚函数表是一个存储类成员虚函数的指针，每个指针都指向调用它的地方，当子类调用虚函数时，就会去虚表里面找自己对应的函数指针，从而实现“谁调用、实现谁”从而实现多态。而静态多态则是通过函数重载（函数名相同，参数不同，两个函数在同一作用域），运算符重载，和重定义（又叫隐藏，指的是在继承关系中，子类实现了一个和父类名字一样的函数，（只关注函数名，和参数与返回值无关）这样的话子类的函数就把父类的同名函数隐藏了。隐藏只与函数名有关，与参数没有关系.）来实现的。</p>
<p>优点：加强代码的可扩展性，可替换性，增强程序的灵活性，提高使用效率，简化对应用代码的编写和修改过程。</p>
<h2 id="6、final标识符的作用是什么"><a href="#6、final标识符的作用是什么" class="headerlink" title="6、final标识符的作用是什么"></a>6、final标识符的作用是什么</h2><p>放在类的后面表示该类无法被继承，也就是阻止了从类的继承，放在虚函数后面该虚函数无法被重写，表示阻止虚函数的重载</p>
<h2 id="7、虚函数是怎么实现的？它存放在哪里在内存的哪个区？什么时候生成的"><a href="#7、虚函数是怎么实现的？它存放在哪里在内存的哪个区？什么时候生成的" class="headerlink" title="7、虚函数是怎么实现的？它存放在哪里在内存的哪个区？什么时候生成的"></a>7、虚函数是怎么实现的？它存放在哪里在内存的哪个区？什么时候生成的</h2><p>在C++中，虚函数的实现原理基于两个关键概念：虚函数表和虚函数指针</p>
<p>虚函数表：每个包含虚函数的类都会生成一个虚函数表，其中存储着该类中所有虚函数的地址。虚函数表是一个由指针构成的数组，每个指针指向一个虚函数的实现代码。</p>
<p>虚函数指针：在对象的内存布局中，编译器会添加一个额外的指针，称为虚函数指针或虚表指针。这个指针指向该对象对应的虚函数表，从而让程序能够动态的调用虚函数。</p>
<p>当一个基类指针或引用调用虚函数时，编译器会使用虚表指针来查找该对象对应的虚函数表，并根据函数在虚函数表中的位置来调用正确的虚函数。</p>
<p>在编译阶段生成，虚函数和普通函数一样存放在代码段，只是它的指针又存放在了虚表之中。</p>
<h2 id="8、智能指针的本质是什么，它们的实现原理是什么？"><a href="#8、智能指针的本质是什么，它们的实现原理是什么？" class="headerlink" title="8、智能指针的本质是什么，它们的实现原理是什么？"></a>8、智能指针的本质是什么，它们的实现原理是什么？</h2><p>智能指针本质是一个封装了一个原始C++指针的类模板，为了确保动态内存的安全性而产生的。实现原理是通过一个对象存储需要被自动释放的资源，然后依靠对象的析构函数来释放资源。</p>
<p>智能指针⽤于管理动态内存的对象，其主要⽬的是在避免内存泄漏和⽅便资源管理。</p>
<p>分为独占智能指针、共享智能指针和弱引用智能指针。</p>
<p>std::unique_ptr （独占智能指针）提供对动态分配的单⼀对象所有权的独占管理。通过独占所有权，确保只有⼀个 std::unique_ptr 可以拥有指定的内存资源。移动语义和右值引⽤允许 std::unique_ptr 在所有权转移时⾼ 效地进⾏转移。</p>
<p>std::shared_ptr （共享智能指针）允许多个智能指针共享同⼀块内存资源。内部使⽤引⽤计数来跟踪对象被共享的次数，当计数 为零时，资源被释放。提供更灵活的内存共享，但可能存在循环引⽤的问题。</p>
<p>std::weak_ptr （弱引用智能指针）⽤于解决 std::shared_ptr 可能导致的循环引⽤问题。 std::weak_ptr 可以从 std::shared_ptr 创建，但不会增加引⽤计数，不会影响资源的释放。 通过 std::weak_ptr::lock() 可以获取⼀个 std::shared_ptr 来访问资源。</p>
<h2 id="9、匿名函数的本质是什么？他的优点是什么？"><a href="#9、匿名函数的本质是什么？他的优点是什么？" class="headerlink" title="9、匿名函数的本质是什么？他的优点是什么？"></a>9、匿名函数的本质是什么？他的优点是什么？</h2><p>匿名函数本质上是一个对象，在其定义的过程中会创建出一个栈对象，内部通过<strong>重载()符号</strong>实现函数调用的外表。</p>
<p>优点：使用匿名函数，可以免去函数的声明和定义。这样匿名函数仅在调用函数的时候才会创建函数对象，而调用结束后立即释放，所以匿名函数比非匿名函数更节省空间。</p>
<h2 id="10、delete-和-free-有什么区别？"><a href="#10、delete-和-free-有什么区别？" class="headerlink" title="10、delete 和 free 有什么区别？"></a>10、delete 和 free 有什么区别？</h2><p>类型安全性： delete 会调⽤对象的析构函数，确保资源被正确释放。 free 不了解对象的构造和析构，只是简单地释放内存块。 </p>
<p>内存块释放后的⾏为： delete 释放的内存块的指针值会被设置为 nullptr ，以避免ᰀ指针。 free 不会修改指针的值，可能导致ᰀ指针问题。 </p>
<p>数组的释放： delete 可以正确释放通过 new[] 分配的数组。 free 不了解数组的⼤⼩，不适⽤于释放通过 malloc 分配的数组。</p>
<h2 id="11、什么是野指针，如何产生以及如何避免？"><a href="#11、什么是野指针，如何产生以及如何避免？" class="headerlink" title="11、什么是野指针，如何产生以及如何避免？"></a>11、什么是野指针，如何产生以及如何避免？</h2><p>野指针是指指向已被释放或无效的的内存地址的指针，使用野指针可能会导致程序崩溃、数据损坏或其他不可预测的行为。通常由以下几种情况产生：</p>
<p>1、释放后没有置空指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span>* ptr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br><span class="hljs-keyword">delete</span> ptr;<br><span class="hljs-comment">// 此时 ptr 成为ᰀ指针，因为它仍然指向已经被释放的内存</span><br>ptr = <span class="hljs-literal">nullptr</span>; <br></code></pre></td></tr></table></figure>

<p>2、返回局部变量的指针（局部变量在函数调用后被销毁，返回的指针成为了野指针&#x2F;悬浮指针）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">createInt</span><span class="hljs-params">()</span> </span>&#123;<br> <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br> <span class="hljs-keyword">return</span> &amp;x; <span class="hljs-comment">// x 是局部变ᰁ，函数结束后 x 被销毁，返回的指针成为野指针</span><br>&#125;<br><span class="hljs-comment">// 在使⽤返回值时可能引发未定义⾏为</span><br></code></pre></td></tr></table></figure>

<p>3、释放内存后没有调整指针指向（同1）</p>
<p>4、函数参数指针被释放</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>* ptr)</span> </span>&#123;<br> <span class="hljs-comment">// 操作 ptr</span><br> <span class="hljs-keyword">delete</span> ptr;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br> <span class="hljs-type">int</span>* ptr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br> <span class="hljs-built_in">foo</span>(ptr);<br> <span class="hljs-comment">// 在 foo 函数中 ptr 被释放，但在 main 函数中仍然可⽤，成为野指针</span><br> <span class="hljs-comment">// 避免：在 foo 函数中不要释放调⽤⽅传递的指针</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>对应的解决方法以及避免野指针的方法：</p>
<p>1、释放内存后将指针设置为nullptr；2、避免返回局部变量的指针；3、使用智能指针；4、注意函数参数的生命周期，避免在函数内释放调用方传递的指针。</p>
<h2 id="12、野指针和悬浮指针的区别"><a href="#12、野指针和悬浮指针的区别" class="headerlink" title="12、野指针和悬浮指针的区别"></a>12、野指针和悬浮指针的区别</h2><p>野指针是指向已经被释放或者⽆效的内存地址的指针。通常由于指针指向的内存被释放，但指针本身没有被置为 nullptr 或者重新分配有效的内存，导致指针仍然包含之前的内存地址。使⽤野指针进⾏访问会导致未定义⾏ 为，可能引发程序崩溃、数据损坏等问题。</p>
<p> 悬浮指针是<strong>指向已经被销毁的对象的引⽤</strong>。当函数返回⼀个局部变量的引⽤，⽽调⽤者使⽤该引⽤时，就可能产⽣ 悬浮引⽤。访问悬浮引⽤会导致未定义⾏为，因为引⽤指向的对象已经被销毁，数据不再有效。</p>
<h2 id="13、说说C-的内存分配方式"><a href="#13、说说C-的内存分配方式" class="headerlink" title="13、说说C++的内存分配方式"></a>13、说说C++的内存分配方式</h2><p>（1）从静态存储区域分配：内存在程序编译的时候就已经分配好，这块内存在程序的整个运⾏期间都存在，如全局变量，static变量。 </p>
<p>（2）在栈上创建：在执⾏函数时，函数内局部变量的存储单元都可以在栈上创建，函数执⾏结束时这些存储单元⾃动被释放。栈内存 分配运算内置于处理器的指令集中，效率很⾼，但是分配的内存容量有限。 </p>
<p>（3）从堆上分配(动态内存分配) 程序在运⾏的时候⽤malloc或new申请任意多少的内存，程序员负责在何时⽤free或delete释放内存。动态内存的 ⽣存期⾃⼰决定，使⽤⾮常灵活。</p>
<h2 id="14、成员函数、成员变量、静态成员变量、静态成员函数的区别成员函数"><a href="#14、成员函数、成员变量、静态成员变量、静态成员函数的区别成员函数" class="headerlink" title="14、成员函数、成员变量、静态成员变量、静态成员函数的区别成员函数"></a>14、成员函数、成员变量、静态成员变量、静态成员函数的区别成员函数</h2><p>1、成员函数</p>
<p>是属于类的函数，它们可以访问类的成员变量和其他成员函数。 成员函数可以分为普通成员函数和静态成员函数。 普通成员函数使⽤对象调⽤，可以访问对象的成员变量·。 普通成员函数的声明和定义通常在类的内部，但定义时需要使⽤类名作为限定符。</p>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="1、进程和线程的区别"><a href="#1、进程和线程的区别" class="headerlink" title="1、进程和线程的区别"></a>1、进程和线程的区别</h2><p>进程是系统进行资源分配和调度的基本单位。</p>
<p>线程是操作系统能够进行运算调度的最小单位。线程是进程的子任务，是进程内的执行单元。一个进程至少有一个线程，一个进程可以运行多个线程，这些线程共享一块内存。</p>
<p>资源开销：</p>
<p>进程：由于每个进程都有独立的内存空间，创建和销毁进程的开销较大。进程间切换需要保存和恢复整个进程的状态，因此上下文切换的开销较高。</p>
<p>线程：线程共享相同的内存空间，创建和销毁线程的开销较小。线程间切换只需保存和恢复少量的线程上下文，因此上下文的切换开销较小。</p>
<p>通信与同步:</p>
<p>进程：由于进程间相互隔离，进程之间的通信需要一些特殊机制，如管道、消息队列、共享内存等方式。</p>
<p>线程：由于线程共享相同的内存空间，他们之间可以直接访问共享数据，线程间通信更加方便。</p>
<p>安全性：</p>
<p>进程：由于进程间相互隔离，一个进程的崩溃不会影响其他进程的稳定性。</p>
<p>线程：由于线程共享相同的内存空间，一个线程的错误可能会影响整个进程的稳定性。</p>
<h2 id="2、进程的调度算法你了解多少？"><a href="#2、进程的调度算法你了解多少？" class="headerlink" title="2、进程的调度算法你了解多少？"></a>2、进程的调度算法你了解多少？</h2><p>进程都希望自己能够占用 CPU 进行工作，那么这涉及到前面说过的进程上下文切换。</p>
<p>一旦操作系统把进程切换到运行状态，也就意味着该进程占用着 CPU 在执行，但是当操作系统把进程切换到其他状态时，那就不能在 CPU 中执行了，于是操作系统会选择下一个要运行的进程，选择一个进程运行这一功能是在操作系统中完成的，通常称为<strong>调度程序</strong></p>
<p>01、先来先服务调度算法（FCFS）</p>
<p>顾名思义，先来后到，<strong>每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。</strong></p>
<p>这似乎很公平，但是当一个长作业先运行了，那么后面的短作业等待的时间就会很长，不利于短作业。</p>
<p>FCFS 对长作业有利，适用于 CPU 繁忙型作业的系统，而不适用于 I&#x2F;O 繁忙型作业的系统。</p>
<p>02、最短作业优先调度算法</p>
<p><strong>最短作业优先（*Shortest Job First, SJF*）调度算法</strong>同样也是顾名思义，它会<strong>优先选择运行时间最短的进程来运行</strong>，这有助于提高系统的吞吐量。</p>
<p>这显然对长作业不利，很容易造成一种极端现象。比如，一个长作业在就绪队列等待运行，而这个就绪队列有非常多的短作业，那么就会使得长作业不断的往后推，周转时间变长，致使长作业长期不会被运行。</p>
<p>03、高响应比优先调度算法</p>
<p>前面两种没有权衡长短作业的利弊，那么，<strong>高响应比优先 （*Highest Response Ratio Next, HRRN*）调度算法</strong>主要是权衡了短作业和长作业。<strong>每次进行进程调度时，先计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行</strong>。</p>
<p>优先权 &#x3D; （等待时间+要求服务时间）&#x2F;要求服务时间</p>
<ul>
<li>如果两个进程的「等待时间」相同时，「要求的服务时间」越短，「响应比」就越高，这样短作业的进程容易被选中运行；</li>
<li>如果两个进程「要求的服务时间」相同时，「等待时间」越长，「响应比」就越高，这就兼顾到了长作业进程，因为进程的响应比可以随时间等待的增加而提高，当其等待时间足够长时，其响应比便可以升到很高，从而获得运行的机会</li>
</ul>
<p>一个进程的要求服务时间是不可预估的，所以高响应比优先调度算法是理想算法，现实中实现不了。</p>
<p>04、时间片轮转调度算法</p>
<p>最古老、最简单、最公平且使用最广的算法就是<strong>时间片轮转（*Round Robin, RR*）调度算法</strong>。</p>
<p><strong>每个进程被分配一个时间段，称为时间片（*Quantum*），即允许该进程在该时间段中运行。</strong></p>
<ul>
<li>如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配给另外一个进程；</li>
<li>如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换；</li>
</ul>
<p>另外，时间片的长度就是一个很关键的点：</p>
<ul>
<li>如果时间片设得太短会导致过多的进程上下文切换，降低了 CPU 效率；</li>
<li>如果设得太长又可能引起对短作业进程的响应时间变长。</li>
</ul>
<p>一般来说，时间片设为 <code>20ms~50ms</code> 通常是一个比较合理的折中值。</p>
<p>05、最高优先级调度算法</p>
<p>前面的「时间片轮转算法」做了个假设，即让所有的进程同等重要，也不偏袒谁，大家的运行时间都一样。</p>
<p>但是，对于多用户计算机系统就有不同的看法了，它们希望调度是有优先级的，即希望调度程序能<strong>从就绪队列中选择最高优先级的进程进行运行，这称为最高优先级（*Highest Priority First，HPF*）调度算法</strong>。</p>
<p>进程的优先级可以分为，静态优先级和动态优先级：</p>
<ul>
<li>静态优先级：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化；</li>
<li>动态优先级：根据进程的动态变化调整优先级，比如如果进程运行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升高其优先级，也就是<strong>随着时间的推移增加等待进程的优先级</strong>。</li>
</ul>
<p>该算法也有两种处理优先级高的方法，非抢占式和抢占式：</p>
<ul>
<li>非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程。</li>
<li>抢占式：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。</li>
</ul>
<p>但是依然有缺点，可能会导致低优先级的进程永远不会运行。</p>
<p>06、多级反馈队列调度算法</p>
<p><strong>多级反馈队列（*Multilevel Feedback Queue*）调度算法</strong>是「时间片轮转算法」和「最高优先级算法」的综合和发展。</p>
<p>顾名思义：</p>
<ul>
<li><p>「多级」表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短。</p>
</li>
<li><p>「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列；</p>
</li>
<li><p>设置了多个队列，赋予每个队列不同的优先级，每个<strong>队列优先级从高到低</strong>，同时<strong>优先级越高时间片越短</strong>；</p>
</li>
<li><p>新的进程会被放入到第一级队列的末尾，按先来先服务的原则排队等待被调度，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成；</p>
</li>
<li><p>当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行；</p>
</li>
</ul>
<p>可以发现，对于短作业可能可以在第一级队列很快被处理完。对于长作业，如果在第一级队列处理不完，可以移入下次队列等待被执行，虽然等待的时间变长了，但是运行时间也变更长了，所以该算法很好的<strong>兼顾了长短作业，同时有较好的响应时间。</strong></p>
<h2 id="3、进程间有哪些通信方式"><a href="#3、进程间有哪些通信方式" class="headerlink" title="3、进程间有哪些通信方式?"></a>3、进程间有哪些通信方式?</h2><p>每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以进程之间要通信必须通过内核。</p>
<p>1、管道（匿名管道</p>
<p>半双工的通信方式，数据只能单向流动而且只能在具有父子进程关系的进程间使用。使用 <code>fork</code> 创建子进程，<strong>创建的子进程会复制父进程的文件描述符</strong>，这样就做到了两个进程各有两个「 <code>fd[0]</code> 与 <code>fd[1]</code>」，两个进程就可以通过各自的 fd 写入和读取同一个管道文件实现跨进程通信了。</p>
<p>2、命名管道</p>
<p>也叫做FIFO，也是半双工通信方式，但是允许无亲缘关系的进程之间的提通信。</p>
<p><strong>管道这种通信方式效率低，不适合进程间频繁地交换数据</strong>。当然，它的好处，自然就是简单，同时也我们很容易得知管道里的数据已经被另一个进程读取了。</p>
<p>不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循<strong>先进先出</strong>原则，不支持 lseek 之类的文件定位操作</p>
<p>3、消息队列</p>
<p>前面说到管道的通信方式是效率低的，因此管道不适合进程间频繁地交换数据。</p>
<p>对于这个问题，<strong>消息队列</strong>的通信模式就可以解决。比如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。同理，B 进程要给 A 进程发送消息也是如此。</p>
<p>再来，<strong>消息队列是保存在内核中的消息链表</strong>，在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。</p>
<p>消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在，而前面提到的匿名管道的生命周期，是随进程的创建而建立，随进程的结束而销毁。</p>
<p>消息这种模型，两个进程之间的通信就像平时发邮件一样，你来一封，我回一封，可以频繁沟通了。</p>
<p>但邮件的通信方式存在不足的地方有两点，<strong>一是通信不及时，二是附件也有大小限制</strong>，这同样也是消息队列通信不足的点。</p>
<p><strong>消息队列不适合比较大数据的传输</strong>，因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限。在 Linux 内核中，会有两个宏定义 <code>MSGMAX</code> 和 <code>MSGMNB</code>，它们以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度。</p>
<p><strong>消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销</strong>，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。</p>
<p>4、共享内存</p>
<p>消息队列的读取和写入的过程，都会有发生用户态与内核态之间的消息拷贝过程。那<strong>共享内存</strong>的方式，就很好的解决了这一问题。</p>
<p>现代操作系统，对于内存管理，采用的是虚拟内存技术，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程 A 和 进程 B 的虚拟地址是一样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。</p>
<p><strong>共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中</strong>。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。</p>
<p>5、信号量</p>
<p>用了共享内存通信方式，带来新的问题，那就是如果多个进程同时修改同一个共享内存，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。</p>
<p>为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，<strong>信号量</strong>就实现了这一保护机制。</p>
<p><strong>信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据</strong>。</p>
<p>信号量表示资源的数量，控制信号量的方式有两种原子操作：</p>
<ul>
<li>一个是 <strong>P 操作</strong>，这个操作会把信号量减去 1，相减后如果信号量 &lt; 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 &gt;&#x3D; 0，则表明还有资源可使用，进程可正常继续执行。</li>
<li>另一个是 <strong>V 操作</strong>，这个操作会把信号量加上 1，相加后如果信号量 &lt;&#x3D; 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程；</li>
</ul>
<p>P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。</p>
<p>信号初始化为 <code>1</code>，就代表着是<strong>互斥信号量</strong>，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。</p>
<p>我们可以初始化信号量为 <code>0</code>，就可以用信号量来实现多进程同步的方式，它可以保证进程 A 应在进程 B 之前执行。</p>
<p>6、信号</p>
<p>上面说的进程间通信，都是常规状态下的工作模式。<strong>对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。</strong></p>
<p>信号跟信号量虽然名字相似度 66.66%，但两者用途完全不一样，就好像 Java 和 JavaScript 的区别。</p>
<p>在 Linux 操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义。我们可以通过 <code>kill -l</code> 命令，查看所有的信号：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">kill</span> -l</span><br> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP<br> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1<br>11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM<br>16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP<br>21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ<br>26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR<br>31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3<br>38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8<br>43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13<br>48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12<br>53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7<br>58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2<br>63) SIGRTMAX-1  64) SIGRTMAX<br></code></pre></td></tr></table></figure>

<p>运行在 shell 终端的进程，我们可以通过键盘输入某些组合键的时候，给进程发送信号。例如</p>
<ul>
<li>Ctrl+C 产生 <code>SIGINT</code> 信号，表示终止该进程；</li>
<li>Ctrl+Z 产生 <code>SIGTSTP</code> 信号，表示停止该进程，但还未结束；</li>
</ul>
<p>如果进程在后台运行，可以通过 <code>kill</code> 命令的方式给进程发送信号，但前提需要知道运行中的进程 PID 号，例如：</p>
<ul>
<li>kill -9 1050 ，表示给 PID 为 1050 的进程发送 <code>SIGKILL</code> 信号，用来立即结束该进程；</li>
</ul>
<p>所以，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令）。</p>
<p>信号是进程间通信机制中<strong>唯一的异步通信机制</strong>，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。</p>
<p><strong>1.执行默认操作</strong>。Linux 对每种信号都规定了默认操作，例如，上面列表中的 SIGTERM 信号，就是终止进程的意思。</p>
<p><strong>2.捕捉信号</strong>。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。</p>
<p><strong>3.忽略信号</strong>。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 <code>SIGKILL</code> 和 <code>SEGSTOP</code>，它们用于在任何时候中断或结束某一进程。</p>
<p>7、socket套接字</p>
<p>前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想<strong>跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。</strong></p>
<p>实际上，Socket 通信不仅可以跨网络与不同主机的进程间通信，还可以在同主机上进程间通信。</p>
<p>我们来看看创建 socket 的系统调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">socket</span><span class="hljs-params">(<span class="hljs-type">int</span> domain, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span> protocal)</span><br></code></pre></td></tr></table></figure>

<p>三个参数分别代表：</p>
<ul>
<li>domain 参数用来指定协议族，比如 AF_INET 用于 IPV4、AF_INET6 用于 IPV6、AF_LOCAL&#x2F;AF_UNIX 用于本机；</li>
<li>type 参数用来指定通信特性，比如 SOCK_STREAM 表示的是字节流，对应 TCP、SOCK_DGRAM 表示的是数据报，对应 UDP、SOCK_RAW 表示的是原始套接字；</li>
<li>protocal 参数原本是用来指定通信协议的，但现在基本废弃。因为协议已经通过前面两个参数指定完成，protocol 目前一般写成 0 即可；</li>
</ul>
<p>根据创建 socket 类型的不同，通信的方式也就不同：</p>
<ul>
<li>实现 TCP 字节流通信： socket 类型是 AF_INET 和 SOCK_STREAM；</li>
<li>实现 UDP 数据报通信：socket 类型是 AF_INET 和 SOCK_DGRAM；</li>
<li>实现本地进程间通信： 「本地字节流 socket 」类型是 AF_LOCAL 和 SOCK_STREAM，「本地数据报 socket 」类型是 AF_LOCAL 和 SOCK_DGRAM。另外，AF_UNIX 和 AF_LOCAL 是等价的，所以 AF_UNIX 也属于本地 socket；</li>
</ul>
<p>总结</p>
<p>由于每个进程的用户空间都是独立的，不能相互访问，这时就需要借助内核空间来实现进程间通信，原因很简单，每个进程都是共享一个内核空间。</p>
<p>Linux 内核提供了不少进程间通信的方式，其中最简单的方式就是管道，管道分为「匿名管道」和「命名管道」。</p>
<p><strong>匿名管道</strong>顾名思义，它没有名字标识，匿名管道是特殊文件只存在于内存，没有存在于文件系统中，shell 命令中的「<code>|</code>」竖线就是匿名管道，通信的数据是<strong>无格式的流并且大小受限</strong>，通信的方式是<strong>单向</strong>的，数据只能在一个方向上流动，如果要双向通信，需要创建两个管道，再来<strong>匿名管道是只能用于存在父子关系的进程间通信</strong>，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失。</p>
<p><strong>命名管道</strong>突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用命名管道的前提，需要在文件系统创建一个类型为 p 的设备文件，那么毫无关系的进程就可以通过这个设备文件进行通信。另外，不管是匿名管道还是命名管道，进程写入的数据都是<strong>缓存在内核</strong>中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循<strong>先进先出</strong>原则，不支持 lseek 之类的文件定位操作。</p>
<p><strong>消息队列</strong>克服了管道通信的数据是无格式的字节流的问题，消息队列实际上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数据类型，发送数据时，会被分成一个一个独立的消息体，当然接收数据时，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的数据是正确的。消息队列通信的速度不是最及时的，毕竟<strong>每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程。</strong></p>
<p><strong>共享内存</strong>可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，<strong>它直接分配一个共享空间，每个进程都可以直接访问</strong>，就像访问进程自己的空间一样快捷方便，不需要陷入内核态或者系统调用，大大提高了通信的速度，享有<strong>最快</strong>的进程间通信方式之名。但是便捷高效的共享内存通信，<strong>带来新的问题，多进程竞争同个共享资源会造成数据的错乱。</strong></p>
<p>那么，就需要<strong>信号量</strong>来保护共享资源，以确保任何时刻只能有一个进程访问共享资源，这种方式就是互斥访问。<strong>信号量不仅可以实现访问的互斥性，还可以实现进程间的同步</strong>，信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 <strong>P 操作和 V 操作</strong>。</p>
<p>与信号量名字很相似的叫<strong>信号</strong>，它俩名字虽然相似，但功能一点儿都不一样。信号是<strong>异步通信机制</strong>，信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令），一旦有信号发生，<strong>进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、3. 忽略信号</strong>。有两个信号是应用进程无法捕捉和忽略的，即 <code>SIGKILL</code> 和 <code>SIGSTOP</code>，这是为了方便我们能在任何时候结束或停止某个进程。</p>
<p>前面说到的通信机制，都是工作于同一台主机，如果<strong>要与不同主机的进程间通信，那么就需要 Socket 通信了</strong>。Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。</p>
<p>以上，就是进程间通信的主要机制了。你可能会问了，那线程通信间的方式呢？</p>
<p>同个进程下的线程之间都是共享进程的资源，只要是共享变量都可以做到线程间通信，比如全局变量，所以对于线程间关注的不是通信方式，而是关注多线程竞争共享资源的问题，信号量也同样可以在线程间实现互斥与同步：</p>
<ul>
<li>互斥的方式，可保证任意时刻只有一个线程访问共享资源；</li>
<li>同步的方式，可保证线程 A 应在线程 B 之前执行；</li>
</ul>
<h2 id="4、什么是死锁以及如何避免死锁？"><a href="#4、什么是死锁以及如何避免死锁？" class="headerlink" title="4、什么是死锁以及如何避免死锁？"></a>4、什么是死锁以及如何避免死锁？</h2><p><strong>死锁是指两个或多个线程在争夺系统资源时，由于相互等待对方释放资源而无法继续执行的状态。</strong></p>
<p>在多线程编程中，我们为了防止多线程竞争共享资源而导致数据错乱，都会在操作共享资源之前加上互斥锁，只有成功获得到锁的线程，才能操作共享资源，获取不到锁的线程就只能等待，直到锁被释放。</p>
<p>那么，当两个线程为了保护两个不同的共享资源而使用了两个互斥锁，那么这两个互斥锁应用不当的时候，可能会造成<strong>两个线程都在等待对方释放锁</strong>，在没有外力的作用下，这些线程会一直相互等待，就没办法继续运行，这种情况就是发生了<strong>死锁</strong></p>
<p>死锁只有<strong>同时满足</strong>以下四个条件才会发生：</p>
<ul>
<li>互斥条件：多个线程不能同时使用同一个资源</li>
<li>持有并等待条件：一个线程因为请求另外的资源被阻塞的时候，不会释放自己目前持有的资源。</li>
<li>不可剥夺条件：资源不能被强制性的从一个进程中夺走，只能由持有者资源释放释放。</li>
<li>环路等待条件：多个进程之间形成一个环形等待资源的链路，每个进程都在等待下一个进程释放自己所占有的资源</li>
</ul>
<p>只要破坏上面任意一个条件就可以破坏死锁。</p>
<p>破坏请求与保持条件：一次性申请所有的资源</p>
<p>破坏不可剥夺条件：占用资源的线程在申请其他资源被堵塞时，可以主动释放他已经占有的资源。</p>
<p>破坏循环等待条件：使用资源有序分配法，让所有进程按照相同的顺序请求资源，释放资源则反序释放。</p>
<p>总结：</p>
<p>简单来说，死锁问题的产生是由两个或者以上线程并行执行的时候，争夺资源而互相等待造成的。</p>
<p>死锁只有同时满足互斥、持有并等待、不可剥夺、环路等待这四个条件的时候才会发生。</p>
<p>所以要避免死锁问题，就是要破坏其中一个条件即可，<strong>最常用的方法就是使用资源有序分配法来破坏环路等待条件</strong></p>
<h2 id="5、什么是虚拟内存，为什么需要虚拟内存？"><a href="#5、什么是虚拟内存，为什么需要虚拟内存？" class="headerlink" title="5、什么是虚拟内存，为什么需要虚拟内存？"></a><strong>5、什么是虚拟内存，为什么需要虚拟内存？</strong></h2><p>虚拟内存在每一个进程创建加载的过程中，会分配一个连续的虚拟地址空间，他不是真实存在的，而是通过映射与实际地址空间对应，这样就可以是每个进程看起来都有自己独立的连续地址空间，并允许程序访问比物理内存更大的地址空间，每个程序都可以认为它拥有足够大的内存来运行。</p>
<p>需要虚拟内存有以下原因：</p>
<p>内存扩展：虚拟内存使得每个程序可以使用比实际可用内存更大的内存，从而允许运行更大的程序或处理更多的数据。</p>
<p>内存隔离：虚拟内存还提供了进程之间的内存隔离，每个进程都有自己的虚拟地址空间，因此一个进程无法直接访问另一个进程的内存。</p>
<p>物理内存管理：虚拟内存允许操作系统动态的将数据和程序的部分加载到物理内存中，以满足当前正在运行的进程的需求。当物理内存不足时，操作系统可以将不常用的数据或程序暂时移到硬盘上，从而释放内存，以便其他进程使用。</p>
<p>页面交换：当物理内存不足时，操作系统可以将一部分数据从物理内存写入到硬盘的虚拟内存中，这个过程被称为页面交换，当需要时，数据可以再次从虚拟内存中加载到物理内存中。这样可以保证系统可以继续运行，尽管物理内存有限。</p>
<p>内存映射文件：虚拟内存还可以用于将文件映射到内存中，这使得文件的读取和写入可以像访问内存一样高效。</p>
<h2 id="6、什么是内存分段和内存分页，作用是什么？"><a href="#6、什么是内存分段和内存分页，作用是什么？" class="headerlink" title="6、什么是内存分段和内存分页，作用是什么？"></a>6、什么是内存分段和内存分页，作用是什么？</h2><p><strong>核心功能是管理虚拟地址与物理地址的之间的映射关系</strong>。</p>
<p><strong>内存分段</strong>：将一个程序的内存空间分为不同的逻辑段（segments），每个段代表程序的一个功能模块或者数据类型，比如代码段、数据段、堆栈段等。每个段都有其自己的大小和权限。</p>
<p><strong>内存分页</strong>：把整个虚拟和物理空间分成固定大小的页（4KB），这样一个连续且大小固定的内存空间，称之为页。</p>
<p>作用：</p>
<p>1、<strong>逻辑隔离</strong>：内存分段和分页都实现了程序的逻辑隔离，使不同的功能模块或数据类型能够被单独的管理和保护，提高了程序的可靠性与安全性。</p>
<p>2、<strong>内存保护</strong>：通过将不同的段或页面设置为只读、可读写、不可执行等权限，操作系统可以确保程序不会越界访问或修改其他段的内容，从而提高了系统的稳定性。</p>
<p>3、<strong>虚拟内存</strong>：分段和分页都是为了实现虚拟内存的概念，允许应用程序认为他们使用的是一个比实际物理内存更大的内存空间。</p>
<p>4、<strong>内存共享</strong>：通过分页，操作系统可以实现内存页面的共享，从而节省内存空间，多个进程可以共享相同的代码段或数据页面。</p>
<p>5、<strong>内存管理</strong>：分页更加灵活，允许操作系统将不同进程的页面分散存放在物理内存中，从而提高内存利用率。分段则更适用于管理不同的逻辑模块。</p>
<p>分段和分页的区别：</p>
<p>分页对用户不可见，分段对用户可见。</p>
<p>分页的地址空间是一维的，分段的地址空间是二维的。</p>
<p>分页（单级页表）以及分段访问一个逻辑地址都需要两次访存，分段存储中可以引入快表机制</p>
<p>分段更容易实现信息的共享和保护</p>
<p>分段与分页的优缺点：</p>
<p>分页：内存空间利用率高，不会产生外部碎片，只会有少量的页内碎片，但不方便按照逻辑模块实现信息的共享与保护。</p>
<p>分段：方便按照逻辑模块实现信息的共享与保护，但是如果段长过大，为其分配很大的连续空间很不方便，且会产生外部碎片。</p>
<p><strong>7、解释一下用户态和内核态</strong></p>
<p><strong>用户态和内核态是操作系统中两种不同的执行模式，用于控制进程或程序对计算机硬件资源的访问权限和操作范围。</strong></p>
<p>用户态：在用户态下，进程或程序只能访问受限的资源和执行受限的指令集，不能直接访问操作系统的核心部分，也不能直接访问硬件资源，用户态下的CPU不能独占，允许被其他程序获取。</p>
<p>内核态：内核态是操作系统的特权级别，允许进程或程序执行特权指令和访问操作系统的核心部分。在内核态下，进程可以直接访问硬件资源，执行系统调用，管理内存、文件系统等操作。处于内核态的CPU可以从一个程序切换到另一个程序，并且占用CPU不会发生被抢占的情况。</p>
<p>用户空间的代码只能访问一个局部的内存空间，而内核空间的代码可以访问所有内存空间。因此，当程序使用用户空间时，我们常说该程序在<strong>用户态</strong>执行，而当程序使内核空间时，程序则在<strong>内核态</strong>执行。<strong>应用程序如果需要进入内核空间，就需要通过系统调用</strong>，内核程序执行在内核态，用户程序执行在用户态。<strong>当应用程序使用系统调用时，会产生一个中断</strong>。发生中断后， CPU 会中断当前在执行的用户程序，转而跳转到中断处理程序，也就是开始执行内核程序。内核处理完后，主动触发中断，把 CPU 执行权限交回给用户程序，回到用户态继续工作。</p>
<p>8、解释一下页面置换算法，例如LRU，FIFO等</p>
<p>在了解内存页面置换算法前，我们得先谈一下<strong>缺页异常（缺页中断）</strong>。</p>
<p>当 CPU 访问的页面不在物理内存时，便会产生一个缺页中断，请求操作系统将所缺页调入到物理内存。那它与一般中断的主要区别在于：</p>
<ul>
<li>缺页中断在指令执行「期间」产生和处理中断信号，而一般中断在一条指令执行「完成」后检查和处理中断信号。</li>
<li>缺页中断返回到该指令的开始重新执行「该指令」，而一般中断返回回到该指令的「下一个指令」执行。</li>
</ul>
<p><strong>缺页中断的处理流程</strong>：</p>
<ol>
<li>在 CPU 里访问一条 Load M 指令，然后 CPU 会去找 M 所对应的页表项。</li>
<li>如果该页表项的状态位是「有效的」，那 CPU 就可以直接去访问物理内存了，如果状态位是「无效的」，则 CPU 则会发送缺页中断请求。</li>
<li>操作系统收到了缺页中断，则会执行缺页中断处理函数，先会查找该页面在磁盘中的页面的位置。</li>
<li>找到磁盘中对应的页面后，需要把该页面换入到物理内存中，但是在换入前，需要在物理内存中找空闲页，如果找到空闲页，就把页面换入到物理内存中。</li>
<li>页面从磁盘换入到物理内存完成后，则把页表项中的状态位修改为「有效的」。</li>
<li>最后，CPU 重新执行导致缺页异常的指令。</li>
</ol>
<p>上面所说的过程，第 4 步是能在物理内存找到空闲页的情况，那如果找不到呢？</p>
<p>找不到空闲页的话，就说明此时内存已满了，这时候，就需要「页面置换算法」选择一个物理页，如果该物理页有被修改过（脏页），则把它换出到磁盘，然后把该被置换出去的页表项的状态改成「无效的」，最后把正在访问的页面装入到这个物理页中。如果没有修改，在置换该页时就不需要将该页写回到磁盘上，以减少系统的开销。</p>
<p>所以，页面置换算法的功能是，<strong>当出现缺页异常，需调入新页面而内存已满时，选择被置换的物理页面</strong>，也就是说选择一个物理页面换出到磁盘，然后把需要访问的页面换入到物理页，算法的目标是尽量减少页面的换入换出次数，减少系统的开销。</p>
<p>1、最佳置换算法</p>
<p>根据未来页面的访问情况，选择最长时间内不会被访问到的页面进行置换。那么就产生一个问题了，未来要访问什么页面操作系统如何未卜先知呢？所以该算法属于理想情况，用来衡量算法的优劣，越接近该算法的效率越高。</p>
<p>2、先进先出置换算法</p>
<p><strong>选择在内存驻留时间很长的页面进行中置换</strong>，这个就是「先进先出置换」算法的思想。但是FIFO算法可能会淘汰经常被使用的角色，导致切换次数增加。而且FIFO算法有可能出现贝拉迪异常：当分配给内存的空间增加时，切换次数反而增加了。</p>
<p>3、最近最久未使用算法（最近最少使用）</p>
<p>最近最久未使用（<em>LRU</em>）的置换算法的基本思路是，发生缺页时，<strong>选择最长时间没有被访问的页面进行置换</strong>，也就是说，该算法假设已经很久没有使用的页面很有可能在未来较长的一段时间内仍然不会被使用。</p>
<p>虽然 LRU 在理论上是可以实现的，但代价很高。为了完全实现 LRU，需要在内存中维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。困难的是，在每次访问内存时都必须要更新「整个链表」。在链表中找到一个页面，删除它，然后把它移动到表头是一个非常费时的操作。</p>
<p>所以，LRU 虽然看上去不错，但是由于开销比较大，实际应用中比较少使用。</p>
<p>4、时钟页面置换算法</p>
<p>那有没有一种即能优化置换的次数，也能方便实现的算法呢？</p>
<p><strong>时钟页面置换算法就可以两者兼得，它跟 LRU 近似，又是对 FIFO 的一种改进。</strong></p>
<p>该算法的思路是，把所有的页面都保存在一个类似钟面的「环形链表」中，一个表针指向最老的页面。</p>
<p>当发生缺页中断时，算法首先检查表针指向的页面：</p>
<ul>
<li>如果它的访问位位是 0 就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置；</li>
<li>如果访问位是 1 就清除访问位，并把表针前移一个位置，重复这个过程直到找到了一个访问位为 0 的页面为止；</li>
</ul>
<p>5、最不常用算法（LFU）</p>
<p><strong>当发生缺页中断时，选择「访问次数」最少的那个页面，并将其淘汰</strong>。</p>
<p>它的实现方式是，对每个页面设置一个「访问计数器」，每当一个页面被访问时，该页面的访问计数器就累加 1。在发生缺页中断时，淘汰计数器值最小的那个页面。</p>
<p>看起来很简单，每个页面加一个计数器就可以实现了，但是在操作系统中实现的时候，我们需要考虑效率和硬件成本的。</p>
<p>要增加一个计数器来实现，这个硬件成本是比较高的，另外如果要对这个计数器查找哪个页面访问次数最小，查找链表本身，如果链表长度很大，是非常耗时的，效率不高。</p>
<p>但还有个问题，LFU 算法只考虑了频率问题，没考虑时间的问题，比如有些页面在过去时间里访问的频率很高，但是现在已经没有访问了，而当前频繁访问的页面由于没有这些页面访问的次数高，在发生缺页中断时，就会可能会误伤当前刚开始频繁访问，但访问次数还不高的页面。</p>
<h2 id="7、解释一下进程同步和互斥，以及解决这些问题的方法？"><a href="#7、解释一下进程同步和互斥，以及解决这些问题的方法？" class="headerlink" title="7、解释一下进程同步和互斥，以及解决这些问题的方法？"></a>7、解释一下进程同步和互斥，以及解决这些问题的方法？</h2><p>互斥：在某一时刻只允许一个进程访问某个共享资源，当一个进程正在使用共享资源时，其他进程不能同时访问改共享资源。</p>
<p>进程同步：多个并发执行的进程之间协调和管理他们的执行顺序，以确保他们按照一定的顺序或时间间隔执行。</p>
<ul>
<li>同步就好比：「操作 A 应在操作 B 之前执行」，「操作 C 必须在操作 A 和操作 B 都完成之后才能执行」等；</li>
<li>互斥就好比：「操作 A 和操作 B 不能在同一时刻执行」</li>
</ul>
<p>临界区：将可能引发互斥问题的代码段称为临界区，为了实现互斥，每个进程在进入临界区前必须获取一个锁，退出临界区后释放该锁。确保同一时间只有一个进程可以进入临界区。</p>
<p>互斥锁：互斥锁是一种同步机制，用于实现互斥。每个共享资源都关联一个互斥锁，进程在访问该资源前需要获取互斥锁，使用完之后释放互斥锁，只有获得互斥锁的进程才能访问资源。</p>
<p>信号量：参考3.</p>
<p>信号初始化为 <code>1</code>，就代表着是<strong>互斥信号量</strong>，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。</p>
<p>我们可以初始化信号量为 <code>0</code>，就可以用信号量来实现多进程同步的方式，它可以保证进程 A 应在进程 B 之前执行。</p>
<h2 id="8、什么是中断和异常？二者有何区别？"><a href="#8、什么是中断和异常？二者有何区别？" class="headerlink" title="8、什么是中断和异常？二者有何区别？"></a>8、什么是中断和异常？二者有何区别？</h2><p>中断和异常是两种不同的事件，他们都会导致CPU暂停当前的程序执行，转而去执行一个特定的处理程序。</p>
<p>区别：</p>
<p><strong>中断是由外部设备或其他处理器产生的</strong>，通常是异步的，也就是说中断可以在任何时候发生。与当前执行的指令无关，比如键盘输入，鼠标移动等都会触发中断通知CPU去处理这些事件。</p>
<p><strong>异常是由CPU内部产生的</strong>，通常是同步的，也就是说只会在执行某些指令时发生，与当前执行的指令有关。比如访问非法内存地址，除数为零、执行非法指令等都会产生异常信号，通知CPU去处理这些错误或故障。</p>
<p><strong>中断可以被屏蔽或者禁止</strong>，意味着CPU可以通过设置某些标志位或寄存器来忽略或延迟响应某些中断信号。可以避免中断过于频繁或干扰重要的任务。</p>
<p><strong>异常不能被屏蔽或者禁止</strong>，意味着CPU必须立即响应异常信号，并进行相应的处理，这样可以保证程序的正确性和系统的稳定性。</p>
<p>中断的定义：CPU在执行指令时，收到某个中断信号转而去执行预先设定好的代码，然后再返回到原指令中继续执行，这就是中断机制。</p>
<p>中断的作用：</p>
<p>1、外设异步通知CPU，外设发生了什么事情或者完成了什么任务都可以通过中断异步通知CPU。</p>
<p>2、CPU之间发送消息，在SMP系统中，一个CPU想给另一个CPU发送消息，可以使用IPI（处理器间中断）。</p>
<p>3、处理CPU异常，CPU在执行指令的过程中遇到了异常会给自己发送中断信号来处理异常。</p>
<p>4、实现系统调用，早期的系统调用就是靠中断来实现的，后期虽然开发了专用的系统调用指令，但其基本原理还是相似的。</p>
<p>中断的产生：</p>
<p>1、外设（硬件中断），外设产生的中断信号时<strong>异步的</strong>，按照是否可以屏蔽分为可屏蔽中断和不可屏蔽中断。网卡、磁盘、定时器都可以产生硬件中断。</p>
<p>2、CPU，处理器间中断（IPI），可以看做一种特殊的硬件中断，<strong>异步</strong>。</p>
<p>3、CPU异常，<strong>同步的</strong>，在处理指令的过程中发现异常，会向自己发送中断信号，也叫做软件中断。CPU异常分为三类：</p>
<p>陷阱：不需要修复，中断处理完成后重新执行之前的指令。</p>
<p>故障：需要修复也有可能修复，中断处理完成后重新执行之前的指令。</p>
<p>中止：需要修复但是无法修复，中断处理完成后，进程或者内核将会崩溃。</p>
<p>4、中断指令，直接用CPU指令来产生中断信号，这种中断和CPU异常一样是<strong>同步的</strong>，也也可以叫做软件中断。</p>
<h2 id="9、介绍一下几种典型的锁"><a href="#9、介绍一下几种典型的锁" class="headerlink" title="9、介绍一下几种典型的锁"></a>9、介绍一下几种典型的锁</h2><p>加锁的目的就是保证共享资源在任意时间里，只有一个线程访问，这样就可以避免多线程导致共享数据错乱的问题。</p>
<p>两个基本的锁</p>
<p>1、互斥锁：一种最常见的锁类型，用于实现互斥访问共享资源。在任何时刻，只有一个线程可以持有互斥锁，其他线程必须等待直到锁被释放，确保了同一时间只有一个线程能够访问被保护的资源。</p>
<p>2、自旋锁：基于忙等待的锁，线程在尝试获取锁时会不断轮训，直到锁被释放。</p>
<ul>
<li><strong>互斥锁</strong>加锁失败后，线程会<strong>释放 CPU</strong> ，给其他线程；</li>
<li><strong>自旋锁</strong>加锁失败后，线程会<strong>忙等待</strong>，直到它拿到锁；</li>
</ul>
<p>其他的锁基于这两种锁</p>
<p>3、读写锁：允许多个线程同时共享资源，只允许一个线程进行写操作，读（共享）写（独占）两种状态。</p>
<p>4、悲观锁：认为多线程同时修改共享资源的概率比较高，所以访问资源时要上锁。</p>
<p>5、乐观锁：先不管，修改了共享资源再说，如果出现同时修改的情况，放弃本次操作。</p>
<p><strong>总结：</strong></p>
<p>开发过程中，最常见的就是互斥锁的了，互斥锁加锁失败时，会用「线程切换」来应对，当加锁失败的线程再次加锁成功后的这一过程，会有两次线程上下文切换的成本，性能损耗比较大。</p>
<p>如果我们明确知道被锁住的代码的执行时间很短，那我们应该选择开销比较小的自旋锁，因为自旋锁加锁失败时，并不会主动产生线程切换，而是一直忙等待，直到获取到锁，那么如果被锁住的代码执行时间很短，那这个忙等待的时间相对应也很短。</p>
<p>如果能区分读操作和写操作的场景，那读写锁就更合适了，它允许多个读线程可以同时持有读锁，提高了读的并发性。根据偏袒读方还是写方，可以分为读优先锁和写优先锁，读优先锁并发性很强，但是写线程会被饿死，而写优先锁会优先服务写线程，读线程也可能会被饿死，那为了避免饥饿的问题，于是就有了公平读写锁，它是用队列把请求锁的线程排队，并保证先入先出的原则来对线程加锁，这样便保证了某种线程不会被饿死，通用性也更好点。</p>
<p>互斥锁和自旋锁都是最基本的锁，读写锁可以根据场景来选择这两种锁其中的一个进行实现。</p>
<p>另外，互斥锁、自旋锁、读写锁都属于悲观锁，悲观锁认为并发访问共享资源时，冲突概率可能非常高，所以在访问共享资源前，都需要先加锁。</p>
<p>相反的，如果并发访问共享资源时，冲突概率非常低的话，就可以使用乐观锁，它的工作方式是，在访问共享资源时，不用先加锁，修改完共享资源后，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。</p>
<p>但是，一旦冲突概率上升，就不适合使用乐观锁了，因为它解决冲突的重试成本非常高。</p>
<p>不管使用的哪种锁，我们的加锁的代码范围应该尽可能的小，也就是加锁的粒度要小，这样执行速度会比较快。再来，使用上了合适的锁，就会快上加快了。</p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="1、一条SQL查询语句是如何执行的？"><a href="#1、一条SQL查询语句是如何执行的？" class="headerlink" title="1、一条SQL查询语句是如何执行的？"></a>1、一条SQL查询语句是如何执行的？</h2><p>1、连接器：负责跟客户端建立连接，获取权限、维持和管理连接。</p>
<ul>
<li><p>与客户端进行 TCP 三次握手建立连接；</p>
</li>
<li><p>校验客户端的用户名和密码，如果用户名或密码不对，则会报错；</p>
</li>
<li><p>如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限；</p>
</li>
</ul>
<p>2、查询缓存：如果 SQL 是查询语句（select 语句），MySQL 就会先去查询缓存（ Query Cache ）里查找缓存数据，看看之前有没有执行过这一条命令，这个查询缓存是以 key-value 形式保存在内存中的，key 为 SQL 查询语句，value 为 SQL 语句查询的结果。</p>
<p>如果查询的语句命中查询缓存，那么就会直接返回 value 给客户端。如果查询的语句没有命中查询缓存中，那么就要往下继续执行，等执行完后，查询的结果就会被存入查询缓存中。</p>
<p>PS：对于更新比较频繁的表，查询缓存的命中率很低的，因为只要一个表有更新操作，那么这个表的查询缓存就会被清空。如果刚缓存了一个查询结果很大的数据，还没被使用的时候，刚好这个表有更新操作，查询缓冲就被清空了，相当于缓存了个寂寞。<strong>所以，MySQL 8.0 版本直接将查询缓存删掉了，也就是说 MySQL 8.0 开始，执行一条 SQL 查询语句，不会再走到查询缓存这个阶段了</strong>。</p>
<p>3、解析SQL：解析器做的第一件事情，<strong>词法分析</strong>。MySQL 会根据你输入的字符串识别出关键字出来，第二件事情，<strong>语法分析</strong>，根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法，如果没问题就会构建出 SQL 语法树，这样方便后面模块获取 SQL 类型、表名、字段名、 where 条件等等。</p>
<p>4、执行SQL：</p>
<p>经过解析器后，接着就要进入执行 SQL 查询语句的流程了，每条<code>SELECT</code> 查询语句流程主要可以分为下面这三个阶段：</p>
<ul>
<li>prepare 阶段，也就是预处理阶段；</li>
<li>optimize 阶段，也就是优化阶段；</li>
<li>execute 阶段，也就是执行阶段；</li>
</ul>
<p><strong>预处理器</strong>：我们先来说说预处理阶段做了什么事情。</p>
<ul>
<li><p>检查 SQL 查询语句中的表或者字段是否存在；</p>
</li>
<li><p>将 <code>select *</code> 中的 <code>*</code> 符号，扩展为表上的所有列；</p>
</li>
</ul>
<p><strong>优化器</strong>：经过预处理阶段后，还需要为 SQL 查询语句先制定一个执行计划，这个工作交由「优化器」来完成的。</p>
<p><strong>优化器主要负责将 SQL 查询语句的执行方案确定下来</strong>，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。</p>
<p>举例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> product <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span>  <span class="hljs-keyword">and</span> name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;i%&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>这条查询语句的结果既可以使用主键索引，也可以使用普通索引，但是执行的效率会不同。这时，就需要优化器来决定使用哪个索引了。</p>
<p>很显然这条查询语句是<strong>覆盖索引</strong>，直接在二级索引就能查找到结果（因为二级索引的 B+ 树的叶子节点的数据存储的是主键值），就没必要在主键索引查找了，<strong>因为查询主键索引的 B+ 树的成本会比查询二级索引的 B+ 的成本大</strong>，优化器基于查询成本的考虑，会选择查询代价小的普通索引。</p>
<p><strong>执行器</strong>：经历完优化器后，就确定了执行方案，接下来 MySQL 就真正开始执行语句了，这个工作是由「执行器」完成的。在执行的过程中，执行器就会和存储引擎交互了，交互是以记录为单位的。</p>
<p>总结：</p>
<p>执行一条 SQL 查询语句，期间发生了什么？</p>
<ul>
<li>连接器：建立连接，管理连接、校验用户身份；</li>
<li>查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；</li>
<li>解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；</li>
<li>执行 SQL：执行 SQL 共有三个阶段：<ul>
<li>预处理阶段：检查表或字段是否存在；将 <code>select *</code> 中的 <code>*</code> 符号扩展为表上的所有列。</li>
<li>优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；</li>
<li>执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</li>
</ul>
</li>
</ul>
<h2 id="2、什么是索引"><a href="#2、什么是索引" class="headerlink" title="2、什么是索引"></a>2、什么是索引</h2><p>索引的定义就是帮助存储引擎快速获取数据的一种数据结构，形象的说就是索引是数据的目录。</p>
<h2 id="3、索引的分类"><a href="#3、索引的分类" class="headerlink" title="3、索引的分类"></a>3、索引的分类</h2><p>我们可以按照四个角度来分类索引。</p>
<ul>
<li><p>按「数据结构」分类：</p>
<p><strong>B+tree索引</strong>:所有数据存放在叶子结点，适合范围查询。</p>
<p><strong>Hash索引</strong>：适合等值查询，检索效率高，一次到位。</p>
<p><strong>Full-text索引</strong>：一般在文本类型char、text、varchar上创建。</p>
</li>
<li><p>按「物理存储」分类：</p>
<p><strong>聚簇索引（主键索引）</strong>：主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；</p>
<p><strong>二级索引（辅助索引）</strong>：二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。</p>
<p>所以，在查询时使用了二级索引，如果查询的数据能在二级索引里查询的到，那么就不需要回表，这个过程就是<strong>覆盖索引</strong>。如果查询的数据不在二级索引里，就会先检索二级索引，找到对应的叶子节点，获取到主键值后，然后再检索主键索引，就能查询到数据了，这个过程就是<strong>回表</strong>。</p>
</li>
<li><p>按「字段特性」分类：</p>
<p><strong>主键索引</strong>：主键索引就是建立在主键字段上的索引，通常在创建表的时候一起创建，<strong>一张表最多只有一个主键索引，索引列的值不允许有空值</strong>。</p>
<p><strong>唯一索引</strong>：唯一索引建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，<strong>索引列的值必须唯一，但是允许有空值</strong>。</p>
<p><strong>普通索引</strong>：普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE，<strong>允许空值和重复值</strong>。</p>
<p><strong>前缀索引</strong>：前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。</p>
</li>
<li><p>按「字段个数」分类：</p>
<p><strong>单列索引</strong>：立在单列上的索引称为单列索引，比如主键索引。</p>
<p><strong>联合索引</strong>：通过将多个字段组合成一个索引，该索引就被称为联合索引。使用联合索引时，存在<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配。在使用联合索引进行查询的时候，如果不遵循「最左匹配原则」，联合索引会失效，这样就无法利用到索引快速查询的特性了。</p>
<p>注意：联合索引有一些特殊情况，<strong>并不是查询过程使用了联合索引查询，就代表联合索引中的所有字段都用到了联合索引进行索引查询</strong>，也就是可能存在部分字段用到联合索引的 B+Tree，部分字段没有用到联合索引的 B+Tree 的情况。</p>
<p><strong>这种特殊情况就发生在范围查询</strong>。联合索引的最左匹配原则会一直向右匹配直到遇到「范围查询」就会停止匹配。<strong>也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引</strong>。</p>
</li>
</ul>
<h2 id="4、什么时候需要索引，什么时候不需要索引？"><a href="#4、什么时候需要索引，什么时候不需要索引？" class="headerlink" title="4、什么时候需要索引，什么时候不需要索引？"></a>4、什么时候需要索引，什么时候不需要索引？</h2><p>索引最大的好处是提高查询速度，但是索引也是有缺点的，比如：</p>
<ul>
<li>需要占用物理空间，数量越大，占用空间越大；</li>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增大；</li>
<li>会降低表的增删改的效率，因为每次增删改索引，B+ 树为了维护索引有序性，都需要进行动态维护。</li>
</ul>
<p>所以，索引不是万能钥匙，它也是根据场景来使用的。</p>
<h4 id="什么时候适用索引？"><a href="#什么时候适用索引？" class="headerlink" title="什么时候适用索引？"></a>什么时候适用索引？</h4><ul>
<li><strong>字段有唯一性限制的</strong>，比如商品编码；</li>
<li><strong>经常用于 <code>WHERE</code> 查询条件的字段</strong>，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。</li>
<li><strong>经常用于 <code>GROUP BY</code> 和 <code>ORDER BY</code> 的字段</strong>，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。</li>
</ul>
<h4 id="什么时候不需要创建索引？"><a href="#什么时候不需要创建索引？" class="headerlink" title="什么时候不需要创建索引？"></a>什么时候不需要创建索引？</h4><ul>
<li><strong><code>WHERE</code> 条件，<code>GROUP BY</code>，<code>ORDER BY</code> 里用不到的字段</strong>，索引的价值是快速定位，如果起不到定位的字段通常是<strong>不需要创建索引</strong>的，因为索引是会占用物理空间的。</li>
<li><strong>字段中存在大量重复数据，不需要创建索引</strong>，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。</li>
<li><strong>表数据太少的时候，不需要创建索引</strong>；（小表）</li>
<li><strong>经常更新的字段不用创建索引</strong>，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。</li>
</ul>
<h2 id="5、为什么MySql采用B-Tree作为索引？"><a href="#5、为什么MySql采用B-Tree作为索引？" class="headerlink" title="5、为什么MySql采用B+Tree作为索引？"></a>5、为什么MySql采用B+Tree作为索引？</h2><p>MySql的数据是持久化的，所以其数据（索引+记录）是保存在磁盘中的，防止设备断电而导致数据丢失。所以，当我们通过索引查找数据的时候，查询过程会发生多次磁盘IO，而磁盘IO发生次数越多，所消耗的时间也越大。</p>
<p>所以，我们希望索引的数据结构能在尽可能少的磁盘的 I&#x2F;O 操作中完成查询工作，因为磁盘 I&#x2F;O 操作越少，所消耗的时间也就越小</p>
<p>另外，另外，MySQL 是支持范围查找的，所以索引的数据结构不仅要能高效地查询某一个记录，而且也要能高效地执行范围查找。</p>
<p>综上所述，要设计一个适合 MySQL 索引的数据结构，至少满足以下要求：</p>
<ul>
<li>能在尽可能少的磁盘的 I&#x2F;O 操作中完成查询工作；</li>
<li>要能高效地查询某一个记录，也要能高效地执行范围查找；</li>
</ul>
<p>分析各种数据结构的优缺点：</p>
<p>二分查找法每次都把查询的范围减半，这样时间复杂度就降到了 O(logn)，但是每次查找都需要不断计算中间位置。</p>
<p>二叉查找树（搜索树）解决了连续结构插入新元素开销很大的问题，同时又保持着天然的二分结构，但是**当每次插入的元素都是二叉查找树中最大的元素，二叉查找树就会退化成了一条链表，查找数据的时间复杂度变成了 O(n)**。</p>
<p>为了解决二叉查找树会在极端情况下退化成链表的问题，后面就有人提出<strong>平衡二叉查找树（AVL 树）</strong>。主要是在二叉查找树的基础上增加了一些条件约束：<strong>每个节点的左子树和右子树的高度差不能超过 1</strong>。也就是说节点的左子树和右子树仍然为平衡二叉树，这样查询操作的时间复杂度就会一直维持在 O(logn)。但是<strong>不管平衡二叉查找树还是红黑树，都会随着插入的元素增多，而导致树的高度变高，这就意味着磁盘 I&#x2F;O 操作次数多，会影响整体数据查询的效率</strong>。</p>
<p>为了解决降低树的高度的问题，后面就出来了 <strong>B 树</strong>，它不再限制一个节点就只能有 2 个子节点，而是允许 M 个子节点 (M&gt;2)，从而降低树的高度。同样的节点数量在平衡二叉树的场景下，树的高度就会很高，意味着磁盘 I&#x2F;O 操作会更多。<strong>所以，B 树在数据查询中比平衡二叉树效率要高。</strong>但是 B 树的每个节点都包含数据（索引+记录），而用户的记录数据的大小很有可能远远超过了索引数据，这就需要花费更多的磁盘 I&#x2F;O 操作次数来读到「有用的索引数据」，另外，如果使用 B 树来做范围查询的话，需要使用中序遍历，这会涉及多个节点的磁盘 I&#x2F;O 问题，从而导致整体速度下降。</p>
<p>B+ 树与 B 树差异的点，主要是以下这几点：</p>
<ul>
<li><strong>叶子节点（最底部的节点）才会存放实际数据（索引+记录）</strong>，<strong>非叶子节点只会存放索引；</strong></li>
<li>所有索引都会在叶子节点出现，叶子节点之间构成一个有序链表；</li>
<li>非叶子节点的索引也会同时存在在子节点中，并且是在子节点中所有索引的最大（或最小）。</li>
<li>非叶子节点中有多少个子节点，就有多少个索引；</li>
</ul>
<p>总结：MySQL 默认的存储引擎 InnoDB 采用的是 B+ 树作为索引的数据结构，原因有：</p>
<ul>
<li>B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，<strong>查询底层节点的磁盘 I&#x2F;O次数会更少。</strong>–单点查询更快</li>
<li>B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；–插入和删除效率</li>
<li>B+ 树叶子节点之间用链表连接了起来，<strong>有利于范围查询</strong>，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I&#x2F;O 操作，范围查询效率不如 B+ 树。–范围查询</li>
</ul>
<h2 id="6、索引失效的场景有哪些？"><a href="#6、索引失效的场景有哪些？" class="headerlink" title="6、索引失效的场景有哪些？"></a>6、索引失效的场景有哪些？</h2><p>1、对索引使用左或者左右模糊匹配</p>
<p>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code> 这两种方式都会造成索引失效，<strong>因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较。</strong></p>
<p>2、对索引使用函数</p>
<p>有时候我们会用一些 MySQL 自带的函数来得到我们想要的结果，这时候要注意了，如果查询条件中对索引字段使用函数，就会导致索引失效。因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。</p>
<p><strong>从 MySQL 8.0 开始，索引特性增加了函数索引，即可以针对函数计算后的值建立一个索引，也就是说该索引的值是函数计算后的值，所以就可以通过扫描索引来查询数据。</strong></p>
<p>3、对索引进行表达式计算</p>
<p>在查询条件中对索引进行表达式计算，也是无法走索引的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">explain select * from t_user where id + 1 = 10; // 不行<br>explain select * from t_user where id = 10 -1;// 可以<br></code></pre></td></tr></table></figure>

<p>4、对索引进行隐式类型转换</p>
<p><strong>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较</strong>。</p>
<p>前面的例子一中的查询语句，我也跟大家说了是会走<strong>全表扫描</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>例子一的查询语句<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> phone <span class="hljs-operator">=</span> <span class="hljs-number">1300000001</span>;<br></code></pre></td></tr></table></figure>

<p>这是因为 phone 字段为字符串，所以 MySQL 要会自动把字符串转为数字，所以这条语句相当于：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> <span class="hljs-built_in">CAST</span>(phone <span class="hljs-keyword">AS</span> signed <span class="hljs-type">int</span>) <span class="hljs-operator">=</span> <span class="hljs-number">1300000001</span>;<br></code></pre></td></tr></table></figure>

<p>可以看到，<strong>CAST 函数是作用在了 phone 字段，而 phone 字段是索引，也就是对索引使用了函数！而前面我们也说了，对索引使用函数是会导致索引失效的</strong>。</p>
<p>例子二中的查询语句，我跟大家说了是会走索引扫描：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>例子二的查询语句<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> &quot;1&quot;;<br></code></pre></td></tr></table></figure>

<p>这时因为字符串部分是输入参数，也就需要将字符串转为数字，所以这条语句相当于：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-built_in">CAST</span>(&quot;1&quot; <span class="hljs-keyword">AS</span> signed <span class="hljs-type">int</span>);<br></code></pre></td></tr></table></figure>

<p>可以看到，<strong>索引字段并没有用任何函数，CAST 函数是用在了输入参数，因此是可以走索引扫描的。</strong></p>
<p>5、联合索引非最左匹配（或遇到范围查询）</p>
<p>对主键字段建立的索引叫做聚簇索引，对普通字段建立的索引叫做二级索引。</p>
<p>那么<strong>多个普通字段组合在一起创建的索引就叫做联合索引</strong>，也叫组合索引。</p>
<p>创建联合索引时，我们需要注意创建时的顺序问题，因为联合索引 (a, b, c) 和 (c, b, a) 在使用的时候会存在差别。联合索引要能正确使用需要遵循<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配。</p>
<p>也就是说，如果我们想使用联合索引中尽可能多的列，查询条件中的各个列必须是联合索引中从最左边开始连续的列。如果我们仅仅按照第二列搜索，肯定无法走索引。</p>
<p>6、WHERE语句中的OR</p>
<p>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</p>
<p>总结：</p>
<ul>
<li>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；</li>
<li>当我们在查询条件中对索引列使用函数，就会导致索引失效。</li>
<li>当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。</li>
<li>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。</li>
<li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li>
<li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效</li>
</ul>
<h2 id="7、事物有哪些特性"><a href="#7、事物有哪些特性" class="headerlink" title="7、事物有哪些特性"></a>7、事物有哪些特性</h2><p>1、<strong>原子性</strong>：事物是不可分割的最小工作单元，一个事物中的所有操作，要么全部完成，要么全部未完成，不会停留在中间状态（比如只完成一半）。如果事物执行过程中发生了错误，会被回滚到没执行操作之前原来的状态，像事物没有执行过一样。**–undo 回滚日志实现**</p>
<p>2、<strong>一致性</strong>：一个事物操作之前和执行之后的状态必须保持一致。比如用户 A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，用户 A 给用户 B 转账 200 元，分为两个步骤，从 A 的账户扣除 200 元和对 B 的账户增加 200 元。一致性就是要求上述步骤操作后，最后的结果是用户 A 还有 600 元，用户 B 有 800 元，总共 1400 元，而不会出现用户 A 扣除了 200 元，但用户 B 未增加的情况。**–其他三种共同保障**</p>
<p>3、隔离性：数据库允许多个并发事务同时对其数据进行修改和读取，隔离性可以防止多个事物并发执行时由于交叉执行导致的数据不一致的情况，因为多个事物并发执行的时候不会相互干扰，每个事物都有一个完整的数据空间，对其他并发事务是隔离的。**–MVCC（多版本并发控制）或者锁机制。**</p>
<p>4、持久性：事物处理结束之后，对数据的修改是永久的，即使系统故障也不会丢失。-<strong>-redo log（重做日志）</strong></p>
<h2 id="8、说一说事物的隔离级别以及他们都是怎么实现的？"><a href="#8、说一说事物的隔离级别以及他们都是怎么实现的？" class="headerlink" title="8、说一说事物的隔离级别以及他们都是怎么实现的？"></a>8、说一说事物的隔离级别以及他们都是怎么实现的？</h2><p>MySQL 服务端是允许多个客户端连接的，这意味着 MySQL 会出现同时处理多个事务的情况。那么<strong>在同时处理多个事务的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题</strong>。</p>
<p>当多个事务并发执行时可能会遇到「脏读、不可重复读、幻读」的现象，这些现象会对事务的一致性产生不同程序的影响。</p>
<ul>
<li>脏读：读到其他事务未提交的数据；</li>
<li>不可重复读：前后读取的数据不一致；</li>
<li>幻读：前后读取的记录数量不一致。</li>
</ul>
<p>SQL 标准提出了四种隔离级别来规避这些现象，隔离级别越高，性能效率就越低，这四个隔离级别如下：<strong>自上而下隔离级别逐级变高</strong>、性能越低</p>
<ul>
<li><strong>读未提交（*read uncommitted*）</strong>，指一个事务还没提交时，它做的变更就能被其他事务看到；</li>
<li><strong>读提交（*read committed*）</strong>，指一个事务提交之后，它做的变更才能被其他事务看到；</li>
<li><strong>可重复读（*repeatable read*）</strong>，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，<strong>MySQL InnoDB 引擎的默认隔离级别</strong>；</li>
<li><strong>串行化（*serializable* ）</strong>；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；</li>
</ul>
<p><strong>针对不同的隔离级别，并发事务时可能发生的现象也会不同</strong>，也就是说：</p>
<ul>
<li>在「读未提交」隔离级别下，可能发生<strong>脏读</strong>、<strong>不可重复读</strong>和<strong>幻读</strong>现象；</li>
<li>在「读提交」隔离级别下，可能发生<strong>不可重复读</strong>和<strong>幻读</strong>现象，但是不可能发生脏读现象；</li>
<li>在「可重复读」隔离级别下，可能发生<strong>幻读</strong>现象，但是不可能发生脏读和不可重复读现象；</li>
<li>在「串行化」隔离级别下，脏读、不可重复读和幻读现象都不可能会发生。</li>
</ul>
<p>要解决脏读现象，就要将隔离级别升级到读已提交以上的隔离级别，要解决不可重复读现象，就要将隔离级别升级到可重复读以上的隔离级别。</p>
<p>而对于幻读现象，不建议将隔离级别升级为串行化，因为这会导致数据库并发时性能很差。MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象，解决的方案有两种：</p>
<ul>
<li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li>
<li>针对<strong>当前读</strong>（select … for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li>
</ul>
<p>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同：</p>
<ul>
<li>「读提交」隔离级别是在<strong>每个 select 都会生成一个新的 Read View，</strong>也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。</li>
<li>「可重复读」隔离级别是<strong>启动事务时生成一个 Read View</strong>，然后整个事务期间都在用这个 Read View，<strong>这样就保证了在事务期间读到的数据都是事务启动前的记录。</strong></li>
</ul>
<p>这两个隔离级别实现是通过「事务的 Read View 里的字段」和「记录中的两个隐藏列」的比对，来控制并发事务访问同一个记录时的行为，这就叫 MVCC（多版本并发控制）。</p>
<p>在可重复读隔离级别中，普通的 select 语句就是基于 MVCC 实现的快照读，也就是不会加锁的。而 select .. for update 语句就不是快照读了，而是当前读了，也就是每次读都是拿到最新版本的数据，但是它会对读到的记录加上 next-key lock 锁。</p>
<h2 id="9、MySQL-可重复读隔离级别，完全解决幻读了吗？"><a href="#9、MySQL-可重复读隔离级别，完全解决幻读了吗？" class="headerlink" title="9、MySQL 可重复读隔离级别，完全解决幻读了吗？"></a>9、MySQL 可重复读隔离级别，完全解决幻读了吗？</h2><p>MySQL InnoDB 引擎的可重复读隔离级别（默认隔离级），根据不同的查询方式，分别提出了避免幻读的方案：</p>
<ul>
<li>针对<strong>快照读</strong>（普通 select 语句），是通过 MVCC 方式解决了幻读。</li>
<li>针对<strong>当前读</strong>（select … for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读。</li>
</ul>
<p>我举例了两个发生幻读场景的例子。</p>
<p>第一个例子：对于快照读， MVCC 并不能完全避免幻读现象。因为当事务 A 更新了一条事务 B 插入的记录，那么事务 A 前后两次查询的记录条目就不一样了，所以就发生幻读。</p>
<p>第二个例子：对于当前读，如果事务开启后，并没有执行当前读，而是先快照读，然后这期间如果其他事务插入了一条记录，那么事务后续使用当前读进行查询的时候，就会发现两次查询的记录条目就不一样了，所以就发生幻读。</p>
<p>所以，<strong>MySQL 可重复读隔离级别并没有彻底解决幻读，只是很大程度上避免了幻读现象的发生。</strong></p>
<p>要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select … for update 这类当前读的语句，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。</p>
<h2 id="10、MYSQL有哪些锁？作用是什么？"><a href="#10、MYSQL有哪些锁？作用是什么？" class="headerlink" title="10、MYSQL有哪些锁？作用是什么？"></a>10、MYSQL有哪些锁？作用是什么？</h2><h3 id="1、全局锁"><a href="#1、全局锁" class="headerlink" title="1、全局锁"></a>1、全局锁</h3><blockquote>
<p>1、全局锁是怎么用的？</p>
</blockquote>
<p>要使用全局锁，则要执行这条命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">flush tables <span class="hljs-keyword">with</span> read lock<br></code></pre></td></tr></table></figure>

<p>执行后，<strong>整个数据库就处于只读状态了</strong>，这时其他线程执行以下操作，都会被阻塞：</p>
<ul>
<li>对数据的增删改操作，比如 insert、delete、update等语句；</li>
<li>对表结构的更改操作，比如 alter table、drop table 等语句。</li>
</ul>
<p>如果要释放全局锁，则要执行这条命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">unlock tables<br></code></pre></td></tr></table></figure>

<p>当然，当会话断开了，全局锁会被自动释放。</p>
<blockquote>
<p>2、全局锁应用场景是什么？</p>
</blockquote>
<p>全局锁主要应用于做<strong>全库逻辑备份</strong>，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。</p>
<blockquote>
<p>3、加全局锁又会带来什么缺点呢？</p>
</blockquote>
<p>加上全局锁，意味着整个数据库都是<strong>只读状态</strong>。</p>
<p>那么如果数据库里有很多数据，备份就会花费很多的时间，关键是备份期间，业务只能读数据，而不能更新数据，这样会造成业务停滞。</p>
<blockquote>
<p>4、既然备份数据库数据的时候，使用全局锁会影响业务，那有什么其他方式可以避免？</p>
</blockquote>
<p>有的，如果数据库的引擎支持的事务支持<strong>可重复读的隔离级别</strong>，<strong>那么在备份数据库之前先开启事务</strong>，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。</p>
<p>因为在可重复读的隔离级别下，即使其他事务更新了表的数据，也不会影响备份数据库时的 Read View，这就是事务四大特性中的<strong>隔离性</strong>，这样备份期间备份的数据一直是在开启事务时的数据。</p>
<p>PS： InnoDB 存储引擎默认的事务隔离级别正是可重复读，因此可以采用这种方式来备份数据库。但是，对于 MyISAM 这种不支持事务的引擎，在备份数据库时就要使用全局锁的方法。</p>
<h3 id="2、表级锁"><a href="#2、表级锁" class="headerlink" title="2、表级锁"></a>2、表级锁</h3><blockquote>
<p>MySQL 表级锁有哪些？具体怎么用的。</p>
</blockquote>
<p>MySQL 里面表级别的锁有这几种：</p>
<ul>
<li><p>表锁：表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。</p>
<p>也就是说如果本线程对学生表加了「共享表锁」，那么本线程接下来如果要对学生表执行<strong>写操作</strong>的语句，是会被阻塞的，当然其他线程对学生表进行<strong>写操作</strong>时也会被阻塞，直到锁被释放。</p>
<p>不过尽量避免在使用 InnoDB 引擎的表使用表锁，因为表锁的颗粒度太大，<strong>会影响并发性能</strong>，<strong>InnoDB 牛逼的地方在于实现了颗粒度更细的行级锁</strong>。</p>
</li>
<li><p>元数据锁（MDL）：我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：</p>
<ul>
<li>对一张表进行 CRUD 操作时，加的是 <strong>MDL 读锁</strong>；</li>
<li>对一张表做结构变更操作的时候，加的是 <strong>MDL 写锁</strong>；</li>
</ul>
<p><strong>MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。</strong></p>
<p>当有线程在执行 select 语句（ 加 MDL 读锁）的期间，如果有其他线程要更改该表的结构（ 申请 MDL 写锁），那么将会被阻塞，直到执行完 select 语句（ 释放 MDL 读锁）。</p>
<p>反之，当有线程对表结构进行变更（ 加 MDL 写锁）的期间，如果有其他线程执行了 CRUD 操作（ 申请 MDL 读锁），那么就会被阻塞，直到表结构变更完成（ 释放 MDL 写锁）。</p>
<p>MDL 是在事务提交后才会释放，这意味着<strong>事务执行期间，MDL 是一直持有的</strong>。</p>
<p><strong>PS</strong>：申请 MDL 锁的操作会形成一个队列，队列中<strong>写锁获取优先级高于读锁</strong>，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。</p>
<p>所以为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中的<strong>长事务</strong>，是否有事务已经对表加上了 MDL 读锁，如果可以考虑 kill 掉这个长事务，然后再做表结构的变更。</p>
</li>
<li><p>意向锁：</p>
<p>在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；</p>
<p>在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；</p>
<p>也就是，当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。</p>
<p>而普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。</p>
<p><strong>意向锁的目的是为了快速判断表里是否有记录被加锁</strong>。</p>
</li>
<li><p>AUTO-INC 锁：表里的主键通常都会设置成自增的，这是通过对主键字段声明 <code>AUTO_INCREMENT</code> 属性实现的。</p>
<p>之后可以在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过 <strong>AUTO-INC 锁</strong>实现的。</p>
<p>AUTO-INC 锁是特殊的表锁机制，锁<strong>不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放</strong>。</p>
<p><strong>在插入数据时，会加一个表级别的 AUTO-INC 锁</strong>，然后为被 <code>AUTO_INCREMENT</code> 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。</p>
<p>那么，一个事务在持有 AUTO-INC 锁的过程中，其他事务如果要向该表插入语句都会被阻塞，从而保证插入数据时，被 <code>AUTO_INCREMENT</code> 修饰的字段的值是连续递增的。</p>
</li>
</ul>
<h3 id="3、行级锁"><a href="#3、行级锁" class="headerlink" title="3、行级锁"></a>3、行级锁</h3><p>行级锁的类型主要有三类：</p>
<ul>
<li>Record Lock，记录锁，也就是仅仅把一条记录锁上；</li>
<li>Gap Lock，间隙锁，锁定一个范围，<strong>但是不包含记录本身</strong>；</li>
<li>Next-Key Lock： Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</li>
</ul>
<h4 id="Record-Lock"><a href="#Record-Lock" class="headerlink" title="Record Lock"></a>Record Lock</h4><p>Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的：</p>
<ul>
<li>当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;</li>
<li>当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。</li>
</ul>
<h4 id="Gap-Lock"><a href="#Gap-Lock" class="headerlink" title="Gap Lock"></a>Gap Lock</h4><p>Gap Lock 称为间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。</p>
<p>假设，表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id &#x3D; 4 这条记录了，这样就有效的防止幻读现象的发生。</p>
<p>间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，<strong>间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的</strong>。</p>
<h4 id="Next-Key-Lock"><a href="#Next-Key-Lock" class="headerlink" title="Next-Key Lock"></a>Next-Key Lock</h4><p>Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</p>
<p>假设，表中有一个范围 id 为（3，5] 的 next-key lock，那么其他事务即不能插入 id &#x3D; 4 记录，也不能修改 id &#x3D; 5 这条记录。</p>
<p>所以，next-key lock 即能保护该记录，又能阻止其他事务将新纪录插入到被保护记录前面的间隙中。</p>
<p><strong>next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的</strong>。</p>
<h4 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h4><p>一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。</p>
<p>如果有的话，插入操作就会发生<strong>阻塞</strong>，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个<strong>插入意向锁</strong>，表明有事务想在某个区间插入新记录，但是现在处于等待状态。</p>
<p>插入意向锁名字虽然有意向锁，但是它并<strong>不是意向锁，它是一种特殊的间隙锁，属于行级别锁</strong>。</p>
<p>如果说间隙锁锁住的是一个区间，那么「插入意向锁」锁住的就是一个点。因而从这个角度来说，插入意向锁确实是一种特殊的间隙锁。</p>
<h2 id="11、MYSQL的执行引擎有哪些？"><a href="#11、MYSQL的执行引擎有哪些？" class="headerlink" title="11、MYSQL的执行引擎有哪些？"></a>11、MYSQL的执行引擎有哪些？</h2><p>1、InnoDB</p>
<p>该引擎提供了对事务ACID的支持，还提供了行级锁和外键的支持。</p>
<p>2、MyISAM</p>
<p>该引擎不支持事务，也不支持行级锁和外键约束。</p>
<p>3、Memery</p>
<p>将数据放在内存中，数据处理速度很快，但是安全性不高。</p>
<h2 id="12、MYSQL的日志文件有哪几种？"><a href="#12、MYSQL的日志文件有哪几种？" class="headerlink" title="12、MYSQL的日志文件有哪几种？"></a>12、MYSQL的日志文件有哪几种？</h2><ul>
<li><strong>undo log（回滚日志）</strong>：是InnoDB存储引擎层生成的日志，实现了事务中的<strong>原子性</strong>，主要用于<strong>事务回滚</strong>和 MVCC。</li>
<li><strong>redo log（重做日志）</strong>：是 InnoDB存储引擎层生成的日志，实现了事务中的<strong>持久性</strong>，主要<strong>用于掉电等故障恢复</strong>；</li>
<li><strong>binlog （归档日志）</strong>：是 Server 层生成的日志，主要<strong>用于数据备份和主从复制</strong>；</li>
</ul>
<p>1、undo log 两大作用：</p>
<ul>
<li><strong>实现事务回滚，保障事务的原子性</strong>。事务处理过程中，如果出现了错误或者用户执 行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。</li>
<li><strong>实现 MVCC（多版本并发控制）关键因素之一</strong>。MVCC 是通过 Read View + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，<strong>顺着 undo log 的版本链</strong>找到满足其可见性的记录。</li>
</ul>
<p>2、redo log 和 undo log 区别在哪？</p>
<p>这两种日志是属于 InnoDB 存储引擎的日志，它们的区别在于：</p>
<ul>
<li>redo log 记录了此次事务「<strong>完成后</strong>」的数据状态，记录的是更新<strong>之后</strong>的值；</li>
<li>undo log 记录了此次事务「<strong>开始前</strong>」的数据状态，记录的是更新<strong>之前</strong>的值；</li>
</ul>
<p><strong>事务提交之前</strong>发生了崩溃，重启后会通过 undo log 回滚事务，<strong>事务提交之后</strong>发生了崩溃，重启后会通过 redo log 恢复事务。<strong>Redo</strong> log 保证了事务四大特性中的<strong>持久性。</strong></p>
<p>3、为什么需要 redo log 这个问题我们有两个答案：</p>
<ul>
<li><strong>实现事务的持久性，让 MySQL 有 crash-safe 的能力</strong>，能够保证 MySQL 在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失；</li>
<li><strong>将写操作从「随机写」变成了「顺序写」</strong>，提升 MySQL 写入磁盘的性能。</li>
</ul>
<p><strong>WAL 技术指的是， MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上</strong>。</p>
<p>4、产生的 redo log 是直接写入磁盘的吗？</p>
<p>不是的。</p>
<p>实际上， 执行一个事务的过程中，产生的 redo log 也不是直接写入磁盘的，因为这样会产生大量的 I&#x2F;O 操作，而且磁盘的运行速度远慢于内存。</p>
<p>所以，redo log 也有自己的缓存—— <strong>redo log buffer</strong>，每当产生一条 redo log 时，会先写入到 redo log buffer，后续在持久化到磁盘如下图：</p>
<p>5、redo log 和 bin log有什么区别？</p>
<p>这两个日志有四个区别。</p>
<p><em>1、适用对象不同：</em></p>
<ul>
<li>binlog 是 MySQL 的 Server 层实现的日志，所有存储引擎都可以使用；</li>
<li>redo log 是 InnoDB存储引擎实现的日志；</li>
</ul>
<p><em>2、文件格式不同：</em></p>
<ul>
<li>binlog 有 3 种格式类型，分别是 STATEMENT（默认格式）、ROW、 MIXED，区别如下：<ul>
<li>STATEMENT：每一条修改数据的 SQL 都会被记录到 binlog 中（相当于记录了逻辑操作，所以针对这种格式， binlog 可以称为逻辑日志），主从复制中 slave 端再根据 SQL 语句重现。但 STATEMENT 有动态函数的问题，比如你用了 uuid 或者 now 这些函数，你在主库上执行的结果并不是你在从库执行的结果，这种随时在变的函数会导致复制的数据不一致；</li>
<li>ROW：记录行数据最终被修改成什么样了（这种格式的日志，就不能称为逻辑日志了），不会出现 STATEMENT 下动态函数的问题。但 ROW 的缺点是每行数据的变化结果都会被记录，比如执行批量 update 语句，更新多少行数据就会产生多少条记录，使 binlog 文件过大，而在 STATEMENT 格式下只会记录一个 update 语句而已；</li>
<li>MIXED：包含了 STATEMENT 和 ROW 模式，它会根据不同的情况自动使用 ROW 模式和 STATEMENT 模式；</li>
</ul>
</li>
<li>redo log 是物理日志，记录的是在某个数据页做了什么修改，比如对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新；</li>
</ul>
<p><em>3、写入方式不同：</em></p>
<ul>
<li>binlog 是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志。</li>
<li><strong>redo log 是循环写</strong>，日志空间大小是固定，全部写满就从头开始，保存未被刷入磁盘的脏页日志。</li>
</ul>
<p><em>4、用途不同：</em></p>
<ul>
<li>binlog 用于备份恢复、主从复制；</li>
<li>redo log 用于掉电等故障恢复。</li>
</ul>
<h2 id="13、MySQL-磁盘-I-O-很高，有什么优化的方法？"><a href="#13、MySQL-磁盘-I-O-很高，有什么优化的方法？" class="headerlink" title="13、MySQL 磁盘 I&#x2F;O 很高，有什么优化的方法？"></a>13、MySQL 磁盘 I&#x2F;O 很高，有什么优化的方法？</h2><p>现在我们知道事务在提交的时候，需要将 binlog 和 redo log 持久化到磁盘，那么如果出现 MySQL 磁盘 I&#x2F;O 很高的现象，我们可以通过控制以下参数，来 “延迟” binlog 和 redo log 刷盘的时机，从而降低磁盘 I&#x2F;O 的频率：</p>
<ul>
<li>设置组提交的两个参数： binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count 参数，延迟 binlog 刷盘的时机，从而减少 binlog 的刷盘次数。这个方法是基于“额外的故意等待”来实现的，因此可能会增加语句的响应时间，但即使 MySQL 进程中途挂了，也没有丢失数据的风险，因为 binlog 早被写入到 page cache 了，只要系统没有宕机，缓存在 page cache 里的 binlog 就会被持久化到磁盘。</li>
<li>将 sync_binlog 设置为大于 1 的值（比较常见是 100~1000），表示每次提交事务都 write，但累积 N 个事务后才 fsync，相当于延迟了 binlog 刷盘的时机。但是这样做的风险是，主机掉电时会丢 N 个事务的 binlog 日志。</li>
<li>将 innodb_flush_log_at_trx_commit 设置为 2。表示每次事务提交时，都只是缓存在 redo log buffer 里的 redo log 写到 redo log 文件，注意写入到「 redo log 文件」并不意味着写入到了磁盘，因为操作系统的文件系统中有个 Page Cache，专门用来缓存文件数据的，所以写入「 redo log文件」意味着写入到了操作系统的文件缓存，然后交由操作系统控制持久化到磁盘的时机。但是这样做的风险是，主机掉电的时候会丢数据。</li>
</ul>
<h2 id="14、总结"><a href="#14、总结" class="headerlink" title="14、总结"></a>14、总结</h2><p>具体更新一条记录 <code>UPDATE t_user SET name = &#39;xiaolin&#39; WHERE id = 1;</code> 的流程如下:</p>
<ol>
<li>执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id &#x3D; 1 这一行记录：<ul>
<li>如果 id&#x3D;1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新；</li>
<li>如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。</li>
</ul>
</li>
<li>执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样：<ul>
<li>如果一样的话就不进行后续更新流程；</li>
<li>如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作；</li>
</ul>
</li>
<li>开启事务， InnoDB 层更新记录前，首先要记录相应的 undo log，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，不过在内存修改该 Undo 页面后，需要记录对应的 redo log。</li>
<li>InnoDB 层开始更新记录，会先更新内存（同时标记为脏页），然后将记录写到 redo log 里面，这个时候更新就算完成了。为了减少磁盘I&#x2F;O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。这就是 <strong>WAL 技术</strong>，MySQL 的写操作并不是立刻写到磁盘上，而是先写 redo 日志，然后在合适的时间再将修改的行数据写到磁盘上。</li>
<li>至此，一条记录更新完了。</li>
<li>在一条更新语句执行完成后，然后开始记录该语句对应的 binlog，此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。</li>
<li>事务提交（为了方便说明，这里不说组提交的过程，只说<strong>两阶段提交</strong>）：<ul>
<li><strong>prepare 阶段</strong>：将 redo log 对应的事务状态设置为 prepare，然后将 redo log 刷新到硬盘；</li>
<li><strong>commit 阶段</strong>：将 binlog 刷新到磁盘，接着调用引擎的提交事务接口，将 redo log 状态设置为 commit（将事务设置为 commit 状态后，刷入到磁盘 redo log 文件）；</li>
</ul>
</li>
<li>至此，一条更新语句执行完成。</li>
</ol>
<p><strong>为什么需要两阶段提交：</strong>事务提交后，redo log 和 binlog 都要持久化到磁盘，但是这两个是独立的逻辑，可能出现半成功的状态，这样就造成两份日志之间的逻辑不一致。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>八股基础</div>
      <div>http://example.com/2024/05/10/八股基础/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>ZDS</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年5月10日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/05/21/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/" title="算法刷题">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">算法刷题</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/05/09/%E6%B0%B4%E4%B8%8B%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%B2%B8%E5%9F%BA%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91/" title="水下机器人岸基客户端开发">
                        <span class="hidden-mobile">水下机器人岸基客户端开发</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>

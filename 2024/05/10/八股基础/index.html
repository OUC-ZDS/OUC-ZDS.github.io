

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/icon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="ZDS">
  <meta name="keywords" content="">
  
    <meta name="description" content="计算机网络1、从输入URL到页面展示期间发生了什么？（1）检查缓存：浏览器收到用户请求后，先检查浏览器缓存里是否有该资源，如果有直接返回；如果没有，进入下一步网络请求。 （2）DNS域名解析：进行网络请求之前需要获取请求域名的IP地址，（HTTP协议）。如果是HTTPS，还需要建立TLS连接。DNS解析时会按照本地浏览器缓存-&gt;本地HOST文件-&gt;路由器缓存-&gt;DNS服务器-&amp;g">
<meta property="og:type" content="article">
<meta property="og:title" content="八股基础">
<meta property="og:url" content="http://example.com/2024/05/10/%E5%85%AB%E8%82%A1%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="佑安的个人博客">
<meta property="og:description" content="计算机网络1、从输入URL到页面展示期间发生了什么？（1）检查缓存：浏览器收到用户请求后，先检查浏览器缓存里是否有该资源，如果有直接返回；如果没有，进入下一步网络请求。 （2）DNS域名解析：进行网络请求之前需要获取请求域名的IP地址，（HTTP协议）。如果是HTTPS，还需要建立TLS连接。DNS解析时会按照本地浏览器缓存-&gt;本地HOST文件-&gt;路由器缓存-&gt;DNS服务器-&amp;g">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/98987d9417b2bab43087f45fc959d32a-20230309232253633.png">
<meta property="article:published_time" content="2024-05-10T11:48:02.000Z">
<meta property="article:modified_time" content="2024-06-16T08:34:48.547Z">
<meta property="article:author" content="ZDS">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png">
  
  
  
  <title>八股基础 - 佑安的个人博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>佑安的个人博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="八股基础"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-05-10 19:48" pubdate>
          2024年5月10日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          65k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          543 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">八股基础</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="1、从输入URL到页面展示期间发生了什么？"><a href="#1、从输入URL到页面展示期间发生了什么？" class="headerlink" title="1、从输入URL到页面展示期间发生了什么？"></a>1、从输入URL到页面展示期间发生了什么？</h2><p>（1）<strong>检查缓存</strong>：浏览器收到用户请求后，先检查浏览器缓存里是否有该资源，如果有直接返回；如果没有，进入下一步网络请求。</p>
<p>（2）<strong>DNS域名解析</strong>：进行网络请求之前需要获取请求域名的IP地址，（HTTP协议）。如果是HTTPS，还需要建立TLS连接。DNS解析时会按照本地浏览器缓存-&gt;本地HOST文件-&gt;路由器缓存-&gt;DNS服务器-&gt;根DNS服务器的顺序查询域名对应IP地址，直到找到为止。—-获取IP地址</p>
<p>DNS 中的域名都是用<strong>句点</strong>来分隔的，比如 <code>www.server.com.</code>，这里的句点代表了不同层次之间的<strong>界限</strong>。在域名中，<strong>越靠右</strong>的位置表示其层级<strong>越高</strong>。（最后一个点表示根域名）</p>
<p>（3）<strong>浏览器与服务器IP建立TCP连接</strong>（可靠传输）：建立连接后，浏览器端构建请求行、请求头等信息，并把和该域名相关的Cookie等数据附加到请求头中，向服务器构建请求信息。（由协议栈（TCP、IP)提供可靠传输–&gt;IP（远程定位）–&gt;MAC（两点传输）–&gt;网卡–&gt;交换机–&gt;路由器）</p>
<p>（4）<strong>服务器收到请求信息，根据请求生成响应数据，发给浏览器</strong>。</p>
<p>（5）<strong>浏览器解析服务器的响应数据</strong>：若响应头状态码为301、302，会重新定向到新地址（IP中的ICMP、ARP功能）；若响应数据类型是字节流类型，一般会将请求交给下载管理器；若是HTML类型，会进入下一步渲染流程。</p>
<p>（6）<strong>浏览器解析HTML文件</strong>，创建DOM树，解析CSS进行样式计算，然后将CSS与DOM合并，构建渲染树，最后布局和绘制渲染树，完成页面展示。</p>
<h2 id="2、HTTP常见面试题"><a href="#2、HTTP常见面试题" class="headerlink" title="2、HTTP常见面试题"></a>2、HTTP常见面试题</h2><h3 id="（1）什么是HTTP（超文本传输协议）"><a href="#（1）什么是HTTP（超文本传输协议）" class="headerlink" title="（1）什么是HTTP（超文本传输协议）"></a>（1）什么是HTTP（超文本传输协议）</h3><p>超文本：文字、图片、视频的混合体</p>
<p>传输：计算机世界中实现两点之间传输</p>
<p>协议：计算机世界里的约定和规范</p>
<p>即<strong>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</strong></p>
<h3 id="（2）HTTP常见的状态码有哪些"><a href="#（2）HTTP常见的状态码有哪些" class="headerlink" title="（2）HTTP常见的状态码有哪些"></a>（2）HTTP常见的状态码有哪些</h3><p><code>1xx</code> 类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少。–<strong>表示请求正在处理</strong></p>
<p><code>2xx</code> 类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态。**–表示请求照常处理完毕**</p>
<ul>
<li>「<strong>200 OK</strong>」是最常见的成功状态码，表示一切正常。如果是非 <code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据。</li>
<li>「<strong>204 No Content</strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</li>
<li>「<strong>206 Partial Content</strong>」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li>
</ul>
<p><code>3xx</code> 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</p>
<p><strong>–需要进行附加操作以完成请求</strong></p>
<ul>
<li>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</li>
<li>「<strong>302 Found</strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</li>
</ul>
<p>301 和 302 都会在响应头里使用字段 <code>Location</code>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p>
<ul>
<li>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。</li>
</ul>
<p><code>4xx</code> 类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</p>
<p>–<strong>客户端错误码，服务器无法处理请求</strong></p>
<ul>
<li>「<strong>400 Bad Request</strong>」表示<strong>客户端请求的报文有错误，但只是个笼统的错误</strong>。</li>
<li>「<strong>403 Forbidden</strong>」表示服务器禁止访问资源，并不是客户端的请求出错。</li>
<li>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li>
</ul>
<p><code>5xx</code> 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</p>
<p><strong>–服务器错误，处理请求时出错</strong></p>
<ul>
<li>「<strong>500 Internal Server Error</strong>」与 400 类型，<strong>是个笼统通用的错误码，服务器发生了什么错误，我们并不知道</strong>。</li>
<li>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li>
<li>「<strong>502 Bad Gateway</strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li>
<li>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。</li>
</ul>
<h3 id="（3）HTTP的常见字段有哪些"><a href="#（3）HTTP的常见字段有哪些" class="headerlink" title="（3）HTTP的常见字段有哪些"></a>（3）HTTP的常见字段有哪些</h3><p>HOST字段：客户端发送请求时，用来指定服务器的域名。</p>
<p>Content-Length 字段：服务器在返回数据时，会有 <code>Content-Length</code> 字段，表明本次回应的数据长度。</p>
<p><strong>HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决“粘包”的问题</strong></p>
<p>Connection 字段：<code>Connection</code> 字段最常用于客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用。</p>
<p>Content-Type 字段：<code>Content-Type</code> 字段用于服务器回应时，告诉客户端，本次数据是什么格式。</p>
<p>Content-Encoding 字段：<code>Content-Encoding</code> 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式。</p>
<h3 id="（4）-GET和POST有什么区别–常考"><a href="#（4）-GET和POST有什么区别–常考" class="headerlink" title="（4） GET和POST有什么区别–常考"></a>（4） GET和POST有什么区别–常考</h3><p>作用不同：<strong>GET用于从服务器获取资源；POST一般用来向服务器提交数据</strong>。</p>
<p>参数传递的方式不同：<strong>GET请求一般写在URL中，只接受ASCII字符。POST请求参数一般放在请求体中，对于数据类型也没有限制。</strong></p>
<p>安全性不同：由于传递参数方式不同，GET请求直接暴露在URL中，一般不用来传递敏感信息。</p>
<p>参数长度限制不同：<strong>GET传输量较小</strong>，<strong>不能大于2KB</strong>；<strong>POST传递的数据量较大，一般默认不受限制。</strong></p>
<p>编码方式不同：<strong>GET只进行URL编码，POST支持多种编码方式。</strong></p>
<p>缓存机制不同：<strong>GET请求会被浏览器主动cache，POST不会，需要手动设置</strong>。GET请求参数会被完整保留在浏览器历史里，POST中的参数不会被保留。GET产生的URL可以被保存为书签，POST不可以。GET在浏览器回退时是无害的，POST会再次提交请求。</p>
<p>时间消耗不同：GET产生一个TCP数据包，POST产生两个TCP数据包。</p>
<p>先说明下安全和幂等的概念：</p>
<ul>
<li>在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。</li>
<li>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。</li>
<li><strong>GET 方法就是安全且幂等的</strong>，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，<strong>可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签</strong>。</li>
<li><strong>POST</strong> 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等</strong>的。所以，<strong>浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签</strong>。</li>
</ul>
<h3 id="（5）HTTP的缓存方式"><a href="#（5）HTTP的缓存方式" class="headerlink" title="（5）HTTP的缓存方式"></a>（5）HTTP的缓存方式</h3><p>缓存解决什么问题：减少不必要的网络传输，节约带宽；更快地加载页面，提高响应速度；减少服务器的负载，避免服务过载的情况出现。</p>
<p>强制缓存：浏览器判断请求的目标资源是否有效命中强缓存，如果命中，则直接从缓存中读取目标资源，无需与服务器通信，也就是说决定是否使用缓存的主动性在于浏览器这边。</p>
<p>Expires强缓存：设置一个强缓存时间，此时间范围内，从内存中读取并返回，但是因为其判断缓存过期的机制是获取本地时间戳，与之前拿到的资源文件的Expires字段时间进行比较，存在漏洞：如果本地时间不准怎么办，目前已被弃用。</p>
<p>Cache-Control强缓存：</p>
<ul>
<li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；</li>
<li>浏览器再次请求访问服务器中的该资源时，会先<strong>通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期</strong>，如果没有，则使用该缓存，否则重新请求服务器；</li>
<li>服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control</li>
</ul>
<p>max-age决定客户端资源被缓存多久；s-maxage决定代理服务器缓存多长时间；no-cache表示强制进行协商缓存；no-store表示禁止任何缓存策略；public表示资源既可以被浏览器缓存也可以被代理服务器缓存。private表示资源只能被浏览器缓存，默认为private。</p>
<p>基于Last-modified的协商缓存：</p>
<p>首先在服务器端读出资源文件的修改时间，将读出来的修改时间赋值给响应头的last-modified字段，然后设置Cache-Control为no-cache（强制协商缓存），当客户端读取到last-modified的时候，会在下次请求的的头部携带一个If-Modified-Since,即服务器第一次修改的时候给他的时间。之后每次对该资源进行请求，都会带上If-Modified-Since字段，服务器会拿着个字段并再次读取该资源的修改时间，进行比较，决定是读取缓存还是返回新资源。</p>
<p>缺点：<strong>根据修改时间做判断</strong>，如果内容没修改那也有可能更新文件修改时间（重命名-再改回来），文件内容没修改但缓存失效了；当文件在极短时间内修改完成，文件修改时间以秒为单位<strong>未检测到毫秒级的改变</strong>，此时文件内容被修改了，但缓存依然可用，并不发送新文件。-<em>-存在的问题</em></p>
<p>基于Etag的协商缓存：将原先协商缓存的比较时间戳的形式修改成了比较文件指纹（根据文件内容计算的唯一哈希值），解决了Last-Modified存在的问题。</p>
<p>第一次请求某资源的时候，服务端读取文件并计算文件指纹，将文件指纹放在响应头的Etag字段中跟随资源一起返回给客户端。第二次请求某资源的时候，客户端从缓存中读取上一次服务端返回的Etag（文件指纹），并赋值给请求头的if-none-match字段，让其跟随请求一起发回服务端。服务端接收到请求头中的if-node-match（上一次的文件指纹），并对目标资源文件再次读取并生成文件指纹，两个文件指纹进行对比，如果吻合，则直接返回304状态码和空的响应并return，如果不吻合，将新的文件指纹存储到Etag并返回给客户端。</p>
<p>缺点：Etag需要计算文件指纹，服务端需要更多的计算开销，如果文件尺寸大且计算频繁，会影响服务器性能。同时，Etag有强验证和弱验证，强验证需要将生成的哈希码深入到每个字节，文件中只有一个字节被改变，也会生成不同的哈希值，非常消耗服务器资源。弱验证通过提取文件的部分属性来生成哈希值，不必精确到每个字节，速度快，但准确率不高，会降低协商缓存的有效性。</p>
<h3 id="（6）HTTP1-0与HTTP1-1的区别–常考"><a href="#（6）HTTP1-0与HTTP1-1的区别–常考" class="headerlink" title="（6）HTTP1.0与HTTP1.1的区别–常考"></a>（6）HTTP1.0与HTTP1.1的区别–常考</h3><p>1、长连接</p>
<p>HTTP1.1支持长连接，每一个TCP连接上可以传送多个HTTP请求和响应，默认开启Connection： <strong>Keep-Alive</strong>。</p>
<p>HTTP1.0默认是短连接，每次请求都需要建立一个TCP连接。</p>
<p>2、缓存</p>
<p>HTTP1.0主要使用If-Modified_Since、Expires来作为缓存判断标准</p>
<p><strong>HTTP1.1则引入了更多的缓存控制策略 比如Entity tag、If-None-Match等更多可选择的缓存头来控制缓存策略</strong>。（文件指纹）</p>
<p>3、管道化</p>
<p>基于HTTP1.1的长连接，使得请求管道化成为可能，管道化能使得请求并行传输，但响应必须按照请求发出的顺序依次返回，性能在一定程度上得到了改善。</p>
<p>4、增加了Host字段</p>
<p>使得一个服务器可以创建多个web站点。</p>
<p>5、状态码</p>
<p>新增了24个错误状态响应码</p>
<p>6、带宽优化</p>
<p>HTTP1.0中，存在浪费带宽的现象，例如客户端只是需要某个资源的一部分，但服务器将整个资源对象传输过来，不支持<strong>断点续传</strong>功能。</p>
<p><strong>HTTP1.1中加入了range头域，它允许只请求资源的某个部分，返回码是<code>206</code>（Partial content）</strong>。</p>
<h3 id="（7）HTTP2-0与HTTP1-1的区别"><a href="#（7）HTTP2-0与HTTP1-1的区别" class="headerlink" title="（7）HTTP2.0与HTTP1.1的区别"></a>（7）HTTP2.0与HTTP1.1的区别</h3><p>1、二进制分帧</p>
<p>HTTP2.0在应用层和传输层之间增加了一个<strong>二进制分帧层</strong>，突破了HTTP1.1的性能限制，<strong>改进了传输性能，实现低延迟高吞吐量。</strong></p>
<p>2、多路复用（MultiPlexing）</p>
<p>允许通过单一的HTTP2.0连接发起多重的请求-响应消息，这个功能基于“二进制分帧”的特性。</p>
<p>3、首部压缩</p>
<p>HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法<strong>对header数据进行压缩</strong>。<strong>减少了数据体积，使得传输更快</strong>。高效的压缩算法可以尽量压缩header，减少发送包的数量从而降低延迟。</p>
<p>4、服务端推送</p>
<p>HTTP2.0中，服务器可以对客户端的一个请求发送多个响应，即服务器可以额外的向客户端推送资源，无需客户端明确的请求。</p>
<h3 id="（8）HTTPS的工作原理（HTTPS是怎么建立连接的）"><a href="#（8）HTTPS的工作原理（HTTPS是怎么建立连接的）" class="headerlink" title="（8）HTTPS的工作原理（HTTPS是怎么建立连接的）"></a>（8）HTTPS的工作原理（HTTPS是怎么建立连接的）</h3><p>首先，客户端向服务器发送请求报文，请求与服务端建立连接。服务端产生一对公私密钥，然后将自己的公钥发送给CA机构，CA机构也有一对公私秘钥，CA机构使用自己的私钥将服务端发送过来的公钥进行加密，产生一个CA数字证书。（客户端–&gt;服务端&lt;–&gt;CA机构)</p>
<p>服务端响应客户端的请求，将CA机构生成的数字证书发送给客户端。(服务端–&gt;客户端)</p>
<p>客户端将服务端发送过来的数字证书进行解析，验证数字证书是否合法，不合法会发送警告，如果合法，取出服务端生成的公钥。客户端取出公钥并生成一个随机码key（对称加密中的秘钥），客户端将加密后的随机码key发送给服务端，作为之后对称加密的秘钥。（客户端–&gt;服务端）</p>
<p>服务端接收到随机码key（秘钥）后，使用服务端自己的私钥对他解密，然后获得这个随机码key。服务端使用这个随机码key对传输的数据进行加密，然后将加密后的内容发送给客户端。（服务端–&gt;客户端）</p>
<p>客户端使用自己生成的随机码key（密码）解密服务端发送过来的数据，之后客户端和服务端通过  对称加密传输数据，随机码key作为传输的秘钥。</p>
<h3 id="（9）HTTPS与HTTP的区别"><a href="#（9）HTTPS与HTTP的区别" class="headerlink" title="（9）HTTPS与HTTP的区别"></a>（9）HTTPS与HTTP的区别</h3><p>1、HTTP是明文传输，HTTPS通过SSL&#x2F;TLS进行加密。</p>
<p>2、HTTP的端口是80，HTTPS的端口是443</p>
<p>3、HTTPS需要到CA申请证书</p>
<p>4、HTTP的连接简单，是无状态的，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全。</p>
<h3 id="（10）DNS及其查询过程–只指路、不带路"><a href="#（10）DNS及其查询过程–只指路、不带路" class="headerlink" title="（10）DNS及其查询过程–只指路、不带路"></a>（10）DNS及其查询过程–只指路、不带路</h3><p>DNS（域名管理系统），当用户使用浏览器访问网址的时候，使用的第一个重要协议，解决的是域名和IP地址映射的问题。</p>
<p>用户在浏览器输入URL地址之后，会先在浏览器缓存中查询是否有该域名对应的IP地址。</p>
<p>如果<strong>浏览器缓存</strong>中没有，会去计算机<strong>本地的Host文件</strong>中查询是否有对应的缓存，是否有该域名对应的IP地址。</p>
<p>如果Host文件中也没有则会向<strong>本地DNS服务器</strong>发送一个DNS查询请求。本地DNS解析器没有缓存该域名的解析记录，它会向<strong>根DNS服务器</strong>发出查询请求，根DNS服务器不负责具体的域名解析，它会告诉本地DNS服务器应该向哪个<strong>顶级域DNS服务器</strong>发送查询请求。</p>
<p>本地DNS服务器接着向顶级域DNS服务器发送查询请求，顶级域DNS服务器也不负责具体的域名解析，它会告诉本地DNS服务器前往哪个<strong>权威域名DNS服务器</strong>发送查询请求。</p>
<p>本地DNS服务器接着向权威DNS服务器发送查询请求，权威DNS服务器是负责存储特定域名和IP地址映射的服务器。当权威DNS服务器收到查询请求是，会查找“example.com”域名对应的IP地址，并将结果返回给<strong>本地DNS服务器</strong>。</p>
<p>本地DNS服务器将收到的IP地址返回给浏览器，并将域名解析结果缓存在本地，以便下次更快响应。</p>
<h3 id="（11）HTTP多个TCP连接怎么实现–靠头部的Keep-Alive"><a href="#（11）HTTP多个TCP连接怎么实现–靠头部的Keep-Alive" class="headerlink" title="（11）HTTP多个TCP连接怎么实现–靠头部的Keep-Alive"></a>（11）HTTP多个TCP连接怎么实现–靠头部的Keep-Alive</h3><p>多个tcp连接是靠某些服务器对Connection： <strong>keep-alive</strong>的Header的支持。即完成这个HTTP请求之后，不要断开HTTP请求使用的TCP连接，这样的好处是连接可以被重复使用，之后发送的HTTP请求不需要重新建立新的TCP连接，并且SSL的开销也可以避免。</p>
<h3 id="（12）TCP的keepalive和HTTP的keep-alive是一个东西吗"><a href="#（12）TCP的keepalive和HTTP的keep-alive是一个东西吗" class="headerlink" title="（12）TCP的keepalive和HTTP的keep-alive是一个东西吗"></a>（12）TCP的keepalive和HTTP的keep-alive是一个东西吗</h3><p>HTTP的keep-alive，是由应用层（用户态）实现的，成为HTTP长连接：—<strong>保持成为长连接</strong></p>
<p>每次请求都要经历这样的过程：建立TCP-&gt;请求资源-&gt;响应资源-&gt;释放连接，这是<strong>HTTP短连接</strong>，但是这样每次建立连接都只能请求一次资源，所以<strong>HTTP通过keep-alive实现了使用同一个TCP连接来发送和接收多个HTTP请求</strong>，避免了连接建立和释放的开销，即HTTP长连接。</p>
<p>TCP的keepalive，是由TCP层（内核态）实现的，称为<strong>TCP保活机制</strong>。—<strong>判断是否存活</strong></p>
<p>TCP有一个定时任务倒计时，超时后会触发任务，内容是发送一个探测报文给对端，用来判断对端是否存活。</p>
<h3 id="（13）HTTP的长连接如何保活？"><a href="#（13）HTTP的长连接如何保活？" class="headerlink" title="（13）HTTP的长连接如何保活？"></a>（13）HTTP的长连接如何保活？</h3><ul>
<li>在服务器端设置一个保活定时器，当定时器开始工作后就定时的向网络通信的另一端发出保活探测的TCP报文，如果接收到了ACK报文，那么就证明对方存活，可以继续保有连接；否则就证明网络存在故障。</li>
<li>通过在客户端发送心跳包来检测服务器是否存活。如果服务器在一定时间内没有收到客户端的心跳包，则认为服务器已经宕机了，需要重新建立连接。</li>
<li>通过在服务器端设置keep-alive参数来实现长连接保活。keep-alive参数指定了客户端与服务器之间的长连接超时时间，超过这个时间后，如果没有数据传输，则自动断开连接。如果在这个时间内有数据传输，则重置超时时间。</li>
</ul>
<h3 id="（14）HTTP-2的缺点"><a href="#（14）HTTP-2的缺点" class="headerlink" title="（14）HTTP&#x2F;2的缺点"></a>（14）HTTP&#x2F;2的缺点</h3><p> HTTP2.0协议是基于TCP实现的，所以存在三个缺陷： </p>
<p>（i）队头阻塞 </p>
<p>（ii）TCP与TLS的握⼿时延迟 </p>
<p>（iii)⽹络迁移需要重新连接 </p>
<h2 id="3、TCP连接如何确保可靠性"><a href="#3、TCP连接如何确保可靠性" class="headerlink" title="3、TCP连接如何确保可靠性"></a>3、TCP连接如何确保可靠性</h2><p>1、数据块大小控制：应用数据被分割成TCP认为最合适发送的数据块，再传输给网络层，数据块被称为报文段或段。</p>
<p>2、序列号：TCP给每个数据包指定序列号，接收方根据序列号对数据包进行排序，并根据序列号对数据包进行去重。</p>
<p>3、校验和：TCP将保持首部和数据的校验和，这是一个端到端的校验和，目的是检测数据在传输过程中的任何变化，如果收到的报文的校验和有误，TCP将丢弃这个报文段和不确认收到此报文段（对面要重新发送或采取别的措施）</p>
<p>4、流量控制：TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据，当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止数据包丢失。TCP利用滑动窗口实现流量控制。</p>
<p>5、拥塞控制：当网络拥塞时，减少数据的发送。（有其拥塞控制算法–见4）</p>
<p>6、确认应答：用过ARQ协议实现。基本原理是每发完一个分组就停止发送，等待对方确认。如果没收到确定就重新发送数据包，直到确认后再发送下一个分组。</p>
<p>7、超时重传：当TCP发出一个数据段后，启动一个定时器，等待目的端的确认收到这个报文段，如果在定时器时间内没收到，将重新发送这个报文段。 <strong>超时重传时间 RTO 的值应该略大于报文往返 RTT 的值</strong></p>
<p>还有一种实现重传机制的方式叫：<code>SACK</code>（ Selective Acknowledgment）， <strong>选择性确认</strong>。</p>
<p>这种方式需要在 TCP 头部「选项」字段里加一个 <code>SACK</code> 的东西，它<strong>可以将已收到的数据的信息发送给「发送方」</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong>。</p>
<h2 id="4、既然提到了拥塞控制，拥塞控制是怎么实现的？"><a href="#4、既然提到了拥塞控制，拥塞控制是怎么实现的？" class="headerlink" title="4、既然提到了拥塞控制，拥塞控制是怎么实现的？"></a>4、既然提到了拥塞控制，拥塞控制是怎么实现的？</h2><p>拥塞控制算法主要有以下几种：</p>
<p>1、慢启动</p>
<p>在连接刚开始时，发送方会逐渐增加发送窗口的大小，以指数增长的速度增加发送窗口的数据量。</p>
<p>2、拥塞避免</p>
<p>一旦慢启动阶段过去，发送方进入拥塞避免阶段，在这个阶段，发送方会逐渐增加发送窗口的大小，但增加速率较慢，以线性增长的方式，避免过快增加导致网络拥塞。</p>
<p>3、超时重传</p>
<p>如果发送方在超时时间内未收到确认，他会认为数据包丢失，并重传这些数据包。这是拥塞控制的最后手段，用于检测和处理网络中的丢包和拥塞情况。</p>
<p>4、快速重传</p>
<p>当发送方发送的数据包丢失或者网络出现拥塞时，接收方会重复发送确认通知（ACK）来通知发送方有数据丢失，当发送方收到三次重复确认时，在超时时间到期内立刻重新发送丢失的数据包，而不是等超时之后再发，这样可以减少网络的拥塞程度。</p>
<p>5、拥塞窗口调整</p>
<p>发送方根据网络的拥塞程度动态调整发送窗口的大小，通过监测网络延迟和丢包情况来确定合适的发送速率，以避免网络拥塞。</p>
<h2 id="5、Cookie和Session是什么，有什么区别？"><a href="#5、Cookie和Session是什么，有什么区别？" class="headerlink" title="5、Cookie和Session是什么，有什么区别？"></a>5、Cookie和Session是什么，有什么区别？</h2><p>Cookie和Session都用于管理用户的状态和身份。</p>
<p>Cookie通过在客户端记录信息来确定用户身份。</p>
<p>Session通过在服务器端记录信息确定用户身份。</p>
<p>1、Cookie</p>
<p>Cook是存储在用户浏览器中的小型文本文件，用于在用户和服务器之间传递数据。通常服务器会将一个或多个Cookie发送到用户浏览器，然后浏览器将这些Cookie存储在本地。</p>
<p>服务端在接收到来自客户端浏览器的请求之后，能够通过分析存放于请求头中的Cookie得到客户端特有的信息，从而动态生成与该客户端相对应的内容。</p>
<p>2、Session</p>
<p>客户端浏览器访问服务器的时候，服务器把客户端信息以某种新式记录在服务器上，即Session。Session主要用于维护用户登录状态、存储用户的临时数据和上下文信息等。</p>
<p>3、区别</p>
<p>存储位置：Cookie存储于用户的浏览器中，Session存储于服务器上。</p>
<p>数据容量：Cookie存储容量较小，一般为几KB，Session存储容量较大，通常没有固定限制，取决于服务器的配置和资源。</p>
<p>安全性：Cookie存储于用户浏览器中可以被用户读取和篡改。相比之下，Session存储于服务器上更难被访问和修改。</p>
<p>传输方式：Cookie在每次HTTP请求中会被自动发送到服务器，而Session ID通常通过Cookie或者URL参数传递。</p>
<h2 id="6、HTTP协议与RPC协议"><a href="#6、HTTP协议与RPC协议" class="headerlink" title="6、HTTP协议与RPC协议"></a>6、HTTP协议与RPC协议</h2><ul>
<li>纯裸 TCP 是能收发数据，但它是个<strong>无边界</strong>的数据流，上层需要定义<strong>消息格式</strong>用于定义<strong>消息边界</strong>。于是就有了各种协议，HTTP 和各类 RPC 协议就是在 TCP 之上定义的应用层协议。</li>
<li><strong>RPC 本质上不算是协议，而是一种调用方式</strong>，而像 gRPC 和 Thrift 这样的具体实现，才是协议，它们是实现了 RPC 调用的协议。目的是希望程序员能像调用本地方法那样去调用远端的服务方法。同时 RPC 有很多种实现方式，<strong>不一定非得基于 TCP 协议</strong>。</li>
<li>从发展历史来说，<strong>HTTP 主要用于 B&#x2F;S 架构，而 RPC 更多用于 C&#x2F;S 架构。但现在其实已经没分那么清了，B&#x2F;S 和 C&#x2F;S 在慢慢融合</strong>。很多软件同时支持多端，所以对外一般用 HTTP 协议，而内部集群的微服务之间则采用 RPC 协议进行通讯。</li>
<li>RPC 其实比 HTTP 出现的要早，且比目前主流的 HTTP&#x2F;1.1 <strong>性能</strong>要更好，所以大部分公司内部都还在使用 RPC。</li>
<li><strong>HTTP&#x2F;2.0</strong> 在 <strong>HTTP&#x2F;1.1</strong> 的基础上做了优化，性能可能比很多 RPC 协议都要好，但由于是这几年才出来的，所以也不太可能取代掉 RPC</li>
</ul>
<h2 id="7、TCP和UDP的区别"><a href="#7、TCP和UDP的区别" class="headerlink" title="7、TCP和UDP的区别"></a>7、TCP和UDP的区别</h2><ol>
<li>TCP是面向连接的协议，建立和释放连接需要进行三次握手和四次挥手。UDP是面向无连接的协议，无需进行三次握手和四次挥手。说明udp比TCP实时性更强。</li>
<li>TCP 是流式传输，没有边界，但保证顺序和可靠。UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li>
<li>TCP连接的可靠性强，UDP的可靠性不强。</li>
<li>TCP只能一对一，UDP支持一对多和多对多。</li>
<li>TCP的头部开销比UDP大。TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li>
</ol>
<h2 id="8、封包和拆包听说过吗？"><a href="#8、封包和拆包听说过吗？" class="headerlink" title="8、封包和拆包听说过吗？"></a>8、封包和拆包听说过吗？</h2><p>封包和拆包都是基于TCP的概念。因为TCP是无边界的流传输，所以需要对TCP进行封包和拆包，确保发送和接收的数据不粘连。</p>
<ul>
<li>封包：封包就是在发送数据报的时候为每个TCP数据包加上一个包头，将数据报分为包头和包体两个部分。包头是一个固定长度的结构体，里面包含该数据包的总长度。</li>
<li>拆包：接收方在接收到报文后提取包头中的长度信息进行截取。</li>
</ul>
<h2 id="9、UDP怎么实现可靠传输？"><a href="#9、UDP怎么实现可靠传输？" class="headerlink" title="9、UDP怎么实现可靠传输？"></a>9、UDP怎么实现可靠传输？</h2><p>最简单的方式是在应用层模仿传输层TCP的可靠性传输。下面不考虑拥塞处理，可靠UDP的简单设计。<br>1、添加seq&#x2F;ack机制，确保数据发送到对端<br>2、添加发送和接收缓冲区，主要是用户超时重传。<br>3、添加超时重传机制。<br>详细说明：发送端发送数据时，生成一个随机seq&#x3D;x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack&#x3D;x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。</p>
<p>10、TCP还有什么机制可以保证可靠传输？</p>
<p>除了TCP本身提供的可靠传输机制即序号和确认号、超时重传、滑动窗口、确认机制、拥塞控制之外，还有其他层上的方式可以保证数据的可靠传输。</p>
<p>比如在数<strong>据链路层和物理层上</strong>，常用的技术包括<strong>循环冗余校验</strong>（CRC）、<strong>帧检验序列</strong>（FCS）等，用于检测和纠正数据传输中的错误。</p>
<p>在应用层上，常用的方法包括<strong>数据重传、数据校验</strong>等。例如，HTTP协议通常会在应用层上进行数据重传，以保证数据的可靠传输。另外，<strong>应用层协议也可以使用一些校验算法，如MD5、SHA等</strong>，来验证数据的完整性，以保证数据在传输过程中不被篡改。</p>
<p>总之，在不同层次上都可以采用不同的技术和机制来保证数据的可靠传输，这些机制相互配合，共同保障了数据的安全和可靠性</p>
<h2 id="10、DNS的负载均衡是什么策略"><a href="#10、DNS的负载均衡是什么策略" class="headerlink" title="10、DNS的负载均衡是什么策略"></a>10、DNS的负载均衡是什么策略</h2><p>当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会崩掉。处理办法就是用DNS负载均衡技术，它的原理是在<strong>DNS服务器中为同一个主机名配置多个IP地址,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器</strong>，从而达到负载均衡的目的｡</p>
<h2 id="11、TCP建立连接为什么需要三次握手，不是两次、四次？"><a href="#11、TCP建立连接为什么需要三次握手，不是两次、四次？" class="headerlink" title="11、TCP建立连接为什么需要三次握手，不是两次、四次？"></a>11、TCP建立连接为什么需要三次握手，不是两次、四次？</h2><ol>
<li>三次握⼿才可以阻⽌重复历史连接的初始化(主因)</li>
<li>三次握⼿才可以同步双⽅的初始序列号 </li>
<li>三次握⼿才可以避免资源浪费</li>
</ol>
<p>1、阻⽌重复历史连接的初始化（主因）</p>
<ol>
<li>当因为⽹络阻塞原因，客户端向服务器发送了两次SYN报⽂ </li>
<li>旧的SYN报⽂先到达服务端，服务端回⼀个ACK+SYN报⽂ </li>
<li>客户端收到后可以根据⾃身的上下⽂，判断这是⼀个历史连接（序列号过期或超时），那么客户端就会发送 RST 报⽂给服务端，表示中⽌这⼀次连接。 </li>
<li>服务器收到RST报⽂，会释放连接 </li>
<li>新的SYN报⽂抵达之后，客户端和服务器之间进⾏正常的三次握⼿ 如果只是两次握⼿，服务端在收到SYN报⽂之后，就进⼊到 ESTABLISHED 状态, 服务器端并不知道这次是历史连 接，直接与客户端建⽴连接并向客户端发送数据（资源浪费），但是客户端会判定这次连接是历史连接，从⽽发送 RST报⽂来断开连接。 所以要想让服务器发送数据前，阻⽌掉历史连接，就需要三次握⼿。</li>
</ol>
<p>2、同步双⽅的初始序列号  </p>
<p>TCP 协议的通信双⽅， 都必须维护⼀个「序列号」， 序列号是可靠传输的⼀个关键因素。 接收端可以去除重复数据。 接收端可以按照序列号顺序接收。 标识发送的数据包，哪些已经被收到。 </p>
<ol>
<li>客户端发送第⼀个报⽂，携带客户端初始序列号的SYN报⽂。</li>
<li>服务器发送第⼆个报⽂，携带服务器初始序列号的ACK + SYN的应答报⽂，表示收到客户端的SYN报⽂。 </li>
<li>客户端发送第三个报⽂，携带服务器的ACK应答报⽂。 这样⼀来⼀回，才能确保双⽅的初始序列号能被可靠的同步。 两次握⼿只保证了⼀⽅的初始序列号能被对⽅成功接收，没办法保证双⽅的初始序列号都能被确认接收。四次握⼿ 也能保证双⽅的初始化序号同步，但是可以省略成三次。</li>
</ol>
<p>3、避免资源浪费</p>
<ol>
<li>只有两次握⼿时，如果客户端的SYN请求连接在⽹络中阻塞，客户端没有收到服务端的ACK报⽂，会重新发送 SYN。</li>
<li>由于没有第三次握⼿，服务器不清楚客户端是否收到了⾃⼰发送的建⽴连接的 ACK 确认信号，所以每收到⼀ 个 SYN 就只能先主动建⽴⼀个连接， 建⽴多个冗余的⽆效链接，造成不必要的资源浪费。</li>
<li>所以通过TCP三次握⼿，能防⽌历史连接的建⽴，能减少双⽅不必要的资源开销，能帮助双⽅同步初始化序列号 </li>
<li>「两次握⼿」：⽆法防⽌历史连接的建⽴，会造成双⽅资源的浪费，也⽆法可靠的同步双⽅序列号；</li>
<li>「四次握⼿」：三次握⼿就已经理论上最少可靠连接建⽴，所以不需要使⽤更多的通信次数。</li>
</ol>
<h2 id="12、什么是半连接队列"><a href="#12、什么是半连接队列" class="headerlink" title="12、什么是半连接队列"></a>12、什么是半连接队列</h2><p>半连接队列（SYN队列）</p>
<p>⽤于存放已经发送了 SYN（同步）包，但还未完成三次握⼿的连接：服务器第⼀次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双⽅还没有完全建⽴其连接，服务器会把此种状态下请求连接放在⼀个队列⾥，我们把这种队列称之为半连接队列。 </p>
<p>全连接队列（Accept队列）</p>
<p>⽤于存放已经完成三次握⼿，处于完全建⽴连接状态的连接。</p>
<h2 id="13、什么是SYN攻击"><a href="#13、什么是SYN攻击" class="headerlink" title="13、什么是SYN攻击"></a>13、什么是SYN攻击</h2><p>在 SYN 攻击中，攻击者发送⼤量伪造的 SYN 请求到⽬标服务器，但不完成后续的握⼿过程，从⽽让服务器⼀直等待确认，消耗服务器的资源（如半连接队列和系统资源），当半连接队列满了之后，后续再收到SYN报⽂就会丢 弃，导致⽆法与客户端之间建⽴连接。</p>
<h2 id="14、为什么TCP断开连接需要四次挥手"><a href="#14、为什么TCP断开连接需要四次挥手" class="headerlink" title="14、为什么TCP断开连接需要四次挥手?"></a>14、为什么TCP断开连接需要四次挥手?</h2><p>关闭连接时，客户端发送FIN报⽂，表示其不再发送数据，<strong>但还可以接收数据。</strong></p>
<p>服务端收到FIN报⽂，可以直接发送<strong>SYN+ACK</strong>报⽂。其中ACK报⽂是⽤来应答的，SYN报⽂是⽤来同步的。但是关闭连接时，服务端可能还要数据需要处理和发送，所以先回⼀个ACK应答报⽂，表示我知道客户端要关闭连接了。等到服务端不再发送数据时，才发送 FIN报⽂给客户端表示同意关闭连接。 </p>
<p>从上⾯过程可知：<strong>服务端通常需要等待完成数据的发送和处理，所以服务端的ACK和FIN⼀般都会分开发送</strong>，从⽽⽐三次握⼿导致多了⼀次。</p>
<h2 id="15、为什么需要-TIME-WAIT-状态"><a href="#15、为什么需要-TIME-WAIT-状态" class="headerlink" title="15、为什么需要 TIME_WAIT 状态"></a>15、为什么需要 TIME_WAIT 状态</h2><p>主动发起关闭连接的⼀⽅，才会有 TIME-WAIT 状态。 </p>
<p>需要 TIME-WAIT 状态，主要是两个原因：</p>
<ol>
<li><p>防⽌历史连接中的数据，被后⾯相同四元组的连接错误的接收； 如果⽹络出现拥塞或延迟，数据包可能会在⽹络中滞留⼀段时间，甚⾄超过了原始连接关闭的时间。如果没有 TIME_WAIT 状态，客户端直接进⼊到CLOSE状态，这些滞留的数据包可能会被传递给新连接，导致新连接的数据 被旧连接的数据⼲扰。 经过 2MSL 这个时间，⾜以让两个⽅向上的数据包都被丢弃，使得原来连接的数据包在⽹络中都⾃然消失，再出现 的数据包⼀定都是新建⽴连接所产⽣的。</p>
</li>
<li><p>保证「被动关闭连接」的⼀⽅能被正确的关闭，即保证最后的 ACK 能让被动关闭⽅接收，从⽽帮助其正常关 闭  如果最后的⼀次ACK报⽂丢失（第四次挥⼿），客户端没有 TIME_WAIT 状态，直接进⼊ClOSE，服务端⼀直在等待 ACK状态，⼀直没有等到，就会重发FIN报⽂，⽽客户端已经进⼊到关闭状态，在收到服务端重传的 FIN 报⽂后， 就会回 RST 报⽂,服务端收到这个 RST 并将其解释为⼀个错误, 为了防⽌这种情况出现，客户端必须等待⾜够⻓的时间，确保服务端能够收到 ACK，如果服务端没有收到 ACK，那么就会触发 TCP 重传机制，服务端会重新发送⼀个 FIN，这样⼀去⼀来刚好两个 MSL 的时间。 </p>
<p>如果 TIME-WAIT 等待⾜够⻓的情况就会遇到两种情况：</p>
<ol>
<li>服务端正常收到四次挥⼿的最后⼀个 ACK 报⽂，则服务端正常关闭连接。</li>
<li>服务端没有收到四次挥⼿的最后⼀个 ACK 报⽂时，则会重发 FIN 关闭连接报⽂并等待新的 ACK 报⽂</li>
</ol>
</li>
</ol>
<h2 id="16、为什么-TIME-WAIT-等待的时间是-2MSL"><a href="#16、为什么-TIME-WAIT-等待的时间是-2MSL" class="headerlink" title="16、为什么 TIME_WAIT 等待的时间是 2MSL"></a>16、为什么 TIME_WAIT 等待的时间是 2MSL</h2><ol>
<li>MSL是 Maximum Segment Lifetime ，<strong>报⽂最⼤⽣存时间</strong>，它是任何报⽂在⽹络上存在的最⻓时间，超过这 个时间报⽂将被丢弃。 </li>
<li>等待MSL两倍：⽹络中可能存在发送⽅的数据包，当这些发送⽅的数据包被接收⽅处理后⼜会向对⽅发送响应，所以⼀来⼀回需要等待 2 倍的时间。</li>
<li>1 个 MSL 确保四次挥⼿中主动关闭⽅最后的 ACK 报⽂最终能达到对端；1 个 MSL 确保对端没有收到 ACK 重传的 FIN 报⽂可以到达。 </li>
<li>2MSL 的时间是从客户端接收到 FIN 后发送 ACK 开始计时的。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端⼜接收到了服务端重发的 FIN 报⽂，那么 2MSL 时间将重新计时。</li>
</ol>
<h2 id="17、TCP的流量控制机制"><a href="#17、TCP的流量控制机制" class="headerlink" title="17、TCP的流量控制机制"></a>17、TCP的流量控制机制</h2><p>TCP 流量控制的基本原理是使⽤滑动窗⼝机制，其中接收⽅可以通过调整窗⼝⼤⼩来告诉发送⽅其当前处理数据的能⼒。 </p>
<p>1、接收窗⼝：接收⽅维护⼀个接收窗⼝，表示可以接收的数据段的范围。窗⼝⼤⼩可以根据接收⽅的处理能⼒进⾏调整。 </p>
<p>2、通告窗⼝⼤⼩：接收⽅通过 TCP 报⽂中的确认信息，通告当前的接收窗⼝⼤⼩给发送⽅。发送⽅会根据这个窗⼝⼤⼩来控制发送数据的速率。 </p>
<p>3、窗⼝滑动：随着接收⽅处理数据的能⼒，窗⼝可以向前滑动。接收⽅可以通告更⼤的窗⼝，表示它可以接收更 多的数据。 </p>
<p>4、发送速率控制：发送⽅会根据接收⽅通告的窗⼝⼤⼩来控制发送数据的速率。如果接收窗⼝变⼩，表示接收⽅的处理能⼒减弱，发送⽅会减慢发送速率，避免数据拥塞。 </p>
<p>5、动态调整：TCP 流量控制是动态的，适应⽹络和接收⽅的变化。如果⽹络拥塞或接收⽅的处理速度变慢，流量控制可以适时地减少发送速率。</p>
<h2 id="18、TCP的拥塞控制机制"><a href="#18、TCP的拥塞控制机制" class="headerlink" title="18、TCP的拥塞控制机制"></a>18、TCP的拥塞控制机制</h2><p>在⽹络出现拥堵时，如果继续发送⼤量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是⼀ 重传就会导致⽹络的负担更重，于是会导致更⼤的延迟以及更多的丢包，这个情况就会进⼊恶性循环被不断地放 ⼤…., 于是，就有了拥塞控制，拥塞控制的⽬的就是避免「发送⽅」的数据填满整个⽹络。 </p>
<p>拥塞控制通过拥塞窗⼝来防⽌过多的数据注⼊⽹络，使得⽹络中的路由器或者链路过载。 拥塞窗⼝ cwnd 是发送⽅维护的⼀个状态变量，根据⽹络拥塞程度⽽变化。 发送窗⼝的值是 swnd &#x3D; min(cwnd, rwnd) ，也就是拥塞窗⼝和接收窗⼝中的最⼩值。 ⽹络中没有出现拥塞，cwnd增⼤，出现拥塞，cwnd减⼩。 </p>
<p>其实只要发送⽅没有在规定时间内接收到 ACK 应答报⽂，也就是发⽣了超时重传，就会认为⽹络出现了拥塞。</p>
<p>拥塞控制的常⻅算法： 1. 慢启动 2. 拥塞避免 3. 拥塞发⽣ 4. 快速恢复 参考问题4。</p>
<h2 id="IP相关"><a href="#IP相关" class="headerlink" title="IP相关"></a>IP相关</h2><h2 id="19、网络层（IP）与数据链路层（MAC）有什么关系？"><a href="#19、网络层（IP）与数据链路层（MAC）有什么关系？" class="headerlink" title="19、网络层（IP）与数据链路层（MAC）有什么关系？"></a>19、网络层（IP）与数据链路层（MAC）有什么关系？</h2><p>1、MAC的作⽤： 实现【直连】的两个设备之间通信。</p>
<p>2、 IP的作⽤： 负责在【没有直连】的两个⽹络之间进⾏通信传输。</p>
<p>在⽹络数据包传输中，源IP地址和⽬标IP地址在传输过程中是不会变的，只有源MAC地址和⽬标MAC⼀直在变化。</p>
<h2 id="20、ARP与RARP协议"><a href="#20、ARP与RARP协议" class="headerlink" title="20、ARP与RARP协议"></a>20、ARP与RARP协议</h2><p>（1）ARP协议 在传输⼀个 IP 数据报的时候，确定了源 IP 地址和⽬标 IP 地址后，就会通过主机「路由表」确定 IP 数据包下⼀ 跳。然⽽，⽹络层的下⼀层是数据链路层，所以我们还要知道「下⼀跳」的 MAC 地址。 由于主机的路由表中可以找到下⼀跳的 IP 地址，所以可以通过 ARP 协议（Address Resolution Protocol，地址解 析协议），求得下⼀跳的 MAC 地址。</p>
<p>ARP是如何知道对⽅的MAC地址的呢？ARP 是借助 ARP 请求与 ARP 响应两种类型的包确定 MAC 地址的。 主机会通过⼴播发送 ARP 请求，这个包中包含了想要知道的 MAC 地址的主机 IP 地址。 当同个链路中的所有设备收到 ARP 请求时，会去拆开 ARP 请求包⾥的内容，如果 ARP 请求包中的⽬标 IP 地址与 ⾃⼰的 IP 地址⼀致，那么这个设备就将⾃⼰的 MAC 地址塞⼊ ARP 响应包返回给主机。 操作系统通常会把第⼀次通过 ARP 获取的 MAC 地址缓存起来，以便下次直接从缓存中找到对应 IP 地址的 MAC 地 址。 不过，MAC 地址的缓存是有⼀定期限的，超过这个期限，缓存的内容将被清除。</p>
<p>（2）RARP协议 </p>
<p>ARP 协议是已知 IP 地址求 MAC 地址，那 RARP 协议正好相反，它是已知 MAC 地址求 IP 地址。 例如将打印机服务器等⼩型嵌⼊式设备接⼊到⽹络时就经常会⽤得到。通常这需要架设⼀台 RARP 服务器，在这个 服务器上注册设备的 MAC 地址及其 IP 地址。然后再将这个设备接⼊到⽹络</p>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="1、进程和线程的区别"><a href="#1、进程和线程的区别" class="headerlink" title="1、进程和线程的区别"></a>1、进程和线程的区别</h2><p>进程是系统进行资源分配的基本单位。<strong>进程是具有独⽴功能的程序在⼀个数据集合上运⾏的过程， 是系统进⾏资源分配和调度的⼀个独⽴单位</strong></p>
<p>线程是操作系统能够进行运算调度的最小单位。线程是进程的子任务，是进程内的执行单元。一个进程至少有一个线程，一个进程可以运行多个线程，这些线程共享一块内存。</p>
<p><strong>线程是进程当中的⼀条执⾏流程，同⼀个进程内多个线程之间可以共享代码段、数据段、打开的⽂件等资源，但每 个线程各⾃都有⼀套独⽴的寄存器和栈，这样可以确保线程的控制流是相对独⽴的</strong>。</p>
<p>资源开销：</p>
<p>进程：由于每个进程都有独立的内存空间，创建和销毁进程的开销较大。进程间切换需要保存和恢复整个进程的状态，因此上下文切换的开销较高。</p>
<p>线程：线程共享相同的内存空间，创建和销毁线程的开销较小。线程间切换只需保存和恢复少量的线程上下文，因此上下文的切换开销较小。</p>
<p>通信与同步:</p>
<p>进程：由于进程间相互隔离，进程之间的通信需要一些特殊机制，如管道、消息队列、共享内存等方式。</p>
<p>线程：由于线程共享相同的内存空间，他们之间可以直接访问共享数据，线程间通信更加方便。</p>
<p>安全性：</p>
<p>进程：由于进程间相互隔离，一个进程的崩溃不会影响其他进程的稳定性。</p>
<p>线程：由于线程共享相同的内存空间，一个线程的错误可能会影响整个进程的稳定性。</p>
<p><strong>协程是用户态的轻量级线程，线程内部调度的基本单位</strong></p>
<p><em><em>实际上，⽆论是创建进程的fork，还是创建线程的 pthread_create ，底层实现都是调⽤同⼀个内核函数 clone 。 1. 如果复制对⽅的地址空间，那么就产出⼀个“进程”; 2. 如果共享对⽅的地址空间，就产⽣⼀个“线程”。 Linux内核是不区分进程和线程的, 只在⽤户层⾯上进⾏区分。所以，线程所有操作函数 pthread_</em> 是库函数，⽽ ⾮系统调⽤。</em>*</p>
<h2 id="2、进程的调度算法你了解多少？"><a href="#2、进程的调度算法你了解多少？" class="headerlink" title="2、进程的调度算法你了解多少？"></a>2、进程的调度算法你了解多少？</h2><p>进程都希望自己能够占用 CPU 进行工作，那么这涉及到前面说过的进程上下文切换。</p>
<p>一旦操作系统把进程切换到运行状态，也就意味着该进程占用着 CPU 在执行，但是当操作系统把进程切换到其他状态时，那就不能在 CPU 中执行了，于是操作系统会选择下一个要运行的进程，选择一个进程运行这一功能是在操作系统中完成的，通常称为<strong>调度程序</strong></p>
<p>01、先来先服务调度算法（FCFS）</p>
<p>顾名思义，先来后到，<strong>每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。</strong></p>
<p>这似乎很公平，但是当一个长作业先运行了，那么后面的短作业等待的时间就会很长，<strong>不利于短作业</strong>。</p>
<p>FCFS <strong>对长作业有利</strong>，适用于 CPU 繁忙型作业的系统，而不适用于 I&#x2F;O 繁忙型作业的系统。</p>
<p>02、最短作业优先调度算法</p>
<p><strong>最短作业优先（*Shortest Job First, SJF*）调度算法</strong>同样也是顾名思义，它会<strong>优先选择运行时间最短的进程来运行</strong>，这有助于提高系统的吞吐量。</p>
<p>这显然对长作业不利，很容易造成一种极端现象。比如，一个长作业在就绪队列等待运行，而这个就绪队列有非常多的短作业，那么就会使得长作业不断的往后推，周转时间变长，<strong>致使长作业长期不会被运行</strong>。</p>
<p>03、高响应比优先调度算法</p>
<p>前面两种没有权衡长短作业的利弊，那么，<strong>高响应比优先 （*Highest Response Ratio Next, HRRN*）调度算法</strong>主要是权衡了短作业和长作业。<strong>每次进行进程调度时，先计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行</strong>。</p>
<p>优先权 &#x3D; （等待时间+要求服务时间）&#x2F;要求服务时间</p>
<ul>
<li>如果两个进程的「等待时间」相同时，「要求的服务时间」越短，「响应比」就越高，这样短作业的进程容易被选中运行；</li>
<li>如果两个进程「要求的服务时间」相同时，「等待时间」越长，「响应比」就越高，这就兼顾到了长作业进程，因为进程的响应比可以随时间等待的增加而提高，当其等待时间足够长时，其响应比便可以升到很高，从而获得运行的机会</li>
</ul>
<p><strong>一个进程的要求服务时间是不可预估的，所以高响应比优先调度算法是理想算法，现实中实现不了</strong>。</p>
<p>04、时间片轮转调度算法</p>
<p>最古老、最简单、最公平且使用最广的算法就是<strong>时间片轮转（*Round Robin, RR*）调度算法</strong>。</p>
<p><strong>每个进程被分配一个时间段，称为时间片（*Quantum*），即允许该进程在该时间段中运行。</strong></p>
<ul>
<li>如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配给另外一个进程；</li>
<li>如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换；</li>
</ul>
<p>另外，时间片的长度就是一个很关键的点：</p>
<ul>
<li>如果时间片设得太短会导致过多的进程上下文切换，降低了 CPU 效率；</li>
<li>如果设得太长又可能引起对短作业进程的响应时间变长。</li>
</ul>
<p>一般来说，时间片设为 <code>20ms~50ms</code> 通常是一个比较合理的折中值。</p>
<p>05、最高优先级调度算法</p>
<p>前面的「时间片轮转算法」做了个假设，即让所有的进程同等重要，也不偏袒谁，大家的运行时间都一样。</p>
<p>但是，对于多用户计算机系统就有不同的看法了，它们希望调度是有优先级的，即希望调度程序能<strong>从就绪队列中选择最高优先级的进程进行运行，这称为最高优先级（*Highest Priority First，HPF*）调度算法</strong>。</p>
<p>进程的优先级可以分为，静态优先级和动态优先级：</p>
<ul>
<li>静态优先级：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化；</li>
<li>动态优先级：根据进程的动态变化调整优先级，比如如果进程运行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升高其优先级，也就是<strong>随着时间的推移增加等待进程的优先级</strong>。</li>
</ul>
<p>该算法也有两种处理优先级高的方法，非抢占式和抢占式：</p>
<ul>
<li>非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程。</li>
<li>抢占式：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。</li>
</ul>
<p><strong>但是依然有缺点，可能会导致低优先级的进程永远不会运行。</strong></p>
<p>06、多级反馈队列调度算法</p>
<p><strong>多级反馈队列（*Multilevel Feedback Queue*）调度算法</strong>是「时间片轮转算法」和「最高优先级算法」的综合和发展。</p>
<p>顾名思义：</p>
<ul>
<li><p>「多级」表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短。</p>
</li>
<li><p>「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列；</p>
</li>
<li><p>设置了多个队列，赋予每个队列不同的优先级，每个<strong>队列优先级从高到低</strong>，同时<strong>优先级越高时间片越短</strong>；</p>
</li>
<li><p>新的进程会被放入到第一级队列的末尾，按先来先服务的原则排队等待被调度，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成；</p>
</li>
<li><p>当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行；</p>
</li>
</ul>
<p>可以发现，对于短作业可能可以在第一级队列很快被处理完。对于长作业，如果在第一级队列处理不完，可以移入下次队列等待被执行，虽然等待的时间变长了，但是运行时间也变更长了，所以该算法很好的<strong>兼顾了长短作业，同时有较好的响应时间。</strong></p>
<h2 id="3、进程间有哪些通信方式"><a href="#3、进程间有哪些通信方式" class="headerlink" title="3、进程间有哪些通信方式?"></a>3、进程间有哪些通信方式?</h2><p>每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以进程之间要通信必须通过内核。</p>
<p>1、管道（匿名管道</p>
<p>半双工的通信方式，数据只能单向流动而且只能在具有父子进程关系的进程间使用。使用 <code>fork</code> 创建子进程，<strong>创建的子进程会复制父进程的文件描述符</strong>，这样就做到了两个进程各有两个「 <code>fd[0]</code> 与 <code>fd[1]</code>」，两个进程就可以通过各自的 fd 写入和读取同一个管道文件实现跨进程通信了。</p>
<p>2、命名管道</p>
<p>也叫做FIFO，也是半双工通信方式，但是允许无亲缘关系的进程之间的提通信。</p>
<p><strong>管道这种通信方式效率低，不适合进程间频繁地交换数据</strong>。当然，它的好处，自然就是简单，同时也我们很容易得知管道里的数据已经被另一个进程读取了。</p>
<p>不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循<strong>先进先出</strong>原则，不支持 lseek 之类的文件定位操作</p>
<p>3、消息队列</p>
<p>前面说到管道的通信方式是效率低的，因此管道不适合进程间频繁地交换数据。</p>
<p>对于这个问题，<strong>消息队列</strong>的通信模式就可以解决。比如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。同理，B 进程要给 A 进程发送消息也是如此。</p>
<p>再来，<strong>消息队列是保存在内核中的消息链表</strong>，在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。</p>
<p>消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在，而前面提到的匿名管道的生命周期，是随进程的创建而建立，随进程的结束而销毁。</p>
<p>消息这种模型，两个进程之间的通信就像平时发邮件一样，你来一封，我回一封，可以频繁沟通了。</p>
<p>但邮件的通信方式存在不足的地方有两点，<strong>一是通信不及时，二是附件也有大小限制</strong>，这同样也是消息队列通信不足的点。</p>
<p><strong>消息队列不适合比较大数据的传输</strong>，因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限。在 Linux 内核中，会有两个宏定义 <code>MSGMAX</code> 和 <code>MSGMNB</code>，它们以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度。</p>
<p><strong>消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销</strong>，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。</p>
<p>4、共享内存</p>
<p>消息队列的读取和写入的过程，都会有发生用户态与内核态之间的消息拷贝过程。那<strong>共享内存</strong>的方式，就很好的解决了这一问题。</p>
<p>现代操作系统，对于内存管理，采用的是虚拟内存技术，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程 A 和 进程 B 的虚拟地址是一样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。</p>
<p><strong>共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中</strong>。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。</p>
<p>5、信号量</p>
<p>用了共享内存通信方式，带来新的问题，那就是如果多个进程同时修改同一个共享内存，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。</p>
<p>为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，<strong>信号量</strong>就实现了这一保护机制。</p>
<p><strong>信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据</strong>。</p>
<p>信号量表示资源的数量，控制信号量的方式有两种原子操作：</p>
<ul>
<li>一个是 <strong>P 操作</strong>，这个操作会把信号量减去 1，相减后如果信号量 &lt; 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 &gt;&#x3D; 0，则表明还有资源可使用，进程可正常继续执行。</li>
<li>另一个是 <strong>V 操作</strong>，这个操作会把信号量加上 1，相加后如果信号量 &lt;&#x3D; 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程；</li>
</ul>
<p>P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。</p>
<p>信号初始化为 <code>1</code>，就代表着是<strong>互斥信号量</strong>，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。</p>
<p>我们可以初始化信号量为 <code>0</code>，就可以用信号量来实现多进程同步的方式，它可以保证进程 A 应在进程 B 之前执行。</p>
<p>6、信号</p>
<p>上面说的进程间通信，都是常规状态下的工作模式。<strong>对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。</strong></p>
<p>信号跟信号量虽然名字相似度 66.66%，但两者用途完全不一样，就好像 Java 和 JavaScript 的区别。</p>
<p>在 Linux 操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义。我们可以通过 <code>kill -l</code> 命令，查看所有的信号：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">kill</span> -l</span><br> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP<br> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1<br>11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM<br>16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP<br>21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ<br>26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR<br>31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3<br>38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8<br>43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13<br>48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12<br>53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7<br>58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2<br>63) SIGRTMAX-1  64) SIGRTMAX<br></code></pre></td></tr></table></figure>

<p>运行在 shell 终端的进程，我们可以通过键盘输入某些组合键的时候，给进程发送信号。例如</p>
<ul>
<li>Ctrl+C 产生 <code>SIGINT</code> 信号，表示终止该进程；</li>
<li>Ctrl+Z 产生 <code>SIGTSTP</code> 信号，表示停止该进程，但还未结束；</li>
</ul>
<p>如果进程在后台运行，可以通过 <code>kill</code> 命令的方式给进程发送信号，但前提需要知道运行中的进程 PID 号，例如：</p>
<ul>
<li>kill -9 1050 ，表示给 PID 为 1050 的进程发送 <code>SIGKILL</code> 信号，用来立即结束该进程；</li>
</ul>
<p>所以，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令）。</p>
<p>信号是进程间通信机制中<strong>唯一的异步通信机制</strong>，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。</p>
<p><strong>1.执行默认操作</strong>。Linux 对每种信号都规定了默认操作，例如，上面列表中的 SIGTERM 信号，就是终止进程的意思。</p>
<p><strong>2.捕捉信号</strong>。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。</p>
<p><strong>3.忽略信号</strong>。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 <code>SIGKILL</code> 和 <code>SEGSTOP</code>，它们用于在任何时候中断或结束某一进程。</p>
<p>7、socket套接字</p>
<p>前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想<strong>跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。</strong></p>
<p>实际上，Socket 通信不仅可以跨网络与不同主机的进程间通信，还可以在同主机上进程间通信。</p>
<p>我们来看看创建 socket 的系统调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">socket</span><span class="hljs-params">(<span class="hljs-type">int</span> domain, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span> protocal)</span><br></code></pre></td></tr></table></figure>

<p>三个参数分别代表：</p>
<ul>
<li>domain 参数用来指定协议族，比如 AF_INET 用于 IPV4、AF_INET6 用于 IPV6、AF_LOCAL&#x2F;AF_UNIX 用于本机；</li>
<li>type 参数用来指定通信特性，比如 SOCK_STREAM 表示的是字节流，对应 TCP、SOCK_DGRAM 表示的是数据报，对应 UDP、SOCK_RAW 表示的是原始套接字；</li>
<li>protocal 参数原本是用来指定通信协议的，但现在基本废弃。因为协议已经通过前面两个参数指定完成，protocol 目前一般写成 0 即可；</li>
</ul>
<p>根据创建 socket 类型的不同，通信的方式也就不同：</p>
<ul>
<li>实现 TCP 字节流通信： socket 类型是 AF_INET 和 SOCK_STREAM；</li>
<li>实现 UDP 数据报通信：socket 类型是 AF_INET 和 SOCK_DGRAM；</li>
<li>实现本地进程间通信： 「本地字节流 socket 」类型是 AF_LOCAL 和 SOCK_STREAM，「本地数据报 socket 」类型是 AF_LOCAL 和 SOCK_DGRAM。另外，AF_UNIX 和 AF_LOCAL 是等价的，所以 AF_UNIX 也属于本地 socket；</li>
</ul>
<p>总结</p>
<p>由于每个进程的用户空间都是独立的，不能相互访问，这时就需要借助内核空间来实现进程间通信，原因很简单，每个进程都是共享一个内核空间。</p>
<p>Linux 内核提供了不少进程间通信的方式，其中最简单的方式就是管道，管道分为「匿名管道」和「命名管道」。</p>
<p><strong>匿名管道</strong>顾名思义，它没有名字标识，匿名管道是特殊文件只存在于内存，没有存在于文件系统中，shell 命令中的「<code>|</code>」竖线就是匿名管道，通信的数据是<strong>无格式的流并且大小受限</strong>，通信的方式是<strong>单向</strong>的，数据只能在一个方向上流动，如果要双向通信，需要创建两个管道，再来<strong>匿名管道是只能用于存在父子关系的进程间通信</strong>，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失。</p>
<p><strong>命名管道</strong>突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用命名管道的前提，需要在文件系统创建一个类型为 p 的设备文件，那么毫无关系的进程就可以通过这个设备文件进行通信。另外，不管是匿名管道还是命名管道，进程写入的数据都是<strong>缓存在内核</strong>中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循<strong>先进先出</strong>原则，不支持 lseek 之类的文件定位操作。</p>
<p><strong>消息队列</strong>克服了管道通信的数据是无格式的字节流的问题，消息队列实际上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数据类型，发送数据时，会被分成一个一个独立的消息体，当然接收数据时，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的数据是正确的。消息队列通信的速度不是最及时的，毕竟<strong>每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程。</strong></p>
<p><strong>共享内存</strong>可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，<strong>它直接分配一个共享空间，每个进程都可以直接访问</strong>，就像访问进程自己的空间一样快捷方便，不需要陷入内核态或者系统调用，大大提高了通信的速度，享有<strong>最快</strong>的进程间通信方式之名。但是便捷高效的共享内存通信，<strong>带来新的问题，多进程竞争同个共享资源会造成数据的错乱。</strong></p>
<p>那么，就需要<strong>信号量</strong>来保护共享资源，以确保任何时刻只能有一个进程访问共享资源，这种方式就是互斥访问。<strong>信号量不仅可以实现访问的互斥性，还可以实现进程间的同步</strong>，信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 <strong>P 操作和 V 操作</strong>。</p>
<p>与信号量名字很相似的叫<strong>信号</strong>，它俩名字虽然相似，但功能一点儿都不一样。信号是<strong>异步通信机制</strong>，信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令），一旦有信号发生，<strong>进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、3. 忽略信号</strong>。有两个信号是应用进程无法捕捉和忽略的，即 <code>SIGKILL</code> 和 <code>SIGSTOP</code>，这是为了方便我们能在任何时候结束或停止某个进程。</p>
<p>前面说到的通信机制，都是工作于同一台主机，如果<strong>要与不同主机的进程间通信，那么就需要 Socket 通信了</strong>。Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。</p>
<p>以上，就是进程间通信的主要机制了。你可能会问了，那线程通信间的方式呢？</p>
<p>同个进程下的线程之间都是共享进程的资源，只要是共享变量都可以做到线程间通信，比如全局变量，所以对于线程间关注的不是通信方式，而是关注多线程竞争共享资源的问题，信号量也同样可以在线程间实现互斥与同步：</p>
<ul>
<li>互斥的方式，可保证任意时刻只有一个线程访问共享资源；</li>
<li>同步的方式，可保证线程 A 应在线程 B 之前执行；</li>
</ul>
<h2 id="4、什么是死锁以及如何避免死锁？"><a href="#4、什么是死锁以及如何避免死锁？" class="headerlink" title="4、什么是死锁以及如何避免死锁？"></a>4、什么是死锁以及如何避免死锁？</h2><p><strong>死锁是指两个或多个线程在争夺系统资源时，由于相互等待对方释放资源而无法继续执行的状态。</strong></p>
<p>在多线程编程中，我们为了防止多线程竞争共享资源而导致数据错乱，都会在操作共享资源之前加上互斥锁，只有成功获得到锁的线程，才能操作共享资源，获取不到锁的线程就只能等待，直到锁被释放。</p>
<p>那么，当两个线程为了保护两个不同的共享资源而使用了两个互斥锁，那么这两个互斥锁应用不当的时候，可能会造成<strong>两个线程都在等待对方释放锁</strong>，在没有外力的作用下，这些线程会一直相互等待，就没办法继续运行，这种情况就是发生了<strong>死锁</strong></p>
<p>死锁只有<strong>同时满足</strong>以下四个条件才会发生：</p>
<ul>
<li>互斥条件：多个线程不能同时使用同一个资源</li>
<li>持有并等待条件：一个线程因为请求另外的资源被阻塞的时候，不会释放自己目前持有的资源。</li>
<li>不可剥夺条件：资源不能被强制性的从一个进程中夺走，只能由持有者资源释放释放。</li>
<li>环路等待条件：多个进程之间形成一个环形等待资源的链路，每个进程都在等待下一个进程释放自己所占有的资源</li>
</ul>
<p>只要破坏上面任意一个条件就可以破坏死锁。</p>
<p>破坏请求与保持条件：一次性申请所有的资源</p>
<p>破坏不可剥夺条件：占用资源的线程在申请其他资源被堵塞时，可以主动释放他已经占有的资源。</p>
<p>破坏循环等待条件：使用资源有序分配法，让所有进程按照相同的顺序请求资源，释放资源则反序释放。</p>
<p>总结：</p>
<p>简单来说，死锁问题的产生是由两个或者以上线程并行执行的时候，争夺资源而互相等待造成的。</p>
<p>死锁只有同时满足互斥、持有并等待、不可剥夺、环路等待这四个条件的时候才会发生。</p>
<p>所以要避免死锁问题，就是要破坏其中一个条件即可，<strong>最常用的方法就是使用资源有序分配法来破坏环路等待条件</strong></p>
<h2 id="5、什么是虚拟内存，为什么需要虚拟内存？"><a href="#5、什么是虚拟内存，为什么需要虚拟内存？" class="headerlink" title="5、什么是虚拟内存，为什么需要虚拟内存？"></a><strong>5、什么是虚拟内存，为什么需要虚拟内存？</strong></h2><p>虚拟内存在每一个进程创建加载的过程中，会分配一个连续的虚拟地址空间，他不是真实存在的，而是通过映射与实际地址空间对应，这样就可以是每个进程看起来都有自己独立的连续地址空间，并允许程序访问比物理内存更大的地址空间，每个程序都可以认为它拥有足够大的内存来运行。</p>
<p>需要虚拟内存有以下原因：</p>
<p>内存扩展：虚拟内存使得每个程序可以使用比实际可用内存更大的内存，从而允许运行更大的程序或处理更多的数据。</p>
<p>内存隔离：虚拟内存还提供了进程之间的内存隔离，每个进程都有自己的虚拟地址空间，因此一个进程无法直接访问另一个进程的内存。</p>
<p>物理内存管理：虚拟内存允许操作系统动态的将数据和程序的部分加载到物理内存中，以满足当前正在运行的进程的需求。当物理内存不足时，操作系统可以将不常用的数据或程序暂时移到硬盘上，从而释放内存，以便其他进程使用。</p>
<p>页面交换：当物理内存不足时，操作系统可以将一部分数据从物理内存写入到硬盘的虚拟内存中，这个过程被称为页面交换，当需要时，数据可以再次从虚拟内存中加载到物理内存中。这样可以保证系统可以继续运行，尽管物理内存有限。</p>
<p>内存映射文件：虚拟内存还可以用于将文件映射到内存中，这使得文件的读取和写入可以像访问内存一样高效。</p>
<h2 id="6、什么是内存分段和内存分页，作用是什么？"><a href="#6、什么是内存分段和内存分页，作用是什么？" class="headerlink" title="6、什么是内存分段和内存分页，作用是什么？"></a>6、什么是内存分段和内存分页，作用是什么？</h2><p><strong>核心功能是管理虚拟地址与物理地址的之间的映射关系</strong>。</p>
<p><strong>内存分段</strong>：将一个程序的内存空间分为不同的逻辑段（segments），每个段代表程序的一个功能模块或者数据类型，比如代码段、数据段、堆栈段等。每个段都有其自己的大小和权限。</p>
<p><strong>内存分页</strong>：把整个虚拟和物理空间分成固定大小的页（4KB），这样一个连续且大小固定的内存空间，称之为页。</p>
<p>作用：</p>
<p>1、<strong>逻辑隔离</strong>：内存分段和分页都实现了程序的逻辑隔离，使不同的功能模块或数据类型能够被单独的管理和保护，提高了程序的可靠性与安全性。</p>
<p>2、<strong>内存保护</strong>：通过将不同的段或页面设置为只读、可读写、不可执行等权限，操作系统可以确保程序不会越界访问或修改其他段的内容，从而提高了系统的稳定性。</p>
<p>3、<strong>虚拟内存</strong>：分段和分页都是为了实现虚拟内存的概念，允许应用程序认为他们使用的是一个比实际物理内存更大的内存空间。</p>
<p>4、<strong>内存共享</strong>：通过分页，操作系统可以实现内存页面的共享，从而节省内存空间，多个进程可以共享相同的代码段或数据页面。</p>
<p>5、<strong>内存管理</strong>：分页更加灵活，允许操作系统将不同进程的页面分散存放在物理内存中，从而提高内存利用率。分段则更适用于管理不同的逻辑模块。</p>
<p>分段和分页的区别：</p>
<p>分页对用户不可见，分段对用户可见。</p>
<p>分页的地址空间是一维的，分段的地址空间是二维的。</p>
<p>分页（单级页表）以及分段访问一个逻辑地址都需要两次访存，分段存储中可以引入快表机制</p>
<p>分段更容易实现信息的共享和保护</p>
<p>分段与分页的优缺点：</p>
<p>分页：内存空间利用率高，不会产生外部碎片，只会有少量的页内碎片，但不方便按照逻辑模块实现信息的共享与保护。</p>
<p>分段：方便按照逻辑模块实现信息的共享与保护，但是如果段长过大，为其分配很大的连续空间很不方便，且会产生外部碎片。</p>
<p><strong>7、解释一下用户态和内核态</strong></p>
<p><strong>用户态和内核态是操作系统中两种不同的执行模式，用于控制进程或程序对计算机硬件资源的访问权限和操作范围。</strong></p>
<p>用户态：在用户态下，进程或程序只能访问受限的资源和执行受限的指令集，不能直接访问操作系统的核心部分，也不能直接访问硬件资源，用户态下的CPU不能独占，允许被其他程序获取。</p>
<p>内核态：内核态是操作系统的特权级别，允许进程或程序执行特权指令和访问操作系统的核心部分。在内核态下，进程可以直接访问硬件资源，执行系统调用，管理内存、文件系统等操作。处于内核态的CPU可以从一个程序切换到另一个程序，并且占用CPU不会发生被抢占的情况。</p>
<p>用户空间的代码只能访问一个局部的内存空间，而内核空间的代码可以访问所有内存空间。因此，当程序使用用户空间时，我们常说该程序在<strong>用户态</strong>执行，而当程序使内核空间时，程序则在<strong>内核态</strong>执行。<strong>应用程序如果需要进入内核空间，就需要通过系统调用</strong>，内核程序执行在内核态，用户程序执行在用户态。<strong>当应用程序使用系统调用时，会产生一个中断</strong>。发生中断后， CPU 会中断当前在执行的用户程序，转而跳转到中断处理程序，也就是开始执行内核程序。内核处理完后，主动触发中断，把 CPU 执行权限交回给用户程序，回到用户态继续工作。</p>
<p>8、解释一下页面置换算法，例如LRU，FIFO等</p>
<p>在了解内存页面置换算法前，我们得先谈一下<strong>缺页异常（缺页中断）</strong>。</p>
<p>当 CPU 访问的页面不在物理内存时，便会产生一个缺页中断，请求操作系统将所缺页调入到物理内存。那它与一般中断的主要区别在于：</p>
<ul>
<li>缺页中断在指令执行「期间」产生和处理中断信号，而一般中断在一条指令执行「完成」后检查和处理中断信号。</li>
<li>缺页中断返回到该指令的开始重新执行「该指令」，而一般中断返回回到该指令的「下一个指令」执行。</li>
</ul>
<p><strong>缺页中断的处理流程</strong>：</p>
<ol>
<li>在 CPU 里访问一条 Load M 指令，然后 CPU 会去找 M 所对应的页表项。</li>
<li>如果该页表项的状态位是「有效的」，那 CPU 就可以直接去访问物理内存了，如果状态位是「无效的」，则 CPU 则会发送缺页中断请求。</li>
<li>操作系统收到了缺页中断，则会执行缺页中断处理函数，先会查找该页面在磁盘中的页面的位置。</li>
<li>找到磁盘中对应的页面后，需要把该页面换入到物理内存中，但是在换入前，需要在物理内存中找空闲页，如果找到空闲页，就把页面换入到物理内存中。</li>
<li>页面从磁盘换入到物理内存完成后，则把页表项中的状态位修改为「有效的」。</li>
<li>最后，CPU 重新执行导致缺页异常的指令。</li>
</ol>
<p>上面所说的过程，第 4 步是能在物理内存找到空闲页的情况，那如果找不到呢？</p>
<p>找不到空闲页的话，就说明此时内存已满了，这时候，就需要「页面置换算法」选择一个物理页，如果该物理页有被修改过（脏页），则把它换出到磁盘，然后把该被置换出去的页表项的状态改成「无效的」，最后把正在访问的页面装入到这个物理页中。如果没有修改，在置换该页时就不需要将该页写回到磁盘上，以减少系统的开销。</p>
<p>所以，页面置换算法的功能是，<strong>当出现缺页异常，需调入新页面而内存已满时，选择被置换的物理页面</strong>，也就是说选择一个物理页面换出到磁盘，然后把需要访问的页面换入到物理页，算法的目标是尽量减少页面的换入换出次数，减少系统的开销。</p>
<p>1、最佳置换算法</p>
<p>根据未来页面的访问情况，选择最长时间内不会被访问到的页面进行置换。那么就产生一个问题了，未来要访问什么页面操作系统如何未卜先知呢？所以该算法属于理想情况，用来衡量算法的优劣，越接近该算法的效率越高。</p>
<p>2、先进先出置换算法</p>
<p><strong>选择在内存驻留时间很长的页面进行中置换</strong>，这个就是「先进先出置换」算法的思想。但是FIFO算法可能会淘汰经常被使用的角色，导致切换次数增加。而且FIFO算法有可能出现贝拉迪异常：当分配给内存的空间增加时，切换次数反而增加了。</p>
<p>3、最近最久未使用算法（最近最少使用）</p>
<p>最近最久未使用（<em>LRU</em>）的置换算法的基本思路是，发生缺页时，<strong>选择最长时间没有被访问的页面进行置换</strong>，也就是说，该算法假设已经很久没有使用的页面很有可能在未来较长的一段时间内仍然不会被使用。</p>
<p>虽然 LRU 在理论上是可以实现的，但代价很高。为了完全实现 LRU，需要在内存中维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。困难的是，在每次访问内存时都必须要更新「整个链表」。在链表中找到一个页面，删除它，然后把它移动到表头是一个非常费时的操作。</p>
<p>所以，LRU 虽然看上去不错，但是由于开销比较大，实际应用中比较少使用。</p>
<p>4、时钟页面置换算法</p>
<p>那有没有一种即能优化置换的次数，也能方便实现的算法呢？</p>
<p><strong>时钟页面置换算法就可以两者兼得，它跟 LRU 近似，又是对 FIFO 的一种改进。</strong></p>
<p>该算法的思路是，把所有的页面都保存在一个类似钟面的「环形链表」中，一个表针指向最老的页面。</p>
<p>当发生缺页中断时，算法首先检查表针指向的页面：</p>
<ul>
<li>如果它的访问位位是 0 就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置；</li>
<li>如果访问位是 1 就清除访问位，并把表针前移一个位置，重复这个过程直到找到了一个访问位为 0 的页面为止；</li>
</ul>
<p>5、最不常用算法（LFU）</p>
<p><strong>当发生缺页中断时，选择「访问次数」最少的那个页面，并将其淘汰</strong>。</p>
<p>它的实现方式是，对每个页面设置一个「访问计数器」，每当一个页面被访问时，该页面的访问计数器就累加 1。在发生缺页中断时，淘汰计数器值最小的那个页面。</p>
<p>看起来很简单，每个页面加一个计数器就可以实现了，但是在操作系统中实现的时候，我们需要考虑效率和硬件成本的。</p>
<p>要增加一个计数器来实现，这个硬件成本是比较高的，另外如果要对这个计数器查找哪个页面访问次数最小，查找链表本身，如果链表长度很大，是非常耗时的，效率不高。</p>
<p>但还有个问题，LFU 算法只考虑了频率问题，没考虑时间的问题，比如有些页面在过去时间里访问的频率很高，但是现在已经没有访问了，而当前频繁访问的页面由于没有这些页面访问的次数高，在发生缺页中断时，就会可能会误伤当前刚开始频繁访问，但访问次数还不高的页面。</p>
<h2 id="7、解释一下进程同步和互斥，以及解决这些问题的方法？"><a href="#7、解释一下进程同步和互斥，以及解决这些问题的方法？" class="headerlink" title="7、解释一下进程同步和互斥，以及解决这些问题的方法？"></a>7、解释一下进程同步和互斥，以及解决这些问题的方法？</h2><p>互斥：在某一时刻只允许一个进程访问某个共享资源，当一个进程正在使用共享资源时，其他进程不能同时访问改共享资源。</p>
<p>进程同步：多个并发执行的进程之间协调和管理他们的执行顺序，以确保他们按照一定的顺序或时间间隔执行。</p>
<ul>
<li>同步就好比：「操作 A 应在操作 B 之前执行」，「操作 C 必须在操作 A 和操作 B 都完成之后才能执行」等；</li>
<li>互斥就好比：「操作 A 和操作 B 不能在同一时刻执行」</li>
</ul>
<p>临界区：将可能引发互斥问题的代码段称为临界区，为了实现互斥，每个进程在进入临界区前必须获取一个锁，退出临界区后释放该锁。确保同一时间只有一个进程可以进入临界区。</p>
<p>互斥锁：互斥锁是一种同步机制，用于实现互斥。每个共享资源都关联一个互斥锁，进程在访问该资源前需要获取互斥锁，使用完之后释放互斥锁，只有获得互斥锁的进程才能访问资源。</p>
<p>信号量：参考3.</p>
<p>信号初始化为 <code>1</code>，就代表着是<strong>互斥信号量</strong>，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。</p>
<p>我们可以初始化信号量为 <code>0</code>，就可以用信号量来实现多进程同步的方式，它可以保证进程 A 应在进程 B 之前执行。</p>
<h2 id="8、什么是中断和异常？二者有何区别？"><a href="#8、什么是中断和异常？二者有何区别？" class="headerlink" title="8、什么是中断和异常？二者有何区别？"></a>8、什么是中断和异常？二者有何区别？</h2><p>中断和异常是两种不同的事件，他们都会导致CPU暂停当前的程序执行，转而去执行一个特定的处理程序。</p>
<p>区别：</p>
<p><strong>中断是由外部设备或其他处理器产生的</strong>，通常是异步的，也就是说中断可以在任何时候发生。与当前执行的指令无关，比如键盘输入，鼠标移动等都会触发中断通知CPU去处理这些事件。</p>
<p><strong>异常是由CPU内部产生的</strong>，通常是同步的，也就是说只会在执行某些指令时发生，与当前执行的指令有关。比如访问非法内存地址，除数为零、执行非法指令等都会产生异常信号，通知CPU去处理这些错误或故障。</p>
<p><strong>中断可以被屏蔽或者禁止</strong>，意味着CPU可以通过设置某些标志位或寄存器来忽略或延迟响应某些中断信号。可以避免中断过于频繁或干扰重要的任务。</p>
<p><strong>异常不能被屏蔽或者禁止</strong>，意味着CPU必须立即响应异常信号，并进行相应的处理，这样可以保证程序的正确性和系统的稳定性。</p>
<p>中断的定义：CPU在执行指令时，收到某个中断信号转而去执行预先设定好的代码，然后再返回到原指令中继续执行，这就是中断机制。</p>
<p>中断的作用：</p>
<p>1、外设异步通知CPU，外设发生了什么事情或者完成了什么任务都可以通过中断异步通知CPU。</p>
<p>2、CPU之间发送消息，在SMP系统中，一个CPU想给另一个CPU发送消息，可以使用IPI（处理器间中断）。</p>
<p>3、处理CPU异常，CPU在执行指令的过程中遇到了异常会给自己发送中断信号来处理异常。</p>
<p>4、实现系统调用，早期的系统调用就是靠中断来实现的，后期虽然开发了专用的系统调用指令，但其基本原理还是相似的。</p>
<p>中断的产生：</p>
<p>1、外设（硬件中断），外设产生的中断信号时<strong>异步的</strong>，按照是否可以屏蔽分为可屏蔽中断和不可屏蔽中断。网卡、磁盘、定时器都可以产生硬件中断。</p>
<p>2、CPU，处理器间中断（IPI），可以看做一种特殊的硬件中断，<strong>异步</strong>。</p>
<p>3、CPU异常，<strong>同步的</strong>，在处理指令的过程中发现异常，会向自己发送中断信号，也叫做软件中断。CPU异常分为三类：</p>
<p>陷阱：不需要修复，中断处理完成后重新执行之前的指令。</p>
<p>故障：需要修复也有可能修复，中断处理完成后重新执行之前的指令。</p>
<p>中止：需要修复但是无法修复，中断处理完成后，进程或者内核将会崩溃。</p>
<p>4、中断指令，直接用CPU指令来产生中断信号，这种中断和CPU异常一样是<strong>同步的</strong>，也也可以叫做软件中断。</p>
<h2 id="9、介绍一下几种典型的锁"><a href="#9、介绍一下几种典型的锁" class="headerlink" title="9、介绍一下几种典型的锁"></a>9、介绍一下几种典型的锁</h2><p>加锁的目的就是保证共享资源在任意时间里，只有一个线程访问，这样就可以避免多线程导致共享数据错乱的问题。</p>
<p>两个基本的锁</p>
<p>1、互斥锁：一种最常见的锁类型，用于实现互斥访问共享资源。在任何时刻，只有一个线程可以持有互斥锁，其他线程必须等待直到锁被释放，确保了同一时间只有一个线程能够访问被保护的资源。</p>
<p>2、自旋锁：基于忙等待的锁，线程在尝试获取锁时会不断轮训，直到锁被释放。</p>
<ul>
<li><strong>互斥锁</strong>加锁失败后，线程会<strong>释放 CPU</strong> ，给其他线程；</li>
<li><strong>自旋锁</strong>加锁失败后，线程会<strong>忙等待</strong>，直到它拿到锁；</li>
</ul>
<p>其他的锁基于这两种锁</p>
<p>3、读写锁：允许多个线程同时共享资源，只允许一个线程进行写操作，读（共享）写（独占）两种状态。</p>
<p>4、悲观锁：认为多线程同时修改共享资源的概率比较高，所以访问资源时要上锁。</p>
<p>5、乐观锁：先不管，修改了共享资源再说，如果出现同时修改的情况，放弃本次操作。</p>
<p><strong>总结：</strong></p>
<p>开发过程中，最常见的就是互斥锁的了，互斥锁加锁失败时，会用「线程切换」来应对，当加锁失败的线程再次加锁成功后的这一过程，会有两次线程上下文切换的成本，性能损耗比较大。</p>
<p>如果我们明确知道被锁住的代码的执行时间很短，那我们应该选择开销比较小的自旋锁，因为自旋锁加锁失败时，并不会主动产生线程切换，而是一直忙等待，直到获取到锁，那么如果被锁住的代码执行时间很短，那这个忙等待的时间相对应也很短。</p>
<p>如果能区分读操作和写操作的场景，那读写锁就更合适了，它允许多个读线程可以同时持有读锁，提高了读的并发性。根据偏袒读方还是写方，可以分为读优先锁和写优先锁，读优先锁并发性很强，但是写线程会被饿死，而写优先锁会优先服务写线程，读线程也可能会被饿死，那为了避免饥饿的问题，于是就有了公平读写锁，它是用队列把请求锁的线程排队，并保证先入先出的原则来对线程加锁，这样便保证了某种线程不会被饿死，通用性也更好点。</p>
<p>互斥锁和自旋锁都是最基本的锁，读写锁可以根据场景来选择这两种锁其中的一个进行实现。</p>
<p>另外，互斥锁、自旋锁、读写锁都属于悲观锁，悲观锁认为并发访问共享资源时，冲突概率可能非常高，所以在访问共享资源前，都需要先加锁。</p>
<p>相反的，如果并发访问共享资源时，冲突概率非常低的话，就可以使用乐观锁，它的工作方式是，在访问共享资源时，不用先加锁，修改完共享资源后，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。</p>
<p>但是，一旦冲突概率上升，就不适合使用乐观锁了，因为它解决冲突的重试成本非常高。</p>
<p>不管使用的哪种锁，我们的加锁的代码范围应该尽可能的小，也就是加锁的粒度要小，这样执行速度会比较快。再来，使用上了合适的锁，就会快上加快了。</p>
<h2 id="10、IO多路复用"><a href="#10、IO多路复用" class="headerlink" title="10、IO多路复用"></a>10、IO多路复用</h2><p>最基础的 TCP 的 Socket 编程，它是阻塞 I&#x2F;O 模型，基本上只能一对一通信，那为了服务更多的客户端，我们需要改进网络 I&#x2F;O 模型。</p>
<p>比较传统的方式是使用多进程&#x2F;线程模型，每来一个客户端连接，就分配一个进程&#x2F;线程，然后后续的读写都在对应的进程&#x2F;线程，这种方式处理 100 个客户端没问题，但是当客户端增大到 10000 个时，10000 个进程&#x2F;线程的调度、上下文切换以及它们占用的内存，都会成为瓶颈。</p>
<p>为了解决上面这个问题，就出现了 I&#x2F;O 的多路复用，可以只在一个进程里处理多个文件的 I&#x2F;O，Linux 下有三种提供 I&#x2F;O 多路复用的 API，分别是：select、poll、epoll。</p>
<p>select 和 poll 并没有本质区别，它们内部都是使用「线性结构」来存储进程关注的 Socket 集合。</p>
<p>在使用的时候，首先需要把关注的 Socket 集合通过 select&#x2F;poll 系统调用从用户态拷贝到内核态，然后由内核检测事件，当有网络事件产生时，内核需要遍历进程关注 Socket 集合，找到对应的 Socket，并设置其状态为可读&#x2F;可写，然后把整个 Socket 集合从内核态拷贝到用户态，用户态还要继续遍历整个 Socket 集合找到可读&#x2F;可写的 Socket，然后对其处理。</p>
<p>很明显发现，select 和 poll 的缺陷在于，当客户端越多，也就是 Socket 集合越大，Socket 集合的遍历和拷贝会带来很大的开销，因此也很难应对 C10K。</p>
<p>epoll 是解决 C10K 问题的利器，通过两个方面解决了 select&#x2F;poll 的问题。</p>
<ul>
<li>epoll 在内核里使用「红黑树」来关注进程所有待检测的 Socket，红黑树是个高效的数据结构，增删改一般时间复杂度是 O(logn)，通过对这棵黑红树的管理，不需要像 select&#x2F;poll 在每次操作时都传入整个 Socket 集合，减少了内核和用户空间大量的数据拷贝和内存分配。</li>
<li>epoll 使用事件驱动的机制，内核里维护了一个「链表」来记录就绪事件，只将有事件发生的 Socket 集合传递给应用程序，不需要像 select&#x2F;poll 那样轮询扫描整个集合（包含有和无事件的 Socket ），大大提高了检测的效率。</li>
</ul>
<p>而且，epoll 支持边缘触发和水平触发的方式，而 select&#x2F;poll 只支持水平触发，一般而言，边缘触发的方式会比水平触发的效率高。</p>
<p>边缘触发：有事件到来，只提醒一次。</p>
<p>水平出发：事件到来，一直提醒，直到处理完再停止。</p>
<p>epoll 支持两种事件触发模式，分别是**边缘触发（*edge-triggered，ET*）**和**水平触发（*level-triggered，LT*）**。</p>
<p>这两个术语还挺抽象的，其实它们的区别还是很好理解的。</p>
<ul>
<li>使用边缘触发模式时，当被监控的 Socket 描述符上有可读事件发生时，<strong>服务器端只会从 epoll_wait 中苏醒一次</strong>，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证一次性将内核缓冲区的数据读取完；</li>
<li>使用水平触发模式时，当被监控的 Socket 上有可读事件发生时，<strong>服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束</strong>，目的是告诉我们有数据需要读取。</li>
</ul>
<h2 id="11、进程的上下文切换"><a href="#11、进程的上下文切换" class="headerlink" title="11、进程的上下文切换"></a>11、进程的上下文切换</h2><p>⼀个进程切换到另⼀个进程运⾏，称为进程的上下⽂切换, 进程的上下⽂切换不仅包含了虚拟内存、栈、全局变量等<strong>⽤户空间</strong>的资源，还包括了内核堆栈、寄存器等<strong>内核空间</strong>的资源。（即用户态和内核态的切换）</p>
<p>发⽣进程上下⽂切换有哪些场景？ </p>
<p>进程的时间⽚耗尽 </p>
<p>阻塞等待 </p>
<p>⾼优先级进程运⾏ </p>
<p>中断处理 </p>
<p>进程通过睡眠函数 sleep 这样的⽅法将⾃⼰主动挂起</p>
<h2 id="12、进程切换为何⽐线程慢"><a href="#12、进程切换为何⽐线程慢" class="headerlink" title="12、进程切换为何⽐线程慢"></a>12、进程切换为何⽐线程慢</h2><p>涉及到虚拟内存的问题，进程切换涉及虚拟地址空间的切换⽽线程不会。 因为每个进程都有⾃⼰的虚拟地址空间，⽽线程是共享所在进程的虚拟地址空间的，所以同⼀个进程中的线程进⾏ 线程切换时不涉及虚拟地址空间的转换。 把虚拟地址转换为物理地址需要查找⻚表，⻚表查找是⼀个很慢的过程（⾄少访问2次内存），因此通常使⽤ Cache来缓存常⽤的地址映射，这样可以加速⻚表查找，这个cache就是TLB（快表）。  由于每个进程都有⾃⼰的虚拟地址空间，那么显然每个进程都有⾃⼰的⻚表，那么当进程切换后⻚表也要进⾏切 换，⻚表切换后TLB就失效了，cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的 就是程序运⾏会变慢，⽽线程切换则不会导致TLB失效，因为线程线程⽆需切换地址空间，这也就是进程切换要⽐ 同进程下线程切换慢的原因。</p>
<h2 id="13、僵尸进程"><a href="#13、僵尸进程" class="headerlink" title="13、僵尸进程"></a>13、僵尸进程</h2><p>多进程程序，⽗进程⼀般需要跟踪⼦进程的退出状态，当⼦进程退出，⽗进程在运⾏，⼦进程必须等到⽗进程捕获到了⼦进程的退出状态才真正结束。在⼦进程结束后，⽗进程读取状态前，此时⼦进程为僵⼫进程。 设置僵⼫进程的⽬的是维护⼦进程的信息，以便⽗进程在以后某个时候获取。这些信息⾄少包括进程ID，进程的终⽌状态，以及该进程使⽤的CPU时间。所以当终⽌⼦进程的⽗进程调⽤wait或waitpid时就可以得到这些信息。</p>
<p> 但是⼦进程停⽌在僵⼫态会占据内核资源，所以需要避免僵⼫进程的产⽣或⽴即结束⼦进程的僵⼫态。 </p>
<p>1、⽗进程调⽤wait&#x2F;waitpid等函数等待⼦进程结束，如果尚⽆⼦进程退出<strong>wait会导致⽗进程阻塞</strong>。waitpid只会等待由pid参数指定的⼦进程，同时也是⾮阻塞，⽬标进程正常退出返回⼦进程PID，还没结束返回0。</p>
<p>2、 在事件已经发⽣情况下执⾏⾮阻塞调⽤可以提⾼程序效率。对waitpid，最好在⼦进程退出后调⽤。使⽤ SIGCHLD信号通知⽗进程，⼦进程结束。</p>
<h2 id="14、⻚⾯置换算法"><a href="#14、⻚⾯置换算法" class="headerlink" title="14、⻚⾯置换算法"></a>14、⻚⾯置换算法</h2><p>1、最佳⻚⾯置换算法(OPT)  </p>
<p>置换在「未来」最⻓时间不访问的⻚⾯,但是实际系统中⽆法实现，因为程序访问⻚⾯时是动态的  我们是⽆法预知每个⻚⾯在「下⼀次」访问前的等待时间，因此作为实际算法效率衡量标准。 </p>
<p>2、先进先出置换算法(FIFO) </p>
<p> 顾名思义，将⻚⾯以队列形式保存，先进⼊队列的⻚⾯先被置换进⼊磁盘。 </p>
<p>3、最近最久未使⽤的置换算法（LRU）  </p>
<p>根据⻚⾯未被访问时⻓⽤升序列表将⻚⾯排列，每次将最久未被使⽤⻚⾯置换出去。 </p>
<p>4、时钟⻚⾯置换算法  </p>
<p>把所有的⻚⾯都保存在⼀个类似钟⾯的「环形链表」中，⻚⾯包含⼀个访问位。 当发⽣缺⻚中断时，顺时针遍历⻚⾯，如果访问位为1，将其改为0，继续遍历，直到访问到访问位为0⻚⾯，进⾏置换。 </p>
<p>5、最不常⽤算法  </p>
<p>记录每个⻚⾯访问次数，当发⽣缺⻚中断时候，将访问次数最少的⻚⾯置换出去，此⽅法需要对每个⻚⾯访问次数 统计，额外开销。</p>
<h2 id="15、并⾏和并发是什么"><a href="#15、并⾏和并发是什么" class="headerlink" title="15、并⾏和并发是什么"></a>15、并⾏和并发是什么</h2><p>并⾏是在同⼀时刻执⾏多个任务。 并发是在相同的时间段内执⾏多个任务，任务可能交替执⾏，通过调度实现。 </p>
<p>并⾏是指在同⼀时刻执⾏多个任务，这些任务可以同时进⾏，每个任务都在不同的处理单元（如多个CPU核⼼）上执⾏。在并⾏系统中，多个处理单元可以同时处理独⽴的⼦任务，从⽽加速整体任务的完成。</p>
<p>并发是指在相同的时间段内执⾏多个任务，这些任务可能不是同时发⽣的，⽽是交替执⾏，通过时间⽚轮转或者事件驱动的⽅式。并发通常与任务之间的交替执⾏和任务调度有关。</p>
<h2 id="16、说一说僵尸进程和孤⼉进程"><a href="#16、说一说僵尸进程和孤⼉进程" class="headerlink" title="16、说一说僵尸进程和孤⼉进程"></a>16、说一说僵尸进程和孤⼉进程</h2><p>1、孤⼉进程：⼀个⽗进程退出，⽽它的⼀个或多个⼦进程还在运⾏，那么那些⼦进程将成为孤⼉进程。孤⼉进程 将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集⼯作。</p>
<p>2、僵⼫进程：⼀个进程使⽤fork创建⼦进程，如果⼦进程退出，⽽⽗进程并没有调⽤wait或waitpid获取⼦进程 的状态信息，那么⼦进程的进程描述符仍然保存在系统中。这种进程称之为僵⼫进程</p>
<h2 id="17、信号和信号量有什么区别"><a href="#17、信号和信号量有什么区别" class="headerlink" title="17、信号和信号量有什么区别"></a>17、信号和信号量有什么区别</h2><p>信号：⼀种处理异步事件的⽅式。信号是⽐较复杂的通信⽅式，⽤于通知接收进程有某种事件发⽣，除了⽤于进程 外，还可以发送信号给进程本身。 </p>
<p>信号量：进程间通信处理同步互斥的机制。是在多线程环境下使⽤的⼀种设施，它负责协调各个线程，以保证它们 能够正确，合理的使⽤公共资源。</p>
<h2 id="18、Linux常用命令"><a href="#18、Linux常用命令" class="headerlink" title="18、Linux常用命令"></a>18、Linux常用命令</h2><p>ls：列出当前⽬录下的⽂件和⼦⽬录。 cd：切换⽬录。 pwd：显示当前⼯作⽬录的路径。 touch：创建新⽂件。 mkdir：创建新⽬录。 rm：删除⽂件或⽬录。 cp：复制⽂件或⽬录。 mv：移动⽂件或⽬录，也⽤于重命名。 cat：显示⽂件的内容。 vi: 编辑⽂件 head 和 tail：查看⽂件的开头和结尾部分。 grep：查找⽂件或其他内容⾥符合条件的字符串 find：查找⽂件和⽬录。 chmod：更改⽂件或⽬录的权限。 chown：更改⽂件或⽬录的所有者。 ps：列出运⾏中的进程。 kill：终⽌进程。 df：显示磁盘空间使⽤情况。 tar：创建和提取归档⽂件（通常是.tar⽂件）。 ifconfig：查看ip地址。ping：测试⽹络连接。 ssh：通过SSH协议远程登录到其他计算机。 apt（Debian&#x2F;Ubuntu）或 yum（Red Hat&#x2F;CentOS）：包管理器，⽤于安装、更新和删除软件包</p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="1、一条SQL查询语句是如何执行的？"><a href="#1、一条SQL查询语句是如何执行的？" class="headerlink" title="1、一条SQL查询语句是如何执行的？"></a>1、一条SQL查询语句是如何执行的？</h2><p>1、连接器：负责跟客户端建立连接，获取权限、维持和管理连接。</p>
<ul>
<li><p>与客户端进行 TCP 三次握手建立连接；</p>
</li>
<li><p>校验客户端的用户名和密码，如果用户名或密码不对，则会报错；</p>
</li>
<li><p>如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限；</p>
</li>
</ul>
<p>2、查询缓存：如果 SQL 是查询语句（select 语句），MySQL 就会先去查询缓存（ Query Cache ）里查找缓存数据，看看之前有没有执行过这一条命令，这个查询缓存是以 key-value 形式保存在内存中的，key 为 SQL 查询语句，value 为 SQL 语句查询的结果。</p>
<p>如果查询的语句命中查询缓存，那么就会直接返回 value 给客户端。如果查询的语句没有命中查询缓存中，那么就要往下继续执行，等执行完后，查询的结果就会被存入查询缓存中。</p>
<p>PS：对于更新比较频繁的表，查询缓存的命中率很低的，因为只要一个表有更新操作，那么这个表的查询缓存就会被清空。如果刚缓存了一个查询结果很大的数据，还没被使用的时候，刚好这个表有更新操作，查询缓冲就被清空了，相当于缓存了个寂寞。<strong>所以，MySQL 8.0 版本直接将查询缓存删掉了，也就是说 MySQL 8.0 开始，执行一条 SQL 查询语句，不会再走到查询缓存这个阶段了</strong>。</p>
<p>3、解析SQL：解析器做的第一件事情，<strong>词法分析</strong>。MySQL 会根据你输入的字符串识别出关键字出来，第二件事情，<strong>语法分析</strong>，根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法，如果没问题就会构建出 SQL 语法树，这样方便后面模块获取 SQL 类型、表名、字段名、 where 条件等等。</p>
<p>4、执行SQL：</p>
<p>经过解析器后，接着就要进入执行 SQL 查询语句的流程了，每条<code>SELECT</code> 查询语句流程主要可以分为下面这三个阶段：</p>
<ul>
<li>prepare 阶段，也就是预处理阶段；</li>
<li>optimize 阶段，也就是优化阶段；</li>
<li>execute 阶段，也就是执行阶段；</li>
</ul>
<p><strong>预处理器</strong>：我们先来说说预处理阶段做了什么事情。</p>
<ul>
<li><p>检查 SQL 查询语句中的表或者字段是否存在；</p>
</li>
<li><p>将 <code>select *</code> 中的 <code>*</code> 符号，扩展为表上的所有列；</p>
</li>
</ul>
<p><strong>优化器</strong>：经过预处理阶段后，还需要为 SQL 查询语句先制定一个执行计划，这个工作交由「优化器」来完成的。</p>
<p><strong>优化器主要负责将 SQL 查询语句的执行方案确定下来</strong>，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。</p>
<p>举例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> product <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span>  <span class="hljs-keyword">and</span> name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;i%&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>这条查询语句的结果既可以使用主键索引，也可以使用普通索引，但是执行的效率会不同。这时，就需要优化器来决定使用哪个索引了。</p>
<p>很显然这条查询语句是<strong>覆盖索引</strong>，直接在二级索引就能查找到结果（因为二级索引的 B+ 树的叶子节点的数据存储的是主键值），就没必要在主键索引查找了，<strong>因为查询主键索引的 B+ 树的成本会比查询二级索引的 B+ 的成本大</strong>，优化器基于查询成本的考虑，会选择查询代价小的普通索引。</p>
<p><strong>执行器</strong>：经历完优化器后，就确定了执行方案，接下来 MySQL 就真正开始执行语句了，这个工作是由「执行器」完成的。在执行的过程中，执行器就会和存储引擎交互了，交互是以记录为单位的。</p>
<p>总结：</p>
<p>执行一条 SQL 查询语句，期间发生了什么？</p>
<ul>
<li>连接器：建立连接，管理连接、校验用户身份；</li>
<li>查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；</li>
<li>解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；</li>
<li>执行 SQL：执行 SQL 共有三个阶段：<ul>
<li>预处理阶段：检查表或字段是否存在；将 <code>select *</code> 中的 <code>*</code> 符号扩展为表上的所有列。</li>
<li>优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；</li>
<li>执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</li>
</ul>
</li>
</ul>
<h2 id="2、什么是索引"><a href="#2、什么是索引" class="headerlink" title="2、什么是索引"></a>2、什么是索引</h2><p>索引的定义就是帮助存储引擎快速获取数据的一种数据结构，形象的说就是索引是数据的目录。</p>
<h2 id="3、索引的分类"><a href="#3、索引的分类" class="headerlink" title="3、索引的分类"></a>3、索引的分类</h2><p>我们可以按照四个角度来分类索引。</p>
<ul>
<li><p>按「数据结构」分类：</p>
<p><strong>B+tree索引</strong>:所有数据存放在叶子结点，适合范围查询。</p>
<p><strong>Hash索引</strong>：适合等值查询，检索效率高，一次到位。</p>
<p><strong>Full-text索引</strong>：一般在文本类型char、text、varchar上创建。</p>
</li>
<li><p>按「物理存储」分类：</p>
<p><strong>聚簇索引（主键索引）</strong>：主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；</p>
<p><strong>二级索引（辅助索引）</strong>：二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。</p>
<p>所以，在查询时使用了二级索引，如果查询的数据能在二级索引里查询的到，那么就不需要回表，这个过程就是<strong>覆盖索引</strong>。如果查询的数据不在二级索引里，就会先检索二级索引，找到对应的叶子节点，获取到主键值后，然后再检索主键索引，就能查询到数据了，这个过程就是<strong>回表</strong>。</p>
</li>
<li><p>按「字段特性」分类：</p>
<p><strong>主键索引</strong>：主键索引就是建立在主键字段上的索引，通常在创建表的时候一起创建，<strong>一张表最多只有一个主键索引，索引列的值不允许有空值</strong>。</p>
<p><strong>唯一索引</strong>：唯一索引建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，<strong>索引列的值必须唯一，但是允许有空值</strong>。</p>
<p><strong>普通索引</strong>：普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE，<strong>允许空值和重复值</strong>。</p>
<p><strong>前缀索引</strong>：前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。</p>
</li>
<li><p>按「字段个数」分类：</p>
<p><strong>单列索引</strong>：立在单列上的索引称为单列索引，比如主键索引。</p>
<p><strong>联合索引</strong>：通过将多个字段组合成一个索引，该索引就被称为联合索引。使用联合索引时，存在<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配。在使用联合索引进行查询的时候，如果不遵循「最左匹配原则」，联合索引会失效，这样就无法利用到索引快速查询的特性了。</p>
<p>注意：联合索引有一些特殊情况，<strong>并不是查询过程使用了联合索引查询，就代表联合索引中的所有字段都用到了联合索引进行索引查询</strong>，也就是可能存在部分字段用到联合索引的 B+Tree，部分字段没有用到联合索引的 B+Tree 的情况。</p>
<p><strong>这种特殊情况就发生在范围查询</strong>。联合索引的最左匹配原则会一直向右匹配直到遇到「范围查询」就会停止匹配。<strong>也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引</strong>。</p>
</li>
</ul>
<h2 id="4、什么时候需要索引，什么时候不需要索引？"><a href="#4、什么时候需要索引，什么时候不需要索引？" class="headerlink" title="4、什么时候需要索引，什么时候不需要索引？"></a>4、什么时候需要索引，什么时候不需要索引？</h2><p>索引最大的好处是提高查询速度，但是索引也是有缺点的，比如：</p>
<ul>
<li>需要占用物理空间，数量越大，占用空间越大；</li>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增大；</li>
<li>会降低表的增删改的效率，因为每次增删改索引，B+ 树为了维护索引有序性，都需要进行动态维护。</li>
</ul>
<p>所以，索引不是万能钥匙，它也是根据场景来使用的。</p>
<h4 id="什么时候适用索引？"><a href="#什么时候适用索引？" class="headerlink" title="什么时候适用索引？"></a>什么时候适用索引？</h4><ul>
<li><strong>字段有唯一性限制的</strong>，比如商品编码；</li>
<li><strong>经常用于 <code>WHERE</code> 查询条件的字段</strong>，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。</li>
<li><strong>经常用于 <code>GROUP BY</code> 和 <code>ORDER BY</code> 的字段</strong>，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。</li>
</ul>
<h4 id="什么时候不需要创建索引？"><a href="#什么时候不需要创建索引？" class="headerlink" title="什么时候不需要创建索引？"></a>什么时候不需要创建索引？</h4><ul>
<li><strong><code>WHERE</code> 条件，<code>GROUP BY</code>，<code>ORDER BY</code> 里用不到的字段</strong>，索引的价值是快速定位，如果起不到定位的字段通常是<strong>不需要创建索引</strong>的，因为索引是会占用物理空间的。</li>
<li><strong>字段中存在大量重复数据，不需要创建索引</strong>，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。</li>
<li><strong>表数据太少的时候，不需要创建索引</strong>；（小表）</li>
<li><strong>经常更新的字段不用创建索引</strong>，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。</li>
</ul>
<h2 id="5、为什么MySql采用B-Tree作为索引？"><a href="#5、为什么MySql采用B-Tree作为索引？" class="headerlink" title="5、为什么MySql采用B+Tree作为索引？"></a>5、为什么MySql采用B+Tree作为索引？</h2><p>MySql的数据是持久化的，所以其数据（索引+记录）是保存在磁盘中的，防止设备断电而导致数据丢失。所以，当我们通过索引查找数据的时候，查询过程会发生多次磁盘IO，而磁盘IO发生次数越多，所消耗的时间也越大。</p>
<p>所以，我们希望索引的数据结构能在尽可能少的磁盘的 I&#x2F;O 操作中完成查询工作，因为磁盘 I&#x2F;O 操作越少，所消耗的时间也就越小</p>
<p>另外，另外，MySQL 是支持范围查找的，所以索引的数据结构不仅要能高效地查询某一个记录，而且也要能高效地执行范围查找。</p>
<p>综上所述，要设计一个适合 MySQL 索引的数据结构，至少满足以下要求：</p>
<ul>
<li><strong>能在尽可能少的磁盘的 I&#x2F;O 操作中完成查询工作；</strong></li>
<li><strong>要能高效地查询某一个记录，也要能高效地执行范围查找；</strong></li>
</ul>
<p>分析各种数据结构的优缺点：</p>
<p>二分查找法每次都把查询的范围减半，这样时间复杂度就降到了 O(logn)，但是每次查找都需要不断计算中间位置。</p>
<p>二叉查找树（搜索树）解决了连续结构插入新元素开销很大的问题，同时又保持着天然的二分结构，但是**当每次插入的元素都是二叉查找树中最大的元素，二叉查找树就会退化成了一条链表，查找数据的时间复杂度变成了 O(n)**。</p>
<p>为了解决二叉查找树会在极端情况下退化成链表的问题，后面就有人提出<strong>平衡二叉查找树（AVL 树）</strong>。主要是在二叉查找树的基础上增加了一些条件约束：<strong>每个节点的左子树和右子树的高度差不能超过 1</strong>。也就是说节点的左子树和右子树仍然为平衡二叉树，这样查询操作的时间复杂度就会一直维持在 O(logn)。但是<strong>不管平衡二叉查找树还是红黑树，都会随着插入的元素增多，而导致树的高度变高，这就意味着磁盘 I&#x2F;O 操作次数多，会影响整体数据查询的效率</strong>。</p>
<p>为了解决降低树的高度的问题，后面就出来了 <strong>B 树</strong>，它不再限制一个节点就只能有 2 个子节点，而是允许 M 个子节点 (M&gt;2)，从而降低树的高度。同样的节点数量在平衡二叉树的场景下，树的高度就会很高，意味着磁盘 I&#x2F;O 操作会更多。<strong>所以，B 树在数据查询中比平衡二叉树效率要高。</strong>但是 B 树的每个节点都包含数据（索引+记录），而用户的记录数据的大小很有可能远远超过了索引数据，这就需要花费更多的磁盘 I&#x2F;O 操作次数来读到「有用的索引数据」，另外，如果使用 B 树来做范围查询的话，需要使用中序遍历，这会涉及多个节点的磁盘 I&#x2F;O 问题，从而导致整体速度下降。</p>
<p>B+ 树与 B 树差异的点，主要是以下这几点：</p>
<ul>
<li><strong>叶子节点（最底部的节点）才会存放实际数据（索引+记录）</strong>，<strong>非叶子节点只会存放索引；</strong></li>
<li>所有索引都会在叶子节点出现，叶子节点之间构成一个有序链表；</li>
<li>非叶子节点的索引也会同时存在在子节点中，并且是在子节点中所有索引的最大（或最小）。</li>
<li>非叶子节点中有多少个子节点，就有多少个索引；</li>
</ul>
<p><strong>总结：MySQL 默认的存储引擎 InnoDB 采用的是 B+ 树作为索引的数据结构，原因有：</strong></p>
<ul>
<li>B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储既存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，**查询底层节点的磁盘 I&#x2F;O次数会更少    <strong>–单点查询更快</strong></li>
<li>B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；**–插入和删除效率**</li>
<li>B+ 树叶子节点之间用链表连接了起来，<strong>有利于范围查询</strong>，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I&#x2F;O 操作，范围查询效率不如 B+ 树。**–范围查询**</li>
</ul>
<h2 id="6、索引失效的场景有哪些？"><a href="#6、索引失效的场景有哪些？" class="headerlink" title="6、索引失效的场景有哪些？"></a>6、索引失效的场景有哪些？</h2><p>1、对索引使用左或者左右模糊匹配</p>
<p>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code> 这两种方式都会造成索引失效，<strong>因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较。</strong></p>
<p>2、对索引使用函数</p>
<p>有时候我们会用一些 MySQL 自带的函数来得到我们想要的结果，这时候要注意了，如果查询条件中对索引字段使用函数，就会导致索引失效。因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。</p>
<p><strong>从 MySQL 8.0 开始，索引特性增加了函数索引，即可以针对函数计算后的值建立一个索引，也就是说该索引的值是函数计算后的值，所以就可以通过扫描索引来查询数据。</strong></p>
<p>3、对索引进行表达式计算</p>
<p>在查询条件中对索引进行表达式计算，也是无法走索引的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">explain select * from t_user where id + 1 = 10; // 不行<br>explain select * from t_user where id = 10 -1;// 可以<br></code></pre></td></tr></table></figure>

<p>4、对索引进行隐式类型转换</p>
<p><strong>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较</strong>。</p>
<p>前面的例子一中的查询语句，我也跟大家说了是会走<strong>全表扫描</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>例子一的查询语句<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> phone <span class="hljs-operator">=</span> <span class="hljs-number">1300000001</span>;<br></code></pre></td></tr></table></figure>

<p>这是因为 phone 字段为字符串，所以 MySQL 要会自动把字符串转为数字，所以这条语句相当于：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> <span class="hljs-built_in">CAST</span>(phone <span class="hljs-keyword">AS</span> signed <span class="hljs-type">int</span>) <span class="hljs-operator">=</span> <span class="hljs-number">1300000001</span>;<br></code></pre></td></tr></table></figure>

<p>可以看到，<strong>CAST 函数是作用在了 phone 字段，而 phone 字段是索引，也就是对索引使用了函数！而前面我们也说了，对索引使用函数是会导致索引失效的</strong>。</p>
<p>例子二中的查询语句，我跟大家说了是会走索引扫描：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>例子二的查询语句<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> &quot;1&quot;;<br></code></pre></td></tr></table></figure>

<p>这时因为字符串部分是输入参数，也就需要将字符串转为数字，所以这条语句相当于：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-built_in">CAST</span>(&quot;1&quot; <span class="hljs-keyword">AS</span> signed <span class="hljs-type">int</span>);<br></code></pre></td></tr></table></figure>

<p>可以看到，<strong>索引字段并没有用任何函数，CAST 函数是用在了输入参数，因此是可以走索引扫描的。</strong></p>
<p>5、联合索引非最左匹配（或遇到范围查询）</p>
<p>对主键字段建立的索引叫做聚簇索引，对普通字段建立的索引叫做二级索引。</p>
<p>那么<strong>多个普通字段组合在一起创建的索引就叫做联合索引</strong>，也叫组合索引。</p>
<p>创建联合索引时，我们需要注意创建时的顺序问题，因为联合索引 (a, b, c) 和 (c, b, a) 在使用的时候会存在差别。联合索引要能正确使用需要遵循<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配。</p>
<p>也就是说，如果我们想使用联合索引中尽可能多的列，查询条件中的各个列必须是联合索引中从最左边开始连续的列。如果我们仅仅按照第二列搜索，肯定无法走索引。</p>
<p>6、WHERE语句中的OR</p>
<p>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</p>
<p>总结：</p>
<ul>
<li>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；</li>
<li>当我们在查询条件中对索引列使用函数，就会导致索引失效。</li>
<li>当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。</li>
<li>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。</li>
<li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li>
<li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效</li>
</ul>
<h2 id="7、事物有哪些特性"><a href="#7、事物有哪些特性" class="headerlink" title="7、事物有哪些特性"></a>7、事物有哪些特性</h2><p>1、<strong>原子性</strong>：事物是不可分割的最小工作单元，一个事物中的所有操作，要么全部完成，要么全部未完成，不会停留在中间状态（比如只完成一半）。如果事物执行过程中发生了错误，会被回滚到没执行操作之前原来的状态，像事物没有执行过一样。**–undo 回滚日志实现**</p>
<p>2、<strong>一致性</strong>：一个事物操作之前和执行之后的状态必须保持一致。比如用户 A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，用户 A 给用户 B 转账 200 元，分为两个步骤，从 A 的账户扣除 200 元和对 B 的账户增加 200 元。一致性就是要求上述步骤操作后，最后的结果是用户 A 还有 600 元，用户 B 有 800 元，总共 1400 元，而不会出现用户 A 扣除了 200 元，但用户 B 未增加的情况。**–其他三种共同保障**</p>
<p>3、隔离性：数据库允许多个并发事务同时对其数据进行修改和读取，隔离性可以防止多个事物并发执行时由于交叉执行导致的数据不一致的情况，因为多个事物并发执行的时候不会相互干扰，每个事物都有一个完整的数据空间，对其他并发事务是隔离的。**–MVCC（多版本并发控制）或者锁机制。**</p>
<p>4、持久性：事物处理结束之后，对数据的修改是永久的，即使系统故障也不会丢失。-<strong>-redo log（重做日志）</strong></p>
<h2 id="8、说一说事物的隔离级别以及他们都是怎么实现的？"><a href="#8、说一说事物的隔离级别以及他们都是怎么实现的？" class="headerlink" title="8、说一说事物的隔离级别以及他们都是怎么实现的？"></a>8、说一说事物的隔离级别以及他们都是怎么实现的？</h2><p>MySQL 服务端是允许多个客户端连接的，这意味着 MySQL 会出现同时处理多个事务的情况。那么<strong>在同时处理多个事务的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题</strong>。</p>
<p>当多个事务并发执行时可能会遇到「脏读、不可重复读、幻读」的现象，这些现象会对事务的一致性产生不同程序的影响。</p>
<ul>
<li>脏读：读到其他事务未提交的数据；</li>
<li>不可重复读：前后读取的数据不一致；</li>
<li>幻读：前后读取的记录数量不一致。</li>
</ul>
<p>SQL 标准提出了四种隔离级别来规避这些现象，隔离级别越高，性能效率就越低，这四个隔离级别如下：<strong>自上而下隔离级别逐级变高</strong>、性能越低</p>
<ul>
<li><strong>读未提交（*read uncommitted*）</strong>，指一个事务还没提交时，它做的变更就能被其他事务看到；</li>
<li><strong>读提交（*read committed*）</strong>，指一个事务提交之后，它做的变更才能被其他事务看到；</li>
<li><strong>可重复读（*repeatable read*）</strong>，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，<strong>MySQL InnoDB 引擎的默认隔离级别</strong>；</li>
<li><strong>串行化（*serializable* ）</strong>；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；</li>
</ul>
<p><strong>针对不同的隔离级别，并发事务时可能发生的现象也会不同</strong>，也就是说：</p>
<ul>
<li>在「读未提交」隔离级别下，可能发生<strong>脏读</strong>、<strong>不可重复读</strong>和<strong>幻读</strong>现象；</li>
<li>在「读提交」隔离级别下，可能发生<strong>不可重复读</strong>和<strong>幻读</strong>现象，但是不可能发生脏读现象；</li>
<li>在「可重复读」隔离级别下，可能发生<strong>幻读</strong>现象，但是不可能发生脏读和不可重复读现象；</li>
<li>在「串行化」隔离级别下，脏读、不可重复读和幻读现象都不可能会发生。</li>
</ul>
<p>要解决脏读现象，就要将隔离级别升级到读已提交以上的隔离级别，要解决不可重复读现象，就要将隔离级别升级到可重复读以上的隔离级别。</p>
<p>而对于幻读现象，不建议将隔离级别升级为串行化，因为这会导致数据库并发时性能很差。MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象，解决的方案有两种：</p>
<ul>
<li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li>
<li>针对<strong>当前读</strong>（select … for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li>
</ul>
<p>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同：</p>
<ul>
<li>「读提交」隔离级别是在<strong>每个 select 都会生成一个新的 Read View，</strong>也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。</li>
<li>「可重复读」隔离级别是<strong>启动事务时生成一个 Read View</strong>，然后整个事务期间都在用这个 Read View，<strong>这样就保证了在事务期间读到的数据都是事务启动前的记录。</strong></li>
</ul>
<p>这两个隔离级别实现是通过「事务的 Read View 里的字段」和「记录中的两个隐藏列」的比对，来控制并发事务访问同一个记录时的行为，这就叫 MVCC（多版本并发控制）。</p>
<p>在可重复读隔离级别中，普通的 select 语句就是基于 MVCC 实现的快照读，也就是不会加锁的。而 select .. for update 语句就不是快照读了，而是当前读了，也就是每次读都是拿到最新版本的数据，但是它会对读到的记录加上 next-key lock 锁。</p>
<h2 id="9、MySQL-可重复读隔离级别，完全解决幻读了吗？"><a href="#9、MySQL-可重复读隔离级别，完全解决幻读了吗？" class="headerlink" title="9、MySQL 可重复读隔离级别，完全解决幻读了吗？"></a>9、MySQL 可重复读隔离级别，完全解决幻读了吗？</h2><p>MySQL InnoDB 引擎的可重复读隔离级别（默认隔离级），根据不同的查询方式，分别提出了避免幻读的方案：</p>
<ul>
<li>针对<strong>快照读</strong>（普通 select 语句），是通过 MVCC 方式解决了幻读。</li>
<li>针对<strong>当前读</strong>（select … for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读。</li>
</ul>
<p>我举例了两个发生幻读场景的例子。</p>
<p>第一个例子：对于快照读， MVCC 并不能完全避免幻读现象。因为当事务 A 更新了一条事务 B 插入的记录，那么事务 A 前后两次查询的记录条目就不一样了，所以就发生幻读。</p>
<p>第二个例子：对于当前读，如果事务开启后，并没有执行当前读，而是先快照读，然后这期间如果其他事务插入了一条记录，那么事务后续使用当前读进行查询的时候，就会发现两次查询的记录条目就不一样了，所以就发生幻读。</p>
<p>所以，<strong>MySQL 可重复读隔离级别并没有彻底解决幻读，只是很大程度上避免了幻读现象的发生。</strong></p>
<p>要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select … for update 这类当前读的语句，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。</p>
<h2 id="10、MYSQL有哪些锁？作用是什么？"><a href="#10、MYSQL有哪些锁？作用是什么？" class="headerlink" title="10、MYSQL有哪些锁？作用是什么？"></a>10、MYSQL有哪些锁？作用是什么？</h2><h3 id="1、全局锁"><a href="#1、全局锁" class="headerlink" title="1、全局锁"></a>1、全局锁</h3><blockquote>
<p>1、全局锁是怎么用的？</p>
</blockquote>
<p>要使用全局锁，则要执行这条命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">flush tables <span class="hljs-keyword">with</span> read lock<br></code></pre></td></tr></table></figure>

<p>执行后，<strong>整个数据库就处于只读状态了</strong>，这时其他线程执行以下操作，都会被阻塞：</p>
<ul>
<li>对数据的增删改操作，比如 insert、delete、update等语句；</li>
<li>对表结构的更改操作，比如 alter table、drop table 等语句。</li>
</ul>
<p>如果要释放全局锁，则要执行这条命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">unlock tables<br></code></pre></td></tr></table></figure>

<p>当然，当会话断开了，全局锁会被自动释放。</p>
<blockquote>
<p>2、全局锁应用场景是什么？</p>
</blockquote>
<p>全局锁主要应用于做<strong>全库逻辑备份</strong>，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。</p>
<blockquote>
<p>3、加全局锁又会带来什么缺点呢？</p>
</blockquote>
<p>加上全局锁，意味着整个数据库都是<strong>只读状态</strong>。</p>
<p>那么如果数据库里有很多数据，备份就会花费很多的时间，关键是备份期间，业务只能读数据，而不能更新数据，这样会造成业务停滞。</p>
<blockquote>
<p>4、既然备份数据库数据的时候，使用全局锁会影响业务，那有什么其他方式可以避免？</p>
</blockquote>
<p>有的，如果数据库的引擎支持的事务支持<strong>可重复读的隔离级别</strong>，<strong>那么在备份数据库之前先开启事务</strong>，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。</p>
<p>因为在可重复读的隔离级别下，即使其他事务更新了表的数据，也不会影响备份数据库时的 Read View，这就是事务四大特性中的<strong>隔离性</strong>，这样备份期间备份的数据一直是在开启事务时的数据。</p>
<p>PS： InnoDB 存储引擎默认的事务隔离级别正是可重复读，因此可以采用这种方式来备份数据库。但是，对于 MyISAM 这种不支持事务的引擎，在备份数据库时就要使用全局锁的方法。</p>
<h3 id="2、表级锁"><a href="#2、表级锁" class="headerlink" title="2、表级锁"></a>2、表级锁</h3><blockquote>
<p>MySQL 表级锁有哪些？具体怎么用的。</p>
</blockquote>
<p>MySQL 里面表级别的锁有这几种：</p>
<ul>
<li><p>表锁：表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。</p>
<p>也就是说如果本线程对学生表加了「共享表锁」，那么本线程接下来如果要对学生表执行<strong>写操作</strong>的语句，是会被阻塞的，当然其他线程对学生表进行<strong>写操作</strong>时也会被阻塞，直到锁被释放。</p>
<p>不过尽量避免在使用 InnoDB 引擎的表使用表锁，因为表锁的颗粒度太大，<strong>会影响并发性能</strong>，<strong>InnoDB 牛逼的地方在于实现了颗粒度更细的行级锁</strong>。</p>
</li>
<li><p>元数据锁（MDL）：我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：</p>
<ul>
<li>对一张表进行 CRUD 操作时，加的是 <strong>MDL 读锁</strong>；</li>
<li>对一张表做结构变更操作的时候，加的是 <strong>MDL 写锁</strong>；</li>
</ul>
<p><strong>MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。</strong></p>
<p>当有线程在执行 select 语句（ 加 MDL 读锁）的期间，如果有其他线程要更改该表的结构（ 申请 MDL 写锁），那么将会被阻塞，直到执行完 select 语句（ 释放 MDL 读锁）。</p>
<p>反之，当有线程对表结构进行变更（ 加 MDL 写锁）的期间，如果有其他线程执行了 CRUD 操作（ 申请 MDL 读锁），那么就会被阻塞，直到表结构变更完成（ 释放 MDL 写锁）。</p>
<p>MDL 是在事务提交后才会释放，这意味着<strong>事务执行期间，MDL 是一直持有的</strong>。</p>
<p><strong>PS</strong>：申请 MDL 锁的操作会形成一个队列，队列中<strong>写锁获取优先级高于读锁</strong>，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。</p>
<p>所以为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中的<strong>长事务</strong>，是否有事务已经对表加上了 MDL 读锁，如果可以考虑 kill 掉这个长事务，然后再做表结构的变更。</p>
</li>
<li><p>意向锁：</p>
<p>在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；</p>
<p>在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；</p>
<p>也就是，当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。</p>
<p>而普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。</p>
<p><strong>意向锁的目的是为了快速判断表里是否有记录被加锁</strong>。</p>
</li>
<li><p>AUTO-INC 锁：表里的主键通常都会设置成自增的，这是通过对主键字段声明 <code>AUTO_INCREMENT</code> 属性实现的。</p>
<p>之后可以在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过 <strong>AUTO-INC 锁</strong>实现的。</p>
<p>AUTO-INC 锁是特殊的表锁机制，锁<strong>不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放</strong>。</p>
<p><strong>在插入数据时，会加一个表级别的 AUTO-INC 锁</strong>，然后为被 <code>AUTO_INCREMENT</code> 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。</p>
<p>那么，一个事务在持有 AUTO-INC 锁的过程中，其他事务如果要向该表插入语句都会被阻塞，从而保证插入数据时，被 <code>AUTO_INCREMENT</code> 修饰的字段的值是连续递增的。</p>
</li>
</ul>
<h3 id="3、行级锁"><a href="#3、行级锁" class="headerlink" title="3、行级锁"></a>3、行级锁</h3><p>行级锁的类型主要有三类：</p>
<ul>
<li>Record Lock，记录锁，也就是仅仅把一条记录锁上；</li>
<li>Gap Lock，间隙锁，锁定一个范围，<strong>但是不包含记录本身</strong>；</li>
<li>Next-Key Lock： Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</li>
</ul>
<h4 id="Record-Lock"><a href="#Record-Lock" class="headerlink" title="Record Lock"></a>Record Lock</h4><p>Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的：</p>
<ul>
<li>当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;</li>
<li>当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。</li>
</ul>
<h4 id="Gap-Lock"><a href="#Gap-Lock" class="headerlink" title="Gap Lock"></a>Gap Lock</h4><p>Gap Lock 称为间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。</p>
<p>假设，表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id &#x3D; 4 这条记录了，这样就有效的防止幻读现象的发生。</p>
<p>间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，<strong>间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的</strong>。</p>
<h4 id="Next-Key-Lock"><a href="#Next-Key-Lock" class="headerlink" title="Next-Key Lock"></a>Next-Key Lock</h4><p>Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</p>
<p>假设，表中有一个范围 id 为（3，5] 的 next-key lock，那么其他事务即不能插入 id &#x3D; 4 记录，也不能修改 id &#x3D; 5 这条记录。</p>
<p>所以，next-key lock 即能保护该记录，又能阻止其他事务将新纪录插入到被保护记录前面的间隙中。</p>
<p><strong>next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的</strong>。</p>
<h4 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h4><p>一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。</p>
<p>如果有的话，插入操作就会发生<strong>阻塞</strong>，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个<strong>插入意向锁</strong>，表明有事务想在某个区间插入新记录，但是现在处于等待状态。</p>
<p>插入意向锁名字虽然有意向锁，但是它并<strong>不是意向锁，它是一种特殊的间隙锁，属于行级别锁</strong>。</p>
<p>如果说间隙锁锁住的是一个区间，那么「插入意向锁」锁住的就是一个点。因而从这个角度来说，插入意向锁确实是一种特殊的间隙锁。</p>
<h2 id="11、MYSQL的执行引擎有哪些？"><a href="#11、MYSQL的执行引擎有哪些？" class="headerlink" title="11、MYSQL的执行引擎有哪些？"></a>11、MYSQL的执行引擎有哪些？</h2><p>1、InnoDB</p>
<p>该引擎提供了对事务ACID的支持，还提供了行级锁和外键的支持。</p>
<p>2、MyISAM</p>
<p>该引擎不支持事务，也不支持行级锁和外键约束。</p>
<p>3、Memery</p>
<p>将数据放在内存中，数据处理速度很快，但是安全性不高。</p>
<h2 id="12、MYSQL的日志文件有哪几种？"><a href="#12、MYSQL的日志文件有哪几种？" class="headerlink" title="12、MYSQL的日志文件有哪几种？"></a>12、MYSQL的日志文件有哪几种？</h2><ul>
<li><strong>undo log（回滚日志）</strong>：是InnoDB存储引擎层生成的日志，实现了事务中的<strong>原子性</strong>，主要用于<strong>事务回滚</strong>和 MVCC。</li>
<li><strong>redo log（重做日志）</strong>：是 InnoDB存储引擎层生成的日志，实现了事务中的<strong>持久性</strong>，主要<strong>用于掉电等故障恢复</strong>；</li>
<li><strong>binlog （归档日志）</strong>：是 Server 层生成的日志，主要<strong>用于数据备份和主从复制</strong>；</li>
</ul>
<p>1、undo log 两大作用：</p>
<ul>
<li><strong>实现事务回滚，保障事务的原子性</strong>。事务处理过程中，如果出现了错误或者用户执 行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。</li>
<li><strong>实现 MVCC（多版本并发控制）关键因素之一</strong>。MVCC 是通过 Read View + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，<strong>顺着 undo log 的版本链</strong>找到满足其可见性的记录。</li>
</ul>
<p>2、redo log 和 undo log 区别在哪？</p>
<p>这两种日志是属于 InnoDB 存储引擎的日志，它们的区别在于：</p>
<ul>
<li>redo log 记录了此次事务「<strong>完成后</strong>」的数据状态，记录的是更新<strong>之后</strong>的值；</li>
<li>undo log 记录了此次事务「<strong>开始前</strong>」的数据状态，记录的是更新<strong>之前</strong>的值；</li>
</ul>
<p><strong>事务提交之前</strong>发生了崩溃，重启后会通过 undo log 回滚事务，<strong>事务提交之后</strong>发生了崩溃，重启后会通过 redo log 恢复事务。<strong>Redo</strong> log 保证了事务四大特性中的<strong>持久性。</strong></p>
<p>3、为什么需要 redo log 这个问题我们有两个答案：</p>
<ul>
<li><strong>实现事务的持久性，让 MySQL 有 crash-safe 的能力</strong>，能够保证 MySQL 在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失；</li>
<li><strong>将写操作从「随机写」变成了「顺序写」</strong>，提升 MySQL 写入磁盘的性能。</li>
</ul>
<p><strong>WAL 技术指的是， MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上</strong>。</p>
<p>4、产生的 redo log 是直接写入磁盘的吗？</p>
<p>不是的。</p>
<p>实际上， 执行一个事务的过程中，产生的 redo log 也不是直接写入磁盘的，因为这样会产生大量的 I&#x2F;O 操作，而且磁盘的运行速度远慢于内存。</p>
<p>所以，redo log 也有自己的缓存—— <strong>redo log buffer</strong>，每当产生一条 redo log 时，会先写入到 redo log buffer，后续在持久化到磁盘如下图：</p>
<p>5、redo log 和 bin log有什么区别？</p>
<p>这两个日志有四个区别。</p>
<p><em>1、适用对象不同：</em></p>
<ul>
<li>binlog 是 MySQL 的 Server 层实现的日志，所有存储引擎都可以使用；</li>
<li>redo log 是 InnoDB存储引擎实现的日志；</li>
</ul>
<p><em>2、文件格式不同：</em></p>
<ul>
<li>binlog 有 3 种格式类型，分别是 STATEMENT（默认格式）、ROW、 MIXED，区别如下：<ul>
<li>STATEMENT：每一条修改数据的 SQL 都会被记录到 binlog 中（相当于记录了逻辑操作，所以针对这种格式， binlog 可以称为逻辑日志），主从复制中 slave 端再根据 SQL 语句重现。但 STATEMENT 有动态函数的问题，比如你用了 uuid 或者 now 这些函数，你在主库上执行的结果并不是你在从库执行的结果，这种随时在变的函数会导致复制的数据不一致；</li>
<li>ROW：记录行数据最终被修改成什么样了（这种格式的日志，就不能称为逻辑日志了），不会出现 STATEMENT 下动态函数的问题。但 ROW 的缺点是每行数据的变化结果都会被记录，比如执行批量 update 语句，更新多少行数据就会产生多少条记录，使 binlog 文件过大，而在 STATEMENT 格式下只会记录一个 update 语句而已；</li>
<li>MIXED：包含了 STATEMENT 和 ROW 模式，它会根据不同的情况自动使用 ROW 模式和 STATEMENT 模式；</li>
</ul>
</li>
<li>redo log 是物理日志，记录的是在某个数据页做了什么修改，比如对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新；</li>
</ul>
<p><em>3、写入方式不同：</em></p>
<ul>
<li>binlog 是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志。</li>
<li><strong>redo log 是循环写</strong>，日志空间大小是固定，全部写满就从头开始，保存未被刷入磁盘的脏页日志。</li>
</ul>
<p><em>4、用途不同：</em></p>
<ul>
<li>binlog 用于备份恢复、主从复制；</li>
<li>redo log 用于掉电等故障恢复。</li>
</ul>
<h2 id="13、MySQL-磁盘-I-O-很高，有什么优化的方法？"><a href="#13、MySQL-磁盘-I-O-很高，有什么优化的方法？" class="headerlink" title="13、MySQL 磁盘 I&#x2F;O 很高，有什么优化的方法？"></a>13、MySQL 磁盘 I&#x2F;O 很高，有什么优化的方法？</h2><p>现在我们知道事务在提交的时候，需要将 binlog 和 redo log 持久化到磁盘，那么如果出现 MySQL 磁盘 I&#x2F;O 很高的现象，我们可以通过控制以下参数，来 “延迟” binlog 和 redo log 刷盘的时机，从而降低磁盘 I&#x2F;O 的频率：</p>
<ul>
<li>设置组提交的两个参数： binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count 参数，延迟 binlog 刷盘的时机，从而减少 binlog 的刷盘次数。这个方法是基于“额外的故意等待”来实现的，因此可能会增加语句的响应时间，但即使 MySQL 进程中途挂了，也没有丢失数据的风险，因为 binlog 早被写入到 page cache 了，只要系统没有宕机，缓存在 page cache 里的 binlog 就会被持久化到磁盘。</li>
<li>将 sync_binlog 设置为大于 1 的值（比较常见是 100~1000），表示每次提交事务都 write，但累积 N 个事务后才 fsync，相当于延迟了 binlog 刷盘的时机。但是这样做的风险是，主机掉电时会丢 N 个事务的 binlog 日志。</li>
<li>将 innodb_flush_log_at_trx_commit 设置为 2。表示每次事务提交时，都只是缓存在 redo log buffer 里的 redo log 写到 redo log 文件，注意写入到「 redo log 文件」并不意味着写入到了磁盘，因为操作系统的文件系统中有个 Page Cache，专门用来缓存文件数据的，所以写入「 redo log文件」意味着写入到了操作系统的文件缓存，然后交由操作系统控制持久化到磁盘的时机。但是这样做的风险是，主机掉电的时候会丢数据。</li>
</ul>
<h2 id="14、总结"><a href="#14、总结" class="headerlink" title="14、总结"></a>14、总结</h2><p>具体更新一条记录 <code>UPDATE t_user SET name = &#39;xiaolin&#39; WHERE id = 1;</code> 的流程如下:</p>
<ol>
<li>执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id &#x3D; 1 这一行记录：<ul>
<li>如果 id&#x3D;1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新；</li>
<li>如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。</li>
</ul>
</li>
<li>执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样：<ul>
<li>如果一样的话就不进行后续更新流程；</li>
<li>如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作；</li>
</ul>
</li>
<li>开启事务， InnoDB 层更新记录前，首先要记录相应的 undo log，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，不过在内存修改该 Undo 页面后，需要记录对应的 redo log。</li>
<li>InnoDB 层开始更新记录，会先更新内存（同时标记为脏页），然后将记录写到 redo log 里面，这个时候更新就算完成了。为了减少磁盘I&#x2F;O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。这就是 <strong>WAL 技术</strong>，MySQL 的写操作并不是立刻写到磁盘上，而是先写 redo 日志，然后在合适的时间再将修改的行数据写到磁盘上。</li>
<li>至此，一条记录更新完了。</li>
<li>在一条更新语句执行完成后，然后开始记录该语句对应的 binlog，此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。</li>
<li>事务提交（为了方便说明，这里不说组提交的过程，只说<strong>两阶段提交</strong>）：<ul>
<li><strong>prepare 阶段</strong>：将 redo log 对应的事务状态设置为 prepare，然后将 redo log 刷新到硬盘；</li>
<li><strong>commit 阶段</strong>：将 binlog 刷新到磁盘，接着调用引擎的提交事务接口，将 redo log 状态设置为 commit（将事务设置为 commit 状态后，刷入到磁盘 redo log 文件）；</li>
</ul>
</li>
<li>至此，一条更新语句执行完成。</li>
</ol>
<p><strong>为什么需要两阶段提交：</strong>事务提交后，redo log 和 binlog 都要持久化到磁盘，但是这两个是独立的逻辑，可能出现半成功的状态，这样就造成两份日志之间的逻辑不一致。</p>
<h2 id="15、MVCC原理及其实现方式"><a href="#15、MVCC原理及其实现方式" class="headerlink" title="15、MVCC原理及其实现方式"></a>15、MVCC原理及其实现方式</h2><p>MVCC(Multi-Version Concurrency Control)是一种多版本并发控制机制，它可以在数据库的读写操作中，将数据按照时间版本进行保存，并且在读取时只读取已提交的版本，避免数据的并发访问产生的问题。</p>
<p>MVCC是通过在每行记录后面保存两个隐藏的列来实现的。 这两个列，一个保存了行的创建时间，一个保存行的过期时间(或删除时间)。 当然存储的并不是实际的时间值，而是系统版本号(system version number)。 每开始一个新的事务，系统版本号都会自动递增。</p>
<p>MVCC就是多版本并发控制，实现了读写的并发控制，在mysql通过readview 隐藏字段和undolog实现了，比如在可重复读里面，比如开启了一个事务，就生成了一个readview，然后记录现在active的事务，判断查询的数据在这个事务可不可读。</p>
<h2 id="16、数据库的备份和容灾可以大致聊聊吗？"><a href="#16、数据库的备份和容灾可以大致聊聊吗？" class="headerlink" title="16、数据库的备份和容灾可以大致聊聊吗？"></a>16、数据库的备份和容灾可以大致聊聊吗？</h2><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>备份和容灾是数据库管理员和系统管理员经常考虑的重要问题。</p>
<p><strong>当谈到数据库的备份和容灾时，我们通常是在讨论如何保护数据库免受数据丢失和系统中断的影响。</strong></p>
<h3 id="数据库备份"><a href="#数据库备份" class="headerlink" title="数据库备份"></a>数据库备份</h3><p>数据库备份是指定期间将数据库的副本创建到另一个位置，以便在发生数据丢失或数据库崩溃时进行恢复。备份可以存储在磁盘、磁带或远程服务器等位置。备份的频率可以根据业务需求和数据重要性来确定，可以是每天、每周或每月进行一次。</p>
<h3 id="数据库容灾"><a href="#数据库容灾" class="headerlink" title="数据库容灾"></a>数据库容灾</h3><p>数据库容灾是指在数据库主服务器发生故障或不可用时，确保数据库系统继续运行并提供服务的能力。<strong>容灾解决方案通常包括冗余硬件、多个数据库实例、数据复制和故障转移</strong>。这些措施可以确保在主服务器发生故障时，备用服务器可以接管并继续提供服务，从而减少系统中断时间。</p>
<h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><p>常见的数据库备份和容灾技术包括：</p>
<h3 id="完全备份"><a href="#完全备份" class="headerlink" title="完全备份"></a>完全备份</h3><p>将整个数据库的副本创建到备份位置。这是最基本和最简单的备份方法，<strong>但也是最耗时和占用存储空间的方法。</strong></p>
<h3 id="增量备份"><a href="#增量备份" class="headerlink" title="增量备份"></a>增量备份</h3><p>只备份自上次完全备份或增量备份以来发生更改的数据。这种备份方法可以减少备份时间和存储空间的使用，但需要进行完全备份和增量备份的恢复过程。</p>
<h3 id="数据库复制"><a href="#数据库复制" class="headerlink" title="数据库复制"></a>数据库复制</h3><p><strong>将数据库的副本创建到另一个服务器</strong>，使其可以独立运行。这种方法可以提供高可用性和容灾能力，因为备用服务器可以在主服务器发生故障时接管。</p>
<h3 id="数据库镜像"><a href="#数据库镜像" class="headerlink" title="数据库镜像"></a>数据库镜像</h3><p><strong>创建数据库的实时副本，并将更改传输到备用服务器。这种方法可以提供几乎无中断的故障转移，但需要更多的网络带宽和服务器资源。</strong></p>
<h3 id="热备份"><a href="#热备份" class="headerlink" title="热备份"></a>热备份</h3><p>在运行的数据库上进行备份，而不需要停止数据库服务。这种方法可以确保数据库持续运行，但可能会对性能产生一些影响。</p>
<p><strong>总的来说，备份和容灾是数据库管理中不可或缺的一部分，对于确保数据的完整性和系统的可用性至关重要。选择适当的备份和容灾策略取决于业务需求、数据重要性和可承受的风险。</strong></p>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="1、什么是Redis？"><a href="#1、什么是Redis？" class="headerlink" title="1、什么是Redis？"></a>1、什么是Redis？</h2><p>Redis是一种基于内存的数据库，对数据的读写操作都在内存中完成，因此读写速度非常快，通常用于缓存、消息队列、分布式锁等场景。</p>
<p>Redis 提供了多种数据类型来支持不同的业务场景，比如 String(字符串)、Hash(哈希)、 List (列表)、Set(集合)、Zset(有序集合)、Bitmaps（位图）、HyperLogLog（基数统计）、GEO（地理信息）、Stream（流），并且对数据类型的操作都是<strong>原子性</strong>的，因为执行命令由单线程负责的，不存在并发竞争的问题。</p>
<p>除此之外，Redis 还支持<strong>事务 、持久化、Lua 脚本、多种集群方案（主从复制模式、哨兵模式、切片机群模式）、发布&#x2F;订阅模式，内存淘汰机制、过期删除机制</strong>等等。</p>
<h2 id="2、Redis-和-Memcached-有什么区别？"><a href="#2、Redis-和-Memcached-有什么区别？" class="headerlink" title="2、Redis 和 Memcached 有什么区别？"></a>2、Redis 和 Memcached 有什么区别？</h2><p>Redis和Memcached都是内存数据库，为什么选择Redis而不选择Memcached？</p>
<p><strong>相同点：</strong></p>
<ol>
<li>都是基于内存的数据库，一般都用来当做缓存使用。</li>
<li>都有过期策略。</li>
<li>两者的性能都非常高。</li>
</ol>
<p>不同点：</p>
<ul>
<li>Redis 支持的<strong>数据类型更丰富</strong>（String、Hash、List、Set、ZSet），而 Memcached 只支持最简单的 key-value 数据类型；</li>
<li>Redis 支持<strong>数据的持久化</strong>，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而 Memcached 没有持久化功能，数据全部存在内存之中，Memcached 重启或者挂掉后，数据就没了；</li>
<li>Redis 原生<strong>支持集群模式</strong>，Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；</li>
<li>Redis 支持<strong>发布订阅模型</strong>、<strong>Lua 脚本</strong>、<strong>事务</strong>等功能，而 Memcached 不支持；</li>
</ul>
<h2 id="3、为什么用-Redis-作为-MySQL-的缓存？"><a href="#3、为什么用-Redis-作为-MySQL-的缓存？" class="headerlink" title="3、为什么用 Redis 作为 MySQL 的缓存？"></a>3、为什么用 Redis 作为 MySQL 的缓存？</h2><p>主要是因为 <strong>Redis 具备「高性能」和「高并发」两种特性</strong>。</p>
<p>1、高性能：</p>
<p>假如用户第一次访问 MySQL 中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据缓存在 Redis 中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了，操作 Redis 缓存就是直接操作内存，所以速度相当快。</p>
<p>2、高并发</p>
<p>单台设备的 Redis 的 QPS（Query Per Second，每秒钟处理完请求的次数） 是 MySQL 的 10 倍，Redis 单机的 QPS 能轻松破 10w，而 MySQL 单机的 QPS 很难破 1w。</p>
<p>所以，直接访问 Redis 能够承受的请求是远远大于直接访问 MySQL 的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p>
<h2 id="4、Redis数据结构和使用场景"><a href="#4、Redis数据结构和使用场景" class="headerlink" title="4、Redis数据结构和使用场景"></a>4、Redis数据结构和使用场景</h2><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>随着 Redis 版本的更新，后面又支持了四种数据类型： <strong>BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增）</strong>。 Redis 五种数据类型的应用场景：</p>
<ul>
<li>String 类型的应用场景：缓存对象、常规计数、分布式锁、共享 session 信息等。</li>
<li>List 类型的应用场景：消息队列（但是有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据）等。</li>
<li>Hash 类型：缓存对象、购物车等。</li>
<li>Set 类型：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。</li>
<li>Zset 类型：排序场景，比如排行榜、电话和姓名排序等。</li>
</ul>
<p>Redis 后续版本又支持四种数据类型，它们的应用场景如下：</p>
<ul>
<li>BitMap（2.2 版新增）：二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等；</li>
<li>HyperLogLog（2.8 版新增）：海量数据基数统计的场景，比如百万级网页 UV 计数等；</li>
<li>GEO（3.2 版新增）：存储地理位置信息的场景，比如滴滴叫车；</li>
<li>Stream（5.0 版新增）：消息队列，相比于基于 List 类型实现的消息队列，有这两个特有的特性：自动生成全局唯一消息ID，支持以消费组形式消费数据。</li>
</ul>
<h2 id="5、Redis是单线程的吗？"><a href="#5、Redis是单线程的吗？" class="headerlink" title="5、Redis是单线程的吗？"></a>5、Redis是单线程的吗？</h2><p><strong>Redis 单线程指的是「接收客户端请求-&gt;解析请求 -&gt;进行数据读写等操作-&gt;发送数据给客户端」这个过程是由一个线程（主线程）来完成的</strong>，这也是我们常说 Redis 是单线程的原因。</p>
<p>但是，<strong>Redis 程序并不是单线程的</strong>，Redis 在启动的时候，是会<strong>启动后台线程</strong>（BIO）的：</p>
<ul>
<li><strong>Redis 在 2.6 版本</strong>，会启动 2 个后台线程，分别处理关闭文件、AOF 刷盘这两个任务；</li>
<li><strong>Redis 在 4.0 版本之后</strong>，新增了一个新的后台线程，用来异步释放 Redis 内存，也就是 lazyfree 线程。例如执行 unlink key &#x2F; flushdb async &#x2F; flushall async 等命令，会把这些删除操作交给后台线程来执行，好处是不会导致 Redis 主线程卡顿。因此，当我们要删除一个大 key 的时候，不要使用 del 命令删除，因为 del 是在主线程处理的，这样会导致 Redis 主线程卡顿，因此我们应该使用 unlink 命令来异步删除大key。</li>
</ul>
<p>之所以 Redis 为「关闭文件、AOF 刷盘、释放内存」这些任务创建单独的线程来处理，是因为这些任务的操作都是很耗时的，如果把这些任务都放在主线程来处理，那么 Redis 主线程就很容易发生阻塞，这样就无法处理后续的请求了。</p>
<h2 id="6、Redis采用单线程模式为什么还这么快？"><a href="#6、Redis采用单线程模式为什么还这么快？" class="headerlink" title="6、Redis采用单线程模式为什么还这么快？"></a>6、Redis采用单线程模式为什么还这么快？</h2><ul>
<li>Redis 的大部分操作<strong>都在内存中完成</strong>，并且采用了高效的数据结构，因此 Redis 瓶颈可能是机器的内存或者网络带宽，而并非 CPU，既然 CPU 不是瓶颈，那么自然就采用单线程的解决方案了；</li>
<li>Redis 采用单线程模型可以<strong>避免了多线程之间的竞争</strong>，省去了多线程切换带来的时间和性能上的开销，而且也不会导致死锁问题。</li>
<li>Redis 采用了 <strong>I&#x2F;O 多路复用机制</strong>处理大量的客户端 Socket 请求，IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select&#x2F;epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听 Socket 和已连接 Socket。内核会一直监听这些 Socket 上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。</li>
</ul>
<h2 id="7、-Redis-如何实现数据不丢失？"><a href="#7、-Redis-如何实现数据不丢失？" class="headerlink" title="7、 Redis 如何实现数据不丢失？"></a>7、 Redis 如何实现数据不丢失？</h2><p>Redis 的读写操作都是在内存中，所以 Redis 性能才会高，但是当 Redis 重启后，内存中的数据就会丢失，那为了保证内存中的数据不会丢失，Redis 实现了数据持久化的机制，这个机制会把数据存储到磁盘，这样在 Redis 重启就能够从磁盘中恢复原有的数据。</p>
<p>Redis 共有三种数据持久化的方式：</p>
<ul>
<li><strong>AOF 日志</strong>：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里；</li>
<li><strong>RDB 快照</strong>：将某一时刻的内存数据，以二进制的方式写入磁盘；</li>
<li><strong>混合持久化方式</strong>：Redis 4.0 新增的方式，集成了 AOF 和 RBD 的优点；</li>
</ul>
<h2 id="8、AOF-日志是如何实现的？"><a href="#8、AOF-日志是如何实现的？" class="headerlink" title="8、AOF 日志是如何实现的？"></a>8、AOF 日志是如何实现的？</h2><p>Redis 在执行完一条写操作命令后，就会把该命令以追加的方式写入到一个文件里，然后 Redis 重启时，会读取该文件记录的命令，然后逐一执行命令的方式来进行数据恢复。</p>
<blockquote>
<p>为什么先执行命令，再把数据写入日志呢？</p>
</blockquote>
<p>Redis 是先执行写操作命令后，才将该命令记录到 AOF 日志里的，这么做其实有两个好处。</p>
<ul>
<li><strong>避免额外的检查开销</strong>：因为如果先将写操作命令记录到 AOF 日志里，再执行该命令的话，如果当前的命令语法有问题，那么如果不进行命令语法检查，该错误的命令记录到 AOF 日志里后，Redis 在使用日志恢复数据时，就可能会出错。</li>
<li><strong>不会阻塞当前写操作命令的执行</strong>：因为当写操作命令执行成功后，才会将命令记录到 AOF 日志。</li>
</ul>
<p>当然，这样做也会带来风险：</p>
<ul>
<li><strong>数据可能会丢失：</strong> 执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个数据就会有丢失的风险。</li>
<li><strong>可能阻塞其他操作：</strong> 由于写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前命令的执行，但因为 AOF 日志也是在主线程中执行，所以当 Redis 把日志文件写入磁盘的时候，还是会阻塞后续的操作无法执行。</li>
</ul>
<p>AOF 写回策略有几种？</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/98987d9417b2bab43087f45fc959d32a-20230309232253633.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<blockquote>
<p>AOF 日志过大，会触发什么机制？</p>
</blockquote>
<p>AOF 日志是一个文件，随着执行的写操作命令越来越多，文件的大小会越来越大。 如果当 AOF 日志文件过大就会带来性能问题，比如重启 Redis 后，需要读 AOF 文件的内容以恢复数据，如果文件过大，整个恢复的过程就会很慢。</p>
<p><strong>所以，Redis 为了避免 AOF 文件越写越大，提供了 AOF 重写机制，当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件。</strong></p>
<p>AOF 重写机制是在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件。</p>
<h2 id="9、RDB-快照是如何实现的呢？"><a href="#9、RDB-快照是如何实现的呢？" class="headerlink" title="9、RDB 快照是如何实现的呢？"></a>9、RDB 快照是如何实现的呢？</h2><p>因为 AOF 日志记录的是操作命令，不是实际的数据，所以用 AOF 方法做故障恢复时，需要全量把日志都执行一遍，一旦 AOF 日志非常多，势必会造成 Redis 的恢复操作缓慢。</p>
<p>为了解决这个问题，Redis 增加了 RDB 快照。所谓的快照，就是记录某一个瞬间东西，比如当我们给风景拍照时，那一个瞬间的画面和信息就记录到了一张照片。</p>
<p>所以，<strong>RDB 快照就是记录某一个瞬间的内存数据，记录的是实际数据</strong>，而 <strong>AOF 文件记录的是命令操作的日志</strong>，而不是实际的数据。</p>
<p>因此在 Redis 恢复数据时， RDB 恢复数据的效率会比 AOF 高些，因为直接将 RDB 文件读入内存就可以，不需要像 AOF 那样还需要额外执行操作命令的步骤才能恢复数据。</p>
<blockquote>
<p>RDB 做快照时会阻塞线程吗？</p>
</blockquote>
<p>Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave，他们的区别就在于是否在「主线程」里执行：</p>
<ul>
<li>执行了 save 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，<strong>会阻塞主线程</strong>；</li>
<li>执行了 bgsave 命令，会创建一个子进程来生成 RDB 文件，这样可以<strong>避免主线程的阻塞</strong>；</li>
</ul>
<p>这里提一点，Redis 的快照是<strong>全量快照</strong>，也就是说每次执行快照，都是把内存中的「<strong>所有数据</strong>」都记录到磁盘中。所以执行快照是一个比较重的操作，如果频率太频繁，可能会对 Redis 性能产生影响。如果频率太低，服务器故障时，丢失的数据会更多。</p>
<blockquote>
<p>RDB 在执行快照的时候，数据能修改吗？</p>
</blockquote>
<p><strong>可以的</strong>，执行 bgsave 过程中，Redis 依然<strong>可以继续处理操作命令</strong>的，也就是数据是能被修改的，关键的技术就在于<strong>写时复制技术（Copy-On-Write, COW）。</strong></p>
<p>执行 bgsave 命令的时候，会通过 fork() 创建子进程，此时子进程和父进程是<strong>共享同一片内存数据</strong>的，因为创建子进程的时候，会复制父进程的页表，但是页表指向的物理内存还是一个，此时如果主线程执行<strong>读操作</strong>，则主线程和 bgsave 子进程互相不影响。如果主线程执行<strong>写操作</strong>，则被修改的数据会复制一份副本，然后 bgsave 子进程会把该副本数据写入 RDB 文件，在这个过程中，主线程仍然可以直接修改原来的数据。</p>
<h2 id="10、为什么会有混合持久化？"><a href="#10、为什么会有混合持久化？" class="headerlink" title="10、为什么会有混合持久化？"></a>10、为什么会有混合持久化？</h2><p>RDB 优点是数据恢复速度快，但是快照的频率不好把握。频率太低，丢失的数据就会比较多，频率太高，就会影响性能。</p>
<p>AOF 优点是丢失数据少，但是数据恢复不快。</p>
<p>为了集成了两者的优点， Redis 4.0 提出了<strong>混合使用 AOF 日志和内存快照</strong>，也叫混合持久化，既保证了 Redis 重启速度，又降低数据丢失风险。</p>
<p>混合持久化工作在 <strong>AOF 日志重写过程</strong>，当开启了混合持久化时，在 AOF 重写日志时，fork 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的AOF 文件。</p>
<p>也就是说，使用了混合持久化，AOF 文件的<strong>前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据</strong>，这样的好处在于，重启 Redis 加载数据的时候，由于前半部分是 RDB 内容，这样<strong>加载的时候速度会很快</strong>。</p>
<p>加载完 RDB 的内容后，才会加载后半部分的 AOF 内容，这里的内容是 Redis 后台子进程重写 AOF 期间，主线程处理的操作命令，可以使得<strong>数据更少的丢失</strong>。</p>
<p><strong>混合持久化优点：</strong></p>
<ul>
<li>混合持久化结合了 RDB 和 AOF 持久化的优点，开头为 RDB 的格式，使得 Redis 可以更快的启动，同时结合 AOF 的优点，有减低了大量数据丢失的风险。</li>
</ul>
<p><strong>混合持久化缺点：</strong></p>
<ul>
<li>AOF 文件中添加了 RDB 格式的内容，使得 AOF 文件的可读性变得很差；</li>
<li>兼容性差，如果开启混合持久化，那么此混合持久化 AOF 文件，就不能用在 Redis 4.0 之前版本了。</li>
</ul>
<h2 id="11、大Key对AOF重写和RDB快照的影响（大key对持久化的影响）"><a href="#11、大Key对AOF重写和RDB快照的影响（大key对持久化的影响）" class="headerlink" title="11、大Key对AOF重写和RDB快照的影响（大key对持久化的影响）"></a>11、大Key对AOF重写和RDB快照的影响（大key对持久化的影响）</h2><p>当 AOF 写回策略配置了 Always 策略，如果写入是一个大 Key，主线程在执行 fsync() 函数的时候，阻塞的时间会比较久，因为当写入的数据量很大的时候，数据同步到硬盘这个过程是很耗时的。</p>
<p>AOF 重写机制和 RDB 快照（bgsave 命令）的过程，都会分别通过 <code>fork()</code> 函数创建一个子进程来处理任务。会有两个阶段会导致阻塞父进程（主线程）：</p>
<ul>
<li>创建子进程的途中，由于要复制父进程的页表等数据结构，阻塞的时间跟页表的大小有关，页表越大，阻塞的时间也越长；</li>
<li>创建完子进程后，如果父进程修改了共享数据中的大 Key，就会发生写时复制，这期间会拷贝物理内存，由于大 Key 占用的物理内存会很大，那么在复制物理内存这一过程，就会比较耗时，所以有可能会阻塞父进程。</li>
</ul>
<p>大 key 除了会影响持久化之外，还会有以下的影响。</p>
<ul>
<li>客户端超时阻塞。由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。</li>
<li>引发网络阻塞。每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。</li>
<li>阻塞工作线程。如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。</li>
<li>内存分布不均。集群模型在 slot 分片均匀情况下，会出现数据和查询倾斜情况，部分有大 key 的 Redis 节点占用内存多，QPS 也会比较大。</li>
</ul>
<p>如何避免大 Key 呢？</p>
<p>最好在设计阶段，就把大 key 拆分成一个一个小 key。或者，定时检查 Redis 是否存在大 key ，如果该大 key 是可以删除的，不要使用 DEL 命令删除，因为该命令删除过程会阻塞主线程，而是用 unlink 命令（Redis 4.0+）删除大 key，因为该命令的删除过程是异步的，不会阻塞主线程。</p>
<h2 id="12、什么是缓存雪崩、击穿、穿透？"><a href="#12、什么是缓存雪崩、击穿、穿透？" class="headerlink" title="12、什么是缓存雪崩、击穿、穿透？"></a>12、什么是缓存雪崩、击穿、穿透？</h2><p>1、缓存雪崩</p>
<p>通常我们为了保证缓存中的数据与数据库中的数据一致性，会给 Redis 里的数据设置过期时间，当缓存数据过期后，用户访问的数据如果不在缓存里，业务系统需要重新生成缓存，因此就会访问数据库，并将数据更新到 Redis 里，这样后续请求都可以直接命中缓存。那么，当<strong>大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机</strong>时，如果此时有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃，这就是<strong>缓存雪崩</strong>的问题。</p>
<p>可以看到，发生缓存雪崩有两个原因：</p>
<p>一、大量数据同时过期；</p>
<p><em>1. 均匀设置过期时间</em></p>
<p>如果要给缓存数据设置过期时间，应该避免将大量的数据设置成同一个过期时间。我们可以在对缓存数据设置过期时间时，<strong>给这些数据的过期时间加上一个随机数</strong>，这样就保证数据不会在同一时间过期。</p>
<p><em>2. 互斥锁</em></p>
<p>当业务线程在处理用户请求时，<strong>如果发现访问的数据不在 Redis 里，就加个互斥锁，保证同一时间内只有一个请求来构建缓存</strong>（从数据库读取数据，再将数据更新到 Redis 里），当缓存构建完成后，再释放锁。未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</p>
<p>实现互斥锁的时候，最好设置<strong>超时时间</strong>，不然第一个请求拿到了锁，然后这个请求发生了某种意外而一直阻塞，一直不释放锁，这时其他请求也一直拿不到锁，整个系统就会出现无响应的现象。</p>
<p><em>3. 后台更新缓存</em></p>
<p>业务线程不再负责更新缓存，缓存也不设置有效期，而是<strong>让缓存“永久有效”，并将更新缓存的工作交由后台线程定时更新</strong>。</p>
<p>二、Redis 故障宕机；</p>
<p><em>1. 服务熔断或请求限流机制</em></p>
<p>因为 Redis 故障宕机而导致缓存雪崩问题时，我们可以启动<strong>服务熔断</strong>机制，<strong>暂停业务应用对缓存服务的访问，直接返回错误</strong>，不用再继续访问数据库，从而降低对数据库的访问压力，保证数据库系统的正常运行，然后等到 Redis 恢复正常后，再允许业务应用访问缓存服务。</p>
<p>服务熔断机制是保护数据库的正常允许，但是暂停了业务应用访问缓存服系统，全部业务都无法正常工作</p>
<p>为了减少对业务的影响，我们可以启用<strong>请求限流</strong>机制，<strong>只将少部分请求发送到数据库进行处理，再多的请求就在入口直接拒绝服务</strong>，等到 Redis 恢复正常并把缓存预热完后，再解除请求限流的机制。</p>
<p><em>2. 构建 Redis 缓存高可靠集群</em></p>
<p>服务熔断或请求限流机制是缓存雪崩发生后的应对方案，我们最好通过<strong>主从节点的方式构建 Redis 缓存高可靠集群</strong>。</p>
<p>如果 Redis 缓存的主节点故障宕机，从节点可以切换成为主节点，继续提供缓存服务，避免了由于 Redis 故障宕机而导致的缓存雪崩问题。</p>
<p>2、缓存击穿</p>
<p>我们的业务通常会有几个数据会被频繁地访问，比如秒杀活动，这类<strong>被频地访问的数据被称为热点数据。</strong></p>
<p>如果缓存中的<strong>某个热点数据过期</strong>了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，这就是<strong>缓存击穿</strong>的问题。缓存击穿跟缓存雪崩很相似，你可以认为缓存击穿是缓存雪崩的一个子集。</p>
<p>应对缓存击穿可以采取前面说到两种方案：</p>
<ul>
<li><strong>互斥锁方案</strong>，保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</li>
<li><strong>不给热点数据设置过期时间</strong>，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间；</li>
</ul>
<p>3、缓存穿透</p>
<p>当发生缓存雪崩或击穿时，数据库中还是保存了应用要访问的数据，一旦缓存恢复相对应的数据，就可以减轻数据库的压力，而缓存穿透就不一样了。</p>
<p>当用户访问的数据，<strong>既不在缓存中，也不在数据库中</strong>，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求。那么当有大量这样的请求到来时，数据库的压力骤增，这就是<strong>缓存穿透</strong>的问题。</p>
<p>缓存穿透的发生一般有这两种情况：</p>
<ul>
<li>业务误操作，缓存中的数据和数据库中的数据都被误删除了，所以导致缓存和数据库中都没有数据；</li>
<li>黑客恶意攻击，故意大量访问某些读取不存在数据的业务；</li>
</ul>
<p>应对缓存穿透的方案，常见的方案有三种。</p>
<ul>
<li>第一种方案，非法请求的限制；</li>
<li>第二种方案，缓存空值或者默认值；</li>
<li>第三种方案，使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在；</li>
</ul>
<h1 id="C-语言基础"><a href="#C-语言基础" class="headerlink" title="C++语言基础"></a>C++语言基础</h1><h2 id="1、虚函数与纯虚函数的区别"><a href="#1、虚函数与纯虚函数的区别" class="headerlink" title="1、虚函数与纯虚函数的区别"></a>1、虚函数与纯虚函数的区别</h2><p><strong>虚函数</strong> </p>
<p>有实现： 虚函数有函数声明和实现，即在基类中可以提供默认实现。 </p>
<p>可选实现： 派⽣类可以选择是否覆盖虚函数。如果派⽣类没有提供实现，将使⽤基类的默认实现。 </p>
<p>允许实例化： 虚函数的类可以被实例化。即你可以创建⼀个虚函数的类的对象。 调⽤靠对象类型决定： 在运⾏时，根据对象的实际类型来决定调⽤哪个版本的虚函数。 </p>
<p>⽤ virtual 关键字声明： 虚函数使⽤ virtual 关键字声明，但不包含 &#x3D; 0 。</p>
<p><strong>纯虚函数</strong> </p>
<p>没有实现： 纯虚函数没有函数体，只有函数声明，即没有提供默认的实现。 </p>
<p>强制覆盖： 派⽣类必须提供纯虚函数的具体实现，否则它们也会成为<strong>抽象类</strong>。 </p>
<p>禁⽌实例化： 包含纯虚函数的类⽆法被实例化，只能⽤于派⽣其他类。</p>
<p>⽤ &#x3D; 0 声明： 纯虚函数使⽤ &#x3D; 0 在函数声明末尾进⾏声明。</p>
<p> 为接⼝提供规范： 通过纯虚函数，抽象类提供⼀种接⼝规范，要求派⽣类提供相关实现。</p>
<h2 id="2、CPP怎么实现多态？"><a href="#2、CPP怎么实现多态？" class="headerlink" title="2、CPP怎么实现多态？"></a>2、CPP怎么实现多态？</h2><p>1、函数重载：通过在同一个作用域内定义多个同名函数，但是参数类型和数量不同，编译器会根据调用时提供的参数来决定调用哪个函数版本。</p>
<p>2、运算符重载：允许定义或修改大部分运算符的默认行为。</p>
<p>3、模板：通过模板函数或模板类，可以编写泛型代码，实现对多种类型的操作，而无需知道这些类型的具体细节。</p>
<p>4、抽象基类：使用包含纯虚函数的类作为接口，强制派生类提供纯虚函数的具体实现。</p>
<p>5、动态多态：除了虚函数外，还可以通过指针或引用传递基类类型的对象，而在运行时根据对象的实际类型来调用相应的成员函数，这通常与虚函数一起使用。</p>
<p>6、静态多态：也称为编译时多态，包括函数重载和模版，由于在编译时已经确定了调用哪个函数，所以称为静态多态。</p>
<h2 id="3、new-和-malloc的区别"><a href="#3、new-和-malloc的区别" class="headerlink" title="3、new 和 malloc的区别"></a>3、new 和 malloc的区别</h2><p>1、new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。</p>
<p>  2、使⽤new操作符申请内存分配时⽆须指定内存块的⼤⼩，⽽malloc则需要显式地指出所需内存的尺⼨。 </p>
<p> 3、opeartor new &#x2F;operator delete可以被重载，⽽malloc&#x2F;free并不允许重载。 </p>
<p> 4、new&#x2F;delete会调⽤对象的构造函数&#x2F;析构函数以完成对象的构造&#x2F;析构。⽽malloc则不会  </p>
<p>5、malloc与free是C++&#x2F;C语⾔的标准库函数,new&#x2F;delete是C++的运算符  </p>
<p>6、new操作符从⾃由存储区上为对象动态分配内存空间，⽽malloc函数从堆上动态分配内存。</p>
<h2 id="4、讲一讲封装、继承、多态是什么？"><a href="#4、讲一讲封装、继承、多态是什么？" class="headerlink" title="4、讲一讲封装、继承、多态是什么？"></a>4、讲一讲封装、继承、多态是什么？</h2><p><strong>封装：</strong>将一个功能或者方法的实现过程以及所需要的数据封装成一个函数，对外提供一个公共的访问接口以供其他程序调用，降低耦合性。这么做使得类成为一个具有内部数据自我隐藏能力、功能独立的软件模块。</p>
<p>意义：保护类中的成员，保护或者防止代码在无意中被破坏，避免了让类外成员直接访问或修改类中的数据，只能通过类提供的接口进行访问。</p>
<p><strong>继承：</strong>子类可以继承父类的特征和行为，可以复用基类（父类）的全体数据和成员函数具有从基类（父类）复制而来的成员数据和成员函数。（基类的私有成员可以被继承，但是无法被访问）。其中<strong>构造函数、析构函数、友元函数、静态数据成员、静态成员函数</strong>都不能被继承。基类中成员的访问方式只能决定派生类能否访问它们。增强了代码耦合性，当父类中的成员变量或者类本身被final关键字修饰时，修饰的类不能被继承，修饰的成员变量不能重写或修改。</p>
<p>意义：基类的程序代码可以被派生类服用，提高了软件复用的效率，缩短了软件开发的周期。</p>
<p><strong>多态：</strong>不同继承类的对象对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现形式。</p>
<p>意义：对已存在的代码具有可替代性，对代码具有可扩充性，新增子类不会影响已存在类的各种性质，在程序中体现了灵活多样的操作，提高了使用效率，简化了对应用代码的编写和修改过程。</p>
<h2 id="5、多态的实现原理（实现方式）是什么？以及多态的优点（特点）？"><a href="#5、多态的实现原理（实现方式）是什么？以及多态的优点（特点）？" class="headerlink" title="5、多态的实现原理（实现方式）是什么？以及多态的优点（特点）？"></a>5、多态的实现原理（实现方式）是什么？以及多态的优点（特点）？</h2><p>实现方式：多态分为动态多态（动态多态是利用虚函数实现运行时的多态，即在系统编译的时候并不知道程序将要调用哪一个函数，只有在运行到这里的时候才能确定接下来会跳转到哪一个函数。）和静态多态（又称编译期多态，即在系统编译期间就可以确定程序将要执行哪个函数），其中动态多态是通过虚函数实现的，虚函数是类的成员函数，存储虚函数指针的表叫做虚函数表，虚函数表是一个存储类成员虚函数的指针，每个指针都指向调用它的地方，当子类调用虚函数时，就会去虚表里面找自己对应的函数指针，从而实现“谁调用、实现谁”从而实现多态。而静态多态则是通过函数重载（函数名相同，参数不同，两个函数在同一作用域），运算符重载，和重定义（又叫隐藏，指的是在继承关系中，子类实现了一个和父类名字一样的函数，（只关注函数名，和参数与返回值无关）这样的话子类的函数就把父类的同名函数隐藏了。隐藏只与函数名有关，与参数没有关系）来实现的。</p>
<p>优点：加强代码的可扩展性，可替换性，增强程序的灵活性，提高使用效率，简化对应用代码的编写和修改过程。</p>
<h2 id="6、final标识符的作用是什么"><a href="#6、final标识符的作用是什么" class="headerlink" title="6、final标识符的作用是什么"></a>6、final标识符的作用是什么</h2><p>放在类的后面表示该类无法被继承，也就是阻止了从类的继承，放在虚函数后面该虚函数无法被重写，表示阻止虚函数的重载</p>
<h2 id="7、虚函数是怎么实现的？它存放在哪里在内存的哪个区？什么时候生成的"><a href="#7、虚函数是怎么实现的？它存放在哪里在内存的哪个区？什么时候生成的" class="headerlink" title="7、虚函数是怎么实现的？它存放在哪里在内存的哪个区？什么时候生成的"></a>7、虚函数是怎么实现的？它存放在哪里在内存的哪个区？什么时候生成的</h2><p>在C++中，虚函数的实现原理基于两个关键概念：虚函数表和虚函数指针</p>
<p>虚函数表：每个包含虚函数的类都会生成一个虚函数表，其中存储着该类中所有虚函数的地址。虚函数表是一个由指针构成的数组，每个指针指向一个虚函数的实现代码。</p>
<p>虚函数指针：在对象的内存布局中，编译器会添加一个额外的指针，称为虚函数指针或虚表指针。这个指针指向该对象对应的虚函数表，从而让程序能够动态的调用虚函数。</p>
<p>当一个基类指针或引用调用虚函数时，编译器会使用虚表指针来查找该对象对应的虚函数表，并根据函数在虚函数表中的位置来调用正确的虚函数。</p>
<p>在编译阶段生成，虚函数和普通函数一样存放在代码段，只是它的指针又存放在了虚表之中。</p>
<h2 id="8、智能指针的本质是什么，它们的实现原理是什么？"><a href="#8、智能指针的本质是什么，它们的实现原理是什么？" class="headerlink" title="8、智能指针的本质是什么，它们的实现原理是什么？"></a>8、智能指针的本质是什么，它们的实现原理是什么？</h2><p>智能指针本质是一个封装了一个原始C++指针的类模板，为了确保动态内存的安全性而产生的。实现原理是通过一个对象存储需要被自动释放的资源，然后依靠对象的析构函数来释放资源。</p>
<p>智能指针⽤于管理动态内存的对象，其主要⽬的是在避免内存泄漏和⽅便资源管理。</p>
<p>分为独占智能指针、共享智能指针和弱引用智能指针。</p>
<p>std::unique_ptr （独占智能指针）提供对动态分配的单⼀对象所有权的独占管理。通过独占所有权，确保只有⼀个 std::unique_ptr 可以拥有指定的内存资源。移动语义和右值引⽤允许 std::unique_ptr 在所有权转移时⾼ 效地进⾏转移。</p>
<p>std::shared_ptr （共享智能指针）允许多个智能指针共享同⼀块内存资源。内部使⽤引⽤计数来跟踪对象被共享的次数，当计数 为零时，资源被释放。提供更灵活的内存共享，但可能存在循环引⽤的问题。</p>
<p>std::weak_ptr （弱引用智能指针）⽤于解决 std::shared_ptr 可能导致的循环引⽤问题。 std::weak_ptr 可以从 std::shared_ptr 创建，但不会增加引⽤计数，不会影响资源的释放。 通过 std::weak_ptr::lock() 可以获取⼀个 std::shared_ptr 来访问资源。</p>
<h2 id="9、匿名函数的本质是什么？他的优点是什么？"><a href="#9、匿名函数的本质是什么？他的优点是什么？" class="headerlink" title="9、匿名函数的本质是什么？他的优点是什么？"></a>9、匿名函数的本质是什么？他的优点是什么？</h2><p>匿名函数本质上是一个对象，在其定义的过程中会创建出一个栈对象，内部通过<strong>重载()符号</strong>实现函数调用的外表。</p>
<p>优点：使用匿名函数，可以免去函数的声明和定义。这样匿名函数仅在调用函数的时候才会创建函数对象，而调用结束后立即释放，所以匿名函数比非匿名函数更节省空间。</p>
<h2 id="10、delete-和-free-有什么区别？"><a href="#10、delete-和-free-有什么区别？" class="headerlink" title="10、delete 和 free 有什么区别？"></a>10、delete 和 free 有什么区别？</h2><p>类型安全性： delete 会调⽤对象的析构函数，确保资源被正确释放。 free 不了解对象的构造和析构，只是简单地释放内存块。 </p>
<p>内存块释放后的⾏为： delete 释放的内存块的指针值会被设置为 nullptr ，以避免ᰀ指针。 free 不会修改指针的值，可能导致ᰀ指针问题。 </p>
<p>数组的释放： delete 可以正确释放通过 new[] 分配的数组。 free 不了解数组的⼤⼩，不适⽤于释放通过 malloc 分配的数组。</p>
<h2 id="11、什么是野指针，如何产生以及如何避免？"><a href="#11、什么是野指针，如何产生以及如何避免？" class="headerlink" title="11、什么是野指针，如何产生以及如何避免？"></a>11、什么是野指针，如何产生以及如何避免？</h2><p>野指针是指指向已被释放或无效的的内存地址的指针，使用野指针可能会导致程序崩溃、数据损坏或其他不可预测的行为。通常由以下几种情况产生：</p>
<p>1、释放后没有置空指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span>* ptr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br><span class="hljs-keyword">delete</span> ptr;<br><span class="hljs-comment">// 此时 ptr 成为ᰀ指针，因为它仍然指向已经被释放的内存</span><br>ptr = <span class="hljs-literal">nullptr</span>; <br></code></pre></td></tr></table></figure>

<p>2、返回局部变量的指针（局部变量在函数调用后被销毁，返回的指针成为了野指针&#x2F;悬浮指针）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">createInt</span><span class="hljs-params">()</span> </span>&#123;<br> <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br> <span class="hljs-keyword">return</span> &amp;x; <span class="hljs-comment">// x 是局部变ᰁ，函数结束后 x 被销毁，返回的指针成为野指针</span><br>&#125;<br><span class="hljs-comment">// 在使⽤返回值时可能引发未定义⾏为</span><br></code></pre></td></tr></table></figure>

<p>3、释放内存后没有调整指针指向（同1）</p>
<p>4、函数参数指针被释放</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>* ptr)</span> </span>&#123;<br> <span class="hljs-comment">// 操作 ptr</span><br> <span class="hljs-keyword">delete</span> ptr;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br> <span class="hljs-type">int</span>* ptr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br> <span class="hljs-built_in">foo</span>(ptr);<br> <span class="hljs-comment">// 在 foo 函数中 ptr 被释放，但在 main 函数中仍然可⽤，成为野指针</span><br> <span class="hljs-comment">// 避免：在 foo 函数中不要释放调⽤⽅传递的指针</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>对应的解决方法以及避免野指针的方法：</p>
<p>1、释放内存后将指针设置为nullptr；2、避免返回局部变量的指针；3、使用智能指针；4、注意函数参数的生命周期，避免在函数内释放调用方传递的指针。</p>
<h2 id="12、野指针和悬浮指针的区别"><a href="#12、野指针和悬浮指针的区别" class="headerlink" title="12、野指针和悬浮指针的区别"></a>12、野指针和悬浮指针的区别</h2><p>野指针是指向已经被释放或者⽆效的内存地址的指针。通常由于指针指向的内存被释放，但指针本身没有被置为 nullptr 或者重新分配有效的内存，导致指针仍然包含之前的内存地址。使⽤野指针进⾏访问会导致未定义⾏ 为，可能引发程序崩溃、数据损坏等问题。</p>
<p> 悬浮指针是<strong>指向已经被销毁的对象的引⽤</strong>。当函数返回⼀个局部变量的引⽤，⽽调⽤者使⽤该引⽤时，就可能产⽣ 悬浮引⽤。访问悬浮引⽤会导致未定义⾏为，因为引⽤指向的对象已经被销毁，数据不再有效。</p>
<h2 id="13、说说C-的内存分配方式"><a href="#13、说说C-的内存分配方式" class="headerlink" title="13、说说C++的内存分配方式"></a>13、说说C++的内存分配方式</h2><p>（1）从静态存储区域分配：内存在程序编译的时候就已经分配好，这块内存在程序的整个运⾏期间都存在，如全局变量，static变量。 </p>
<p>（2）在栈上创建：在执⾏函数时，函数内局部变量的存储单元都可以在栈上创建，函数执⾏结束时这些存储单元⾃动被释放。栈内存 分配运算内置于处理器的指令集中，效率很⾼，但是分配的内存容量有限。 </p>
<p>（3）从堆上分配(动态内存分配) 程序在运⾏的时候⽤malloc或new申请任意多少的内存，程序员负责在何时⽤free或delete释放内存。动态内存的⽣存期⾃⼰决定，使⽤⾮常灵活。</p>
<h2 id="14、成员函数、成员变量、静态成员变量、静态成员函数的区别成员函数"><a href="#14、成员函数、成员变量、静态成员变量、静态成员函数的区别成员函数" class="headerlink" title="14、成员函数、成员变量、静态成员变量、静态成员函数的区别成员函数"></a>14、成员函数、成员变量、静态成员变量、静态成员函数的区别成员函数</h2><p>1、成员函数</p>
<p>是属于类的函数，它们可以访问类的成员变量和其他成员函数。 成员函数可以分为普通成员函数和静态成员函数。 普通成员函数使⽤对象调⽤，可以访问对象的成员变量。 普通成员函数的声明和定义通常在类的内部，但定义时需要使⽤类名作为限定符。</p>
<p>2、成员变量</p>
<p>成员变量是属于类的变量，存储在类的每个对象中。 每个对象拥有⼀份成员变量的副本，它们在对象创建时分配，并在对象销毁时释放。 成员变量的访问权限可以是 public 、 private 或 protected 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br> <span class="hljs-type">int</span> memberVariable; <span class="hljs-comment">// 成员变量的声明</span><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">memberFunction</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// 普通成员函数使用对象调用</span><br> <span class="hljs-comment">// 成员函数的实现</span><br> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>3、静态成员函数</p>
<p> 静态成员函数属于类⽽不是对象，因此可以直接通过类名调⽤，⽽不需要创建类的实例。 静态成员函数不能直接访问普通成员变量，因为它们没有隐含的 this 指针。 静态成员函数的声明和定义也通常在类的内部，但在定义时需要使⽤类名作为限定符。</p>
<p>4、 静态成员变量</p>
<p> 静态成员变量是属于类⽽不是对象的变量，它们在所有对象之间共享。 静态成员变量通常在类的声明中进⾏声明，但在类的定义外进⾏定义和初始化。 静态成员变量可以通过类名或对象访问。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br> <span class="hljs-type">static</span> <span class="hljs-type">int</span> staticMemberVariable; <span class="hljs-comment">// 静态成员变量的声明</span><br> <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">staticMemberFunction</span><span class="hljs-params">()</span> </span>&#123;<br> <span class="hljs-comment">// 静态成员函数的实现</span><br> &#125;<br>&#125;;<br><span class="hljs-type">int</span> MyClass::staticMemberVariable = <span class="hljs-number">0</span>;<span class="hljs-comment">// 静态成员变量的定义和初始化</span><br></code></pre></td></tr></table></figure>

<h2 id="15、什么是抽象类和纯虚函数？（接1）"><a href="#15、什么是抽象类和纯虚函数？（接1）" class="headerlink" title="15、什么是抽象类和纯虚函数？（接1）"></a>15、什么是抽象类和纯虚函数？（接1）</h2><p>抽象类是不能被实例化的类，它存在的主要⽬的是为了提供⼀个接⼝，供派⽣类继承和实现。抽象类中可以包含普通的成员函数、数据成员和构造函数，但它必须<strong>包含⾄少⼀个纯虚函数</strong>。即在声明中使⽤ virtual 关键字并赋予 函数⼀个 &#x3D; 0 的纯虚函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractShape</span> &#123;<br><span class="hljs-keyword">public</span>:<br> <span class="hljs-comment">// 纯虚函数，提供接⼝</span><br> <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br> <span class="hljs-comment">// 普通成员函数</span><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">commonFunction</span><span class="hljs-params">()</span> </span>&#123;<br> <span class="hljs-comment">// 具体实现</span><br> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>纯虚函数是在抽象类中声明的虚函数，它<strong>没有具体的实现，只有函数的声明</strong>。通过在函数声明的末尾使⽤ &#x3D; 0 ， 可以将虚函数声明为纯虚函数。派⽣类必须实现抽象类中的纯虚函数，否则它们也会成为抽象类。</p>
<h2 id="16、为什么有虚析构函数，没有虚构造函数？"><a href="#16、为什么有虚析构函数，没有虚构造函数？" class="headerlink" title="16、为什么有虚析构函数，没有虚构造函数？"></a>16、为什么有虚析构函数，没有虚构造函数？</h2><p><strong>虚析构函数</strong>是⼀个带有 virtual 关键字的析构函数。 主要作⽤是确保在通过基类指针删除派⽣类对象时，能够正确调⽤派⽣类的析构函数，从⽽释放对象所占⽤的资源。 通常，如果⼀个类可能被继承，且在其派⽣类中有可能使⽤ delete 运算符来删除通过基类指针指向的对象，那么该基类的析构函数应该声明为虚析构函数。</p>
<p>因此，<strong>虚析构函数</strong>的作用是：</p>
<p>1、允许在<strong>运行的时候</strong>根据对象的实际类型调用正确的析构函数，从而实现多态性。</p>
<p><strong>2、如果基类的析构函数不是虚函数，当通过基类指针删除指向派生类的对象时，只会调用基类的析构函数，不会调用派生类的析构函数，可能会导致派生类的资源未被正确释放，造成内存泄漏。</strong></p>
<p>构造函数在对象的<strong>创建阶段</strong>被调⽤，对象的类型在构造函数中已经确定。因此，构造函数调⽤不涉及多态性，也就 是说，在对象的构造期间⽆法实现动态绑定。虚构造函数没有意义，因为对象的类型在构造过程中就已经确定，不需要动态地选择构造函数。</p>
<p>1、从存储空间⻆度：虚函数对应⼀个vtable,这个表的地址是存储在对象的内存空间的。如果将构造函数设置为虚函数，就需要到vtable 中调⽤，可是对象还没有实例化，没有内存空间分配，如何调⽤。（悖论）</p>
<p> 2、从使⽤⻆度：虚函数主要⽤于在信息不全的情况下，能使重载的函数得到对应的调⽤。构造函数本身就是要初 始化实例，那使⽤虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。虚函数的作⽤在于通过⽗类的 指针或者引⽤来调⽤它的时候能够变成调⽤⼦类的那个成员函数。⽽构造函数是在创建对象时⾃动调⽤的，不可能通过⽗类的指针或者引⽤去调⽤，因此也就规定构造函数不能是虚函数。 </p>
<p>3、从实现上看，vtable 在构造函数调⽤后才建⽴，因⽽构造函数不可能成为虚函数。从实际含义上看，在调⽤构造 函数时还不能确定对象的真实类型（因为⼦类会调⽗类的构造函数）；⽽且构造函数的作⽤是提供初始化，在对象⽣命期只执⾏⼀次，不是对象的动态⾏为，也没有太⼤的必要成为虚函数。</p>
<h2 id="17、哪些函数不能被声明为虚函数？"><a href="#17、哪些函数不能被声明为虚函数？" class="headerlink" title="17、哪些函数不能被声明为虚函数？"></a>17、哪些函数不能被声明为虚函数？</h2><p>构造函数：在对象创建时调用，对象的类型在创建时期已经确定，虚函数是在运行阶段动态绑定，二者矛盾。</p>
<p>普通函数（非成员函数），在编译阶段绑定，只能重载，不能重写。</p>
<p>静态成员函数：对于每一个类都只有一份代码，共享，不需要动态绑定。</p>
<p>友元函数：C++不支持友元函数的继承，对于没有继承性质的函数没有虚函数的说法。</p>
<p>内联成员函数：内联函数就是为了在代码中直接展开，减少函数调⽤花费的代价，虚函数是为了在继承后对象能够准确的执⾏⾃⼰ 的动作，这是不可能统⼀的。（再说了，inline函数在编译时被展开，虚函数在运⾏时才能动态的绑定函数）</p>
<h2 id="18、深拷贝和浅拷贝的区别"><a href="#18、深拷贝和浅拷贝的区别" class="headerlink" title="18、深拷贝和浅拷贝的区别"></a>18、深拷贝和浅拷贝的区别</h2><p>主要区别是如何处理对象内部动态分配的资源。</p>
<p>1、深拷贝：</p>
<p>深拷⻉是对对象的完全独⽴复制，包括对象内部动态分配的资源。在深拷⻉中，不仅复制对象的值，还会复制对象 所指向的堆上的数据。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DeepCopyExample</span> &#123;<br><span class="hljs-keyword">public</span>:<br> <span class="hljs-type">int</span> *data;<br> <span class="hljs-built_in">DeepCopyExample</span>(<span class="hljs-type">const</span> DeepCopyExample &amp;other) &#123;<br> <span class="hljs-comment">// ⼿动分配内存并复制数据</span><br> data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*(other.data));<br> &#125;<br> ~<span class="hljs-built_in">DeepCopyExample</span>() &#123;<br> <span class="hljs-comment">// 释放动态分配的资源</span><br> <span class="hljs-keyword">delete</span> data;<br> &#125;<br> DeepCopyExample&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> DeepCopyExample &amp;other) &#123;<span class="hljs-comment">// 重载 = 号 用于深拷贝的赋值</span><br> <span class="hljs-comment">// 复制数据</span><br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br> <span class="hljs-keyword">delete</span> data;<br> data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*(other.data));<br> &#125;<br> <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>2、 浅拷⻉ ：</p>
<p>浅拷⻉仅复制对象的值，⽽不涉及对象内部动态分配的资源。在浅拷⻉中，新对象和原对象共享相同的资源，⽽不 是复制⼀份新的资源。</p>
<h2 id="19、什么是STL（标准模板库），包含哪些组件？"><a href="#19、什么是STL（标准模板库），包含哪些组件？" class="headerlink" title="19、什么是STL（标准模板库），包含哪些组件？"></a>19、什么是STL（标准模板库），包含哪些组件？</h2><p><strong>⼴义上讲</strong>，STL分为3类：Algorithm（算法）、Container（容器）和Iterator（迭代器），容器和算法通过迭代器 可以进⾏⽆缝地连接。 </p>
<p>详细的说，STL由6部分组成：容器(Container)、算法（Algorithm）、 迭代器（Iterator）、仿函数（Function object）、适配器（Adaptor）、空间配制器（Allocator）。 STL提供了六⼤组件，彼此之间可以组合套⽤，这六⼤组件分别是:容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器。</p>
<p>  STL六⼤组件的交互关系：</p>
<p>1、容器通过空间配置器取得数据存储空间 </p>
<p>2、算法通过迭代器存储容器中的内容  </p>
<p>3、仿函数可以协助算法完成不同的策略的变化  </p>
<p>4、适配器可以修饰仿函数</p>
<p>容器: vector map list deque set等用来存放数据，从实现角度看是一种类模板（class template）</p>
<p>算法：sort find for_each copy等，从实现角度来看，是一种函数模板（function template）</p>
<p>迭代器：扮演着容器与算法之间的粘合剂，从实现⻆度来看，迭代器是⼀种将operator* , operator-&gt; , operator++,operator–等指针相关操作予以重载的class template。（类模板）</p>
<p>仿函数：⾏为类似函数，可作为算法的某种策略。从实现⻆度来看，仿函数是⼀种重载了operator()的class 或者class template </p>
<p>适配器：用来修饰容器、仿函数、或迭代器的接口</p>
<p>STL提供的queue 和 stack，虽然看似容器，但其实只能算是⼀种容器配接器，因为它们的底部完全借助deque， 所有操作都由底层的deque供应。</p>
<p>空间配置器：负责空间的配置与管理。从实现⻆度看，配置器是⼀个实现了动态空间配置、空间管理、空间释放的class template.  ⼀般的分配器的std:alloctor都含有两个函数allocate与deallocte，这两个函数分别调⽤operator new()与 delete()，这两个函数的底层⼜分别是malloc()and free();但是每次malloc会带来格外开销（因为每次malloc⼀个元素都要带有附加信息）</p>
<h2 id="20、STL的优点"><a href="#20、STL的优点" class="headerlink" title="20、STL的优点"></a>20、STL的优点</h2><p>STL具有高可重用性、高性能、高移植性、跨平台的优点。</p>
<p>1、高可重用性：STL中所有的代码都采用了模板类和模板函数的方式实现，相比于传统的由函数和类组成的库来说，提供了更好的代码重用机会。</p>
<p>2、高性能：例如map可以高效的从几十万的记录里面查出指定的记录，map底层采用红黑树实现。</p>
<p>3、高移植性</p>
<p>STL 的⼀个᯿要特性是将数据和操作分离 数据由容器类别加以管理，操作则由可定制的算法定义。迭代器在两者之间充当“粘合剂”,以使算法可以和容器交互 运作。</p>
<h2 id="21、vector和list的区别-（天美）"><a href="#21、vector和list的区别-（天美）" class="headerlink" title="21、vector和list的区别 （天美）"></a>21、vector和list的区别 （天美）</h2><p>1、 实现上 </p>
<p>vector 使⽤动态数组实现。连续的内存块，⽀持随机访问。在尾部进⾏插⼊&#x2F;删除操作较快，但在中间或头 部进⾏插⼊&#x2F;删除可能会涉及⼤量元素的移动。 </p>
<p>list 使⽤双向链表实现。不连续的内存块，不⽀持随机访问。在任意位置进⾏插⼊&#x2F;删除操作都是常数时间复杂度。</p>
<p>2、访问上 </p>
<p>vector⽀持通过索引进⾏快速随机访问。使⽤迭代器进⾏访问时，效率较⾼。 </p>
<p>List不⽀持通过索引进⾏快速随机访问。迭代器在访问时需要遍历链表，效率相对较低。 </p>
<p>3、插⼊和删除操作 </p>
<p>vector：在尾部进⾏插⼊&#x2F;删除操作是常数时间复杂度。在中间或头部进⾏插⼊&#x2F;删除可能涉及⼤量元素的移 动，时间复杂度为线性。 </p>
<p>List: 在任意位置进⾏插⼊&#x2F;删除操作都是常数时间复杂度，因为只需调整相邻节点的指针。 </p>
<p>4、内存管理 </p>
<p>Vector使⽤动态数组，需要在预估元素数量时分配⼀块较⼤的内存空间。</p>
<p> list由于采⽤链表结构，动态分配的内存⽐较灵活。每个元素都有⾃⼰的内存块，避免了预分配的问题。</p>
<p>5、适⽤场景 </p>
<p>Vector适⽤于需要频繁随机访问、在尾部进⾏插⼊&#x2F;删除操作的场景。</p>
<p> list适⽤于需要频繁在中间或头部进⾏插⼊&#x2F;删除操作、不要求随机访问的场景。</p>
<h2 id="22、Vector的实现原理"><a href="#22、Vector的实现原理" class="headerlink" title="22、Vector的实现原理"></a>22、Vector的实现原理</h2><p>std::vector 是C++标准库中的⼀个动态数组实现，它的实现原理基于<strong>数组数据结构</strong>。</p>
<p>实现通常包含⼀个指向数组起始位置的指针、数组的⼤⼩和容量等信息。 在尾部进⾏插⼊和删除操作时，只需调整尾部指针，不需要移动整个数据块。</p>
<p> 当元素数量达到当前内存块的容量时， std::vector 会申请⼀个更⼤的内存块，将元素从旧的内存块复制到新的 内存块，并释放旧的内存块。（一般是两倍内存大小）</p>
<p> <strong>由于数组的连续内存结构，通过索引进⾏访问时可以通过指针运算实现常数时间复杂度的随机访问。</strong></p>
<h2 id="23、list的实现原理"><a href="#23、list的实现原理" class="headerlink" title="23、list的实现原理"></a>23、list的实现原理</h2><p>std::list 是C++标准库中的⼀个双向链表实现，它的实现原理基于<strong>链表数据结构</strong>。</p>
<p>每个节点包含两个指针，分别指向前⼀个节点和后⼀个节点, 以及存储实际数据的部分。 std::list 维护⼀个头指针和⼀个尾指针，它们分别指向链表的第⼀个和最后⼀个节点。 </p>
<p>在插⼊和删除操作时，只需调整相邻节点的指针，不需要移动整个数据块。</p>
<h2 id="24、map-set的区别和实现原理"><a href="#24、map-set的区别和实现原理" class="headerlink" title="24、map &amp;&amp; set的区别和实现原理"></a>24、map &amp;&amp; set的区别和实现原理</h2><p> map内部实现了⼀个红⿊树（红⿊树是⾮严格平衡的⼆叉搜索树，⽽AVL是严格平衡⼆叉搜索树），红⿊树有⾃动 排序的功能，因此map内部所有元素都是有序的，红⿊树的每⼀个节点都代表着map的⼀个元素。因此，对于map 进⾏的查找、删除、添加等⼀系列的操作都相当于是对红⿊树进⾏的操作。map中的元素是按照⼆叉树（⼜名⼆叉 查找树、⼆叉排序树）存储的，特点就是左⼦树上所有节点的键值都⼩于根节点的键值，右⼦树所有节点的键值都 ⼤于根节点的键值。使⽤中序遍历可将键值按照从⼩到⼤遍历出来。 </p>
<p>共同点： 都是C++的关联容器,只是通过它提供的接⼝对⾥⾯的元素进⾏访问，底层都是采⽤红⿊树实现。 </p>
<p> 不同点： set：⽤来判断某⼀个元素是不是在⼀个组⾥⾯。  </p>
<p>1、为什么要成倍的扩容⽽不是⼀次增加⼀个固定⼤⼩的容量呢？  采⽤成倍⽅式扩容，可以保证常数的时间复杂度，⽽增加指定⼤⼩的容量只能达到O(n)的时间复杂度。 </p>
<p> 2、为什么是以两倍的⽅式扩容⽽不是三倍四倍，或者其他⽅式呢 考虑可能产⽣的堆空间浪费，所以增⻓倍数不能太⼤，⼀般是1.5或2；GCC是2；VS是1.5，k &#x3D;2 每次扩展的新尺⼨ 必然刚好⼤于之前分配的总和，之前分配的内存空间不可能被使⽤，这样对于缓存并不友好，采⽤1.5倍的增⻓⽅ 式可以更好的实现对内存的重复利⽤。</p>
<p>  C++并没有规定扩容因⼦K，这是由标准库的实现者决定的。</p>
<h2 id="25、什么是内存对齐？为什么需要内存对齐？"><a href="#25、什么是内存对齐？为什么需要内存对齐？" class="headerlink" title="25、什么是内存对齐？为什么需要内存对齐？"></a>25、什么是内存对齐？为什么需要内存对齐？</h2><p>1、什么是内存对齐</p>
<p>内存对⻬是指数据在内存中的存储起始地址是某个值的倍数。</p>
<p>在结构体中，编译器为结构体的每个成员按其⾃然边界（alignment）分配空间。各个成员按照它们被声明的顺序在内存中顺序存储，第⼀个成员的地址和整 个结构体的地址相同。</p>
<p>为了<strong>使CPU能够对变量进⾏快速的访问</strong>，变量的起始地址应该具有某些特性，即所谓的“对⻬”，⽐如4字节的int 型，其起始地址应该位于4字节的边界上，即起始地址能够被4整除，也即“对⻬”跟数据在内存中的位置有关。如果 ⼀个变量的内存地址正好位于它⻓度的整数倍，他就被称做⾃然对⻬。</p>
<p>⽐如在32位cpu下，假设⼀个整型变量的地址为0x00000004(为4的倍数)，那它就是⾃然对⻬的，⽽如果其地址为 0x00000002（⾮4的倍数）则是⾮对⻬的。现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类 型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就 需要各种类型数据按照⼀定的规则在空间上排列，⽽不是顺序的⼀个接⼀个的排放，这就是对⻬。</p>
<p>2、为什么需要内存对齐</p>
<p>需要字节对⻬的根本原因在于<strong>CPU访问数据的效率问题</strong>。假设上⾯整型变量的地址不是⾃然对⻬，⽐如为 0x00000002，则CPU如果取它的值的话需要访问两次内存，第⼀次取从0x00000002-0x00000003的⼀个short， 第⼆次取从0x00000004-0x00000005的⼀个short然后组合得到所要的数据，如果变量在0x00000003地址上的话 则要访问三次内存，第⼀次为char，第⼆次为short，第三次为char，然后组合得到整型数据。 ⽽如果变量在⾃然对⻬位置上，则只要⼀次就可以取出数据。⼀些系统对内存对⻬要求⾮常严格，⽐如sparc系统，如 果取未对⻬的数据会发⽣错误，⽽在x86上就不会出现错误，只是效率下降。</p>
<h2 id="26、指针和引用的区别"><a href="#26、指针和引用的区别" class="headerlink" title="26、指针和引用的区别"></a>26、指针和引用的区别</h2><p>指针存放某个对象的地址，其本身就是变量（命了名的对象），<strong>本身就有地址</strong>，所以可以有指向指针的指针；可变，包括其所指向的地址的改变和其指向的地址中所存放的数据的改变。</p>
<p>引⽤就是变量的别名，从⼀⽽终，不可变，必须初始化。不存在指向空值的引⽤，但是存在指向空值的指针。</p>
<p>1、定义和声明： </p>
<p>指针是⼀个变量，其值是另⼀个变量的地址。声明指针时，使⽤ * 符号。</p>
<p>引⽤是⼀个别名，它是在<strong>已存在的变量上创建</strong>的。在声明引⽤时，使⽤ &amp; 符号。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> *ptr = &amp;x;<span class="hljs-comment">// 指针的定义</span><br><br><span class="hljs-type">int</span> y = <span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> &amp;ref = y;<span class="hljs-comment">// 引用的定义与初始化</span><br></code></pre></td></tr></table></figure>

<p>2、 使⽤和操作： </p>
<p>指针： 可以通过解引⽤操作符 * 来访问指针指向的变量的值，还可以通过地址运算符 &amp; 获取变量的地址。 </p>
<p>引⽤： 引⽤在声明时被初始化，并在整个⽣命周期中⼀直引⽤同⼀个变量。不需要使⽤解引⽤操作符，因为引⽤本身就是变量的别名。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> value = *ptr; <span class="hljs-comment">// 获取指针指向的值</span><br><span class="hljs-type">int</span> address = &amp;x; <span class="hljs-comment">// 获取变量 x 的地址</span><br><span class="hljs-type">int</span> newValue = ref;<span class="hljs-comment">//获取引用的值</span><br></code></pre></td></tr></table></figure>

<p>3、空值和空引用：</p>
<p>指针可以指向空（nullptr），表示不指向任何有效的地址。</p>
<p>引用必须在声明时初始化，并且不能再后续改变引用的绑定对象，因此没有空引用的概念。</p>
<p>4、可变性：</p>
<p>指针：指针的指向可以改变，使其指向不同的地址，指针指向的的地址里面的值也可以修改。</p>
<p>引用：一旦引用被初始化，它将一直引用同一个对象，不能改变绑定。</p>
<p>5、用途：</p>
<p>指针： 通常⽤于动态内存分配、数组操作以及函数参数传递。</p>
<p> 引⽤： 通常⽤于函数参数传递、操作符᯿载以及创建别名。</p>
<h2 id="27、数据类型"><a href="#27、数据类型" class="headerlink" title="27、数据类型"></a>27、数据类型</h2><p>C++ 整型数据⻓度标准 short ⾄少 16 位， int ⾄少与 short ⼀样⻓ ，long ⾄少 32 位，且⾄少与 int ⼀样⻓ 。long long ⾄少 64 位，且⾄少与 long ⼀样⻓，在使⽤8位字节的系统中，1 byte &#x3D; 8 bit 。很多系统都使⽤最⼩⻓度，short 为 16 位即 2 个字节，long 为 32 位即 4 个字节，long long 为 64 位即 8 个字 节，int 的⻓度较为灵活，⼀般认为 int 的⻓度为 4 个字节，与 long 等⻓。 </p>
<p>可以通过运算符 sizeof 判断数据类型的⻓度。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout &lt;&lt; <span class="hljs-string">&quot;int is &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span> (<span class="hljs-type">int</span>) &lt;&lt; <span class="hljs-string">&quot; bytes. \n&quot;</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;short is &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span> (<span class="hljs-type">short</span>) &lt;&lt; <span class="hljs-string">&quot; bytes. \n&quot;</span>;<br></code></pre></td></tr></table></figure>

<p>头⽂件climits定义了符号常量：例如：INT_MAX 表示 int 的最⼤值，INT_MIN 表示 int 的最⼩值。</p>
<p>⽆符号类型：即为<strong>不存储负数值的整型</strong>，可以增⼤变量能够存储的最⼤值，数据⻓度不变。 int 被设置为⾃然⻓度，即为计算机处理起来效率最⾼的⻓度，所以选择类型时⼀般选⽤ int 类型。</p>
<h2 id="28、关键字"><a href="#28、关键字" class="headerlink" title="28、关键字"></a>28、关键字</h2><p>一、const 关键字</p>
<p>const的作⽤： <strong>被它修饰的值不能改变</strong>，是只读变量。必须在定义的时候就给它赋初值。</p>
<p>1、常量指针（底层const）</p>
<p>是指定义了⼀个指针，<strong>这个指针指向⼀个只读的对象</strong>，不能通过常量指针来改变这个对象的值。常量指针强调的是 <strong>指针对其所指对象的不可改变性</strong>。</p>
<p>特点：靠近变量名</p>
<p>形式：</p>
<p>（1）const 数据类型 *指针变量 &#x3D; 变量名 （2）数据类型 const *指针变量 &#x3D; 变量名</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-type">int</span> temp = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* a = &amp;temp;<br><span class="hljs-type">int</span> <span class="hljs-type">const</span> *a = &amp;temp;<br><span class="hljs-comment">// 更改：</span><br>*a = <span class="hljs-number">9</span>; <span class="hljs-comment">// 错误：只读对象</span><br>temp = <span class="hljs-number">9</span>; <span class="hljs-comment">// 正确</span><br></code></pre></td></tr></table></figure>

<p><strong>不能通过常量指针修改指针指向的值</strong></p>
<p>2、指针常量（顶层const）</p>
<p>指针常量是指定义了⼀个指针，这个指针的值只能在定义时初始化，其他地⽅不能改变。指针常量强调的是指针的 不可改变性。</p>
<p>特点：靠近变量类型</p>
<p>形式：</p>
<p>数据类型 * const 指针变量&#x3D;变量名</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> temp = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> temp1 = <span class="hljs-number">12</span>;<br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> p = &amp;temp;<br><span class="hljs-comment">// 更改：</span><br>p = &amp;temp2; <span class="hljs-comment">// 错误</span><br>*p = <span class="hljs-number">9</span>; <span class="hljs-comment">// 正确</span><br></code></pre></td></tr></table></figure>

<p><strong>不能修改指针的指向</strong></p>
<p>二、static关键字的作用</p>
<p>static 关键字主要⽤于控制变量和函数的⽣命周期、作⽤域以及访问权限。</p>
<p>1、 静态变量</p>
<p>在函数内部使⽤ static 关键字修饰的变量称为静态变量。</p>
<p>静态变量在程序的整个⽣命周期内存在，不会因为离开作⽤域⽽被销毁。</p>
<p>静态变量默认初始化为零（对于基本数据类型）。</p>
<p>2、静态函数</p>
<p>在类内部使⽤ static 关键字修饰的函数是静态函数。</p>
<p>静态函数属于类而不是类的实例，可以通过类名直接调⽤，而无需创建对象。 </p>
<p>静态函数不能直接访问⾮静态成员变量或⾮静态成员函数。</p>
<p>3、静态成员变量 </p>
<p>在类中使⽤ static 关键字修饰的成员变量是静态成员变量。 </p>
<p>所有类的对象共享同⼀个静态成员变量的副本。 </p>
<p>静态成员变量必须在类外部单独定义，以便为其分配存储空间。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ExampleClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br> <span class="hljs-type">static</span> <span class="hljs-type">int</span> staticVar; <span class="hljs-comment">// 静态成员变量声明</span><br>&#125;;<br><span class="hljs-comment">// 静态成员变量定义</span><br><span class="hljs-type">int</span> ExampleClass::staticVar = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>

<p>4、静态成员函数 </p>
<p>在类中使⽤ static 关键字修饰的成员函数是静态成员函数。 </p>
<p>静态成员函数不能直接访问⾮静态成员变量或⾮静态成员函数。 </p>
<p>静态成员函数可以通过类名调⽤，而不需要创建类的实例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ExampleClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br> <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">staticMethod</span><span class="hljs-params">()</span> </span>&#123;<br> cout &lt;&lt; <span class="hljs-string">&quot;Static method&quot;</span> &lt;&lt; endl;<br> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="29、const关键字的作用"><a href="#29、const关键字的作用" class="headerlink" title="29、const关键字的作用"></a>29、const关键字的作用</h2><p>const 关键字主要⽤于指定变量、指针、引⽤、成员函数等的性质 </p>
<ol>
<li>常量变量：声明常量，使变量的值不能被修改。</li>
<li>指针和引⽤：声明指向常量的指针，表示指针所指向的值是常量，不能通过指针修改。声明常量引⽤，表示引 ⽤的值是常量，不能通过引⽤修改。</li>
<li>成员函数：⽤于声明常量成员函数，表示该函数不会修改对象的成员变量（对于成员变量是⾮静态的情况）。</li>
<li>常量对象：声明对象为常量，使得对象的成员变量不能被修改。 </li>
<li>常引⽤参数：声明函数参数为常量引⽤，表示函数不会修改传⼊的参数</li>
<li>常量指针参数：声明函数参数为指向常量的指针，表示函数不会通过指针修改传⼊的数据。</li>
</ol>
<h2 id="30、define-和-typedef-的区别"><a href="#30、define-和-typedef-的区别" class="headerlink" title="30、define 和 typedef 的区别"></a>30、define 和 typedef 的区别</h2><p>define </p>
<p>1、只是简单的字符串替换，没有类型检查 </p>
<p>2、只是在编译的预处理阶段起作⽤ </p>
<p>3、可以⽤来防⽌头⽂件重复引⽤</p>
<p> 4、不分配内存，给出的是⽴即数，有多少次使⽤就进⾏多少次替换</p>
<p>typedef </p>
<p>1、有对应的数据类型，是要进⾏判断的</p>
<p>2、是在编译、运⾏的时候起作⽤ </p>
<p>3、在<strong>静态存储区</strong>中分配空间，在程序运⾏过程中内存中只有⼀个拷⻉</p>
<h2 id="31、define和inline的区别"><a href="#31、define和inline的区别" class="headerlink" title="31、define和inline的区别"></a>31、define和inline的区别</h2><p>1、define： 定义预编译时处理的宏，只是简单的字符串替换，⽆类型检查，不安全。</p>
<p>2、inline： </p>
<p>inline是先将内联函数编译完成⽣成了函数体直接插⼊被调⽤的地⽅，减少了压栈，跳转和返回的操作。</p>
<p>没有普通 函数调⽤时的额外开销； 内联函数是⼀种特殊的函数，会进⾏类型检查； </p>
<p>对编译器的⼀种请求，编译器有可能拒绝这种请求；</p>
<p>C++中inline编译限制：</p>
<p>1、不能存在任何形式的循环语句 </p>
<p>2、不能存在过多的条件判断语句</p>
<p>3、函数体不能过于庞⼤ </p>
<p>4、内联函数声明必须在调⽤语句之前</p>
<h2 id="32、const和define的区别"><a href="#32、const和define的区别" class="headerlink" title="32、const和define的区别"></a>32、const和define的区别</h2><p>const⽤于定义常量；⽽define⽤于定义宏，⽽宏也可以⽤于定义常量。都⽤于常量定义时，它们的区别有：</p>
<p>1、const⽣效于编译的阶段；define⽣效于预处理阶段。</p>
<p>2、 const定义的常量，在C语⾔中是<strong>存储在内存中、需要额外的内存空间</strong>的；define定义的常量，运⾏时是直接的操作数，并不会存放在内存中。</p>
<p>3、const定义的常量是带类型的；define定义的常量不带类型。因此define定义的常量不利于类型检查。</p>
<h2 id="33、constexpr-和-const"><a href="#33、constexpr-和-const" class="headerlink" title="33、constexpr 和 const"></a>33、constexpr 和 const</h2><p>const 表示“只读”的语义，constexpr 表示“常量”的语义 </p>
<p>constexpr 只能定义编译期常量，⽽ const 可以定义编译期常量，也可以定义运⾏期常量。 你将⼀个成员函数标记为constexpr，则顺带也将它标记为了const。</p>
<p>如果你将⼀个变量标记为constexpr，则同样它是const的。但相反并不成⽴，⼀个const的变量或函数，并不是constexpr的。</p>
<p>constexpr变量</p>
<p>复杂系统中很难分辨⼀个初始值是不是常量表达式，可以将变量声明为constexpr类型，由编译器来验证变量的值 是否是⼀个常量表达式。  </p>
<p>必须使⽤常量初始化:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> n = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> m = n + <span class="hljs-number">1</span>;<br><span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1000000007</span>;<br></code></pre></td></tr></table></figure>

<p><strong>如果constexpr声明中定义了⼀个指针，constexpr仅对指针有效，和所指对象⽆关。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> *p = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">//常量指针 顶层const</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *q = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">//指向常量的指针， 底层const（常量指针）</span><br><span class="hljs-type">int</span> *<span class="hljs-type">const</span> q = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">//顶层const（指针常量）</span><br></code></pre></td></tr></table></figure>

<p>顶层const：指针本身是常量； </p>
<p>底层const：指针所指的对象是常量；</p>
<p>左定值，右定向：指的是const在*的左还是右边</p>
<h2 id="34、constexpr的好处"><a href="#34、constexpr的好处" class="headerlink" title="34、constexpr的好处"></a>34、constexpr的好处</h2><p>1、为⼀些不能修改数据提供保障，写成变量则就有被意外修改的⻛险</p>
<p> 2、有些场景，编译器可以在编译期对constexpr的代码进⾏优化，提⾼效率</p>
<p> 3、相⽐宏来说，没有额外的开销，但更安全可靠</p>
<h2 id="35、前置-与后置"><a href="#35、前置-与后置" class="headerlink" title="35、前置++与后置++"></a>35、前置++与后置++</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">self &amp;<span class="hljs-keyword">operator</span>++() &#123;<br> node = (linktype)((node).next);<br> <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-type">const</span> self <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) &#123;<br> self tmp = *<span class="hljs-keyword">this</span>;<br> ++*<span class="hljs-keyword">this</span>;<br> <span class="hljs-keyword">return</span> tmp;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>为了区分前后置，重载函数是以参数类型来区分，在调⽤的时候，编译器默默给int指定为⼀个0。</p>
<p>1、为什么后置返回对象，⽽不是引⽤ </p>
<p>因为后置为了返回旧值创建了⼀个临时对象，在函数结束的时候这个对象就会被销毁，如果返回引⽤，那么我请问你？你的对象对象都被销毁了，你引⽤啥呢？ </p>
<p>2、为什么后置前⾯也要加const </p>
<p>其实也可以不加，但是为了防⽌你使⽤i++++,连续两次的调⽤后置++重载符，为什么呢? 原因： 它与内置类型⾏为不⼀致；你⽆法获得你所期望的结果，因为第⼀次返回的是旧值，⽽不是原对象，你调⽤两次后置++，结果只累加了⼀次，所以我们必须⼿动禁⽌，使其合法化，就要在前⾯加上const</p>
<p>36、什么是函数指针，如何定义和使⽤场景</p>
<p>函数指针是指向函数的指针变量。它可以⽤于存储函数的地址，允许在运⾏时动态选择要调⽤的函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 返回类型 (*指针变量名)(参数列表)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br> <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">subtract</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br> <span class="hljs-keyword">return</span> a - b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br> <span class="hljs-comment">// 定义⼀个函数指针，指向⼀个接受两个int参数、返回int的函数</span><br> <span class="hljs-built_in">int</span> (*operationPtr)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>);<br> <span class="hljs-comment">// 初始化函数指针，使其指向 add 函数</span><br> operationPtr = &amp;add;<br> <span class="hljs-comment">// 通过函数指针调⽤函数</span><br> <span class="hljs-type">int</span> result = <span class="hljs-built_in">operationPtr</span>(<span class="hljs-number">10</span>,<span class="hljs-number">5</span>)<br> cout &lt;&lt; <span class="hljs-string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; endl;<br> <span class="hljs-comment">// 将函数指针切换到 subtract 函数</span><br> operationPtr = &amp;subtract;<br> <span class="hljs-comment">// 再次通过函数指针调⽤函数</span><br> result = <span class="hljs-built_in">operationPtr</span>(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>);<br> cout &lt;&lt; <span class="hljs-string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; endl;<br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使⽤场景： </p>
<p>1、回调函数： 函数指针常⽤于实现回调机制，允许将函数的地址传递给其他函数，以便在适当的时候调用。 </p>
<p>2、函数指针数组： 可以使⽤函数指针数组实现类似于状态机的逻辑，根据不同的输⼊调⽤不同的函数。</p>
<p> 3、动态加载库： 函数指针可⽤于在运⾏时动态加载库中的函数，实现动态链接库的调用。</p>
<p>4、多态实现： 在C++中，虚函数和函数指针结合使⽤，可以实现类似于多态的效果。 </p>
<p>5、函数指针作为参数： 可以将函数指针作为参数传递给其他函数，实现⼀种可插拔的函数⾏为。</p>
<p>6、实现函数映射表： 在⼀些需要根据某些条件调⽤不同函数的情况下，可以使⽤函数指针来实现函数映射表。</p>
<h2 id="36、struct和class的区别"><a href="#36、struct和class的区别" class="headerlink" title="36、struct和class的区别"></a>36、struct和class的区别</h2><p>通常， struct ⽤于表示⼀组相关的数据，⽽ class ⽤于表示⼀个封装了<strong>数据和操作</strong>的对象,在实际使⽤中， 可以根据具体的需求选择使⽤ struct 或 class 。</p>
<p>如果只是⽤来组织⼀些数据，⽽不涉及复杂的封装和继承关系， struct 可能更直观；如果需要进⾏封装、继承等⾯向对象编程的特性，可以选择使⽤ class 。 </p>
<p>struct结构体中的成员默认是公有的（public）。类中的成员默认是私有的（private）。 struct 继承时默认使⽤公有继承。class 继承时默认使⽤私有继承。</p>
<p>如果结构体没有定义任何构造函数，编译器会⽣成默认的无参数构造函数。如果类没有定义任何构造函数，编译器也会⽣成默认的⽆参数构造函数。</p>
<h2 id="37、C-强制类型转换"><a href="#37、C-强制类型转换" class="headerlink" title="37、C++强制类型转换"></a>37、C++强制类型转换</h2><p> 关键字：static_cast、dynamic_cast、reinterpret_cast和 const_cast</p>
<p>1、static_cast </p>
<p>没有运⾏时类型检查来保证转换的安全性 </p>
<p>进⾏上⾏转换（把派⽣类的指针或引⽤转换成基类表示）是安全的 </p>
<p>进⾏下⾏转换（把基类的指针或引⽤转换为派⽣类表示），由于没有动态类型检查，所以是不安全的。 </p>
<p> 使⽤：</p>
<p>​         1、⽤于基本数据类型之间的转换，如把int转换成char。</p>
<pre><code class="hljs">     2、把任何类型的表达式转换成void类型。
</code></pre>
<p>2、dynamic_cast </p>
<p>在进⾏下⾏转换时，dynamic_cast具有类型检查（信息在虚函数中）的功能，⽐static_cast更安全。 </p>
<p>转换后必须是类的指针、引⽤或者void*，基类要有虚函数，可以交叉转换。</p>
<p> dynamic本身只能⽤于<strong>存在虚函数的⽗⼦关系的强制类型转换</strong>；对于指针，转换失败则返回nullptr，对于引⽤，转换失败会抛出异常。 </p>
<p>3、reinterpret_cast </p>
<p>可以将整型转换为指针，也可以把指针转换为数组；可以在指针和引⽤⾥进⾏肆⽆忌惮的转换，平台移植性⽐价 差。</p>
<p>4、const_cast </p>
<p>常量指针转换为⾮常量指针，并且仍然指向原来的对象。常量引⽤被转换为⾮常量引⽤，并且仍然指向原来的对象。<strong>去掉类型的const或volatile属性</strong>。</p>
<h2 id="38、堆和栈的区别"><a href="#38、堆和栈的区别" class="headerlink" title="38、堆和栈的区别"></a>38、堆和栈的区别</h2><p>堆和栈都是用来存储程序数据的内存区域。</p>
<p>栈是一种有限的内存区域，用于存储局部变量，函数调用信息等。</p>
<p>堆是一种动态分配的内存区域，用于存储程序运行时动态分配的数据。</p>
<p>栈上的变量生命周期与其所在函数的执行周期相同，</p>
<p>堆上的变量生命周期由程序员显示的控制，可以（使⽤ new 或 malloc ）开辟和释放（使⽤ delete 或 free ）。</p>
<h2 id="申请方式不同"><a href="#申请方式不同" class="headerlink" title="申请方式不同"></a>申请方式不同</h2><ul>
<li>栈由系统自动分配。</li>
<li>堆是自己申请和释放的。</li>
</ul>
<h2 id="申请大小限制不同"><a href="#申请大小限制不同" class="headerlink" title="申请大小限制不同"></a>申请大小限制不同</h2><ul>
<li>栈顶和栈底是之前预设好的，栈是向栈底扩展，大小固定，可以通过ulimit -a查看，由ulimit -s修改。</li>
<li>堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。</li>
</ul>
<h2 id="申请效率不同"><a href="#申请效率不同" class="headerlink" title="申请效率不同"></a>申请效率不同</h2><ul>
<li>栈由系统分配，速度快，不会有碎片。</li>
<li>堆由程序员分配，速度慢，且会有碎片。</li>
</ul>
<p>栈就像我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。</p>
<p>堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大</p>
<h2 id="39、内存分区"><a href="#39、内存分区" class="headerlink" title="39、内存分区"></a>39、内存分区</h2><p>1、栈 （自顶向下增长）</p>
<p>栈⽤于存储函数的<strong>局部变量</strong>、<strong>函数参数</strong>和<strong>函数调⽤</strong>信息的区域。函数的调⽤和返回通过栈来管理。</p>
<p>2、堆 （自底向上增长）</p>
<p>堆⽤于存储动态分配的内存的区域，由程序员⼿动分配和释放。使⽤ new 和 delete 或 malloc 和 free 来进 ⾏堆内存的分配和释放。 </p>
<p>3、全局&#x2F;静态区 </p>
<p>全局区存储全局变量和静态变量。⽣命周期是整个程序运⾏期间。在程序启动时分配，程序结束时释放。</p>
<p>4、常量区 </p>
<p>常量区也被称为只读区。存储常量数据，如字符串常量。</p>
<p>5、代码区 </p>
<p>存储程序的代码。 </p>
<h2 id="40、sort-函数你用没？其中的排序函数是快排还是插入排序？"><a href="#40、sort-函数你用没？其中的排序函数是快排还是插入排序？" class="headerlink" title="40、sort()函数你用没？其中的排序函数是快排还是插入排序？"></a>40、sort()函数你用没？其中的排序函数是快排还是插入排序？</h2><p>1、首先进行判断排序的元素个数是否大于stl_threshold，stl_threshold是一个常量值是16，意思就是说我传入的元素规模小于我们的16的时候直接采用插入排序。</p>
<p>（为什么用插入排序？因为插入排序在面对“几近排序”的序列时，表现更好，而快排是通过递归实现的，会为了极小的子序列产生很多的递归调用在区间长度小的时候经常不如插入排序效率高）</p>
<p>2、如果说我们的元素规模大于16，那就需要去判断是不是能采用快速排序，怎么判断呢？</p>
<p>快排是使用递归来实现的，如果说我们进行判断我们的递归深度有没有到达递归深度的限制阈值2*lg（n），如果递归深度没达到阈值就使用快速排序来进行排序</p>
<p>3、如果说大于我们的最深递归深度阈值的话，这个时候说明快排复杂度退化了（比如很不巧基准元素多次选取到了当前区间中最小或最大的元素。</p>
<p>这种情况下，每次划分只能将区间缩小1个元素，造成递归深度过深），就会采用我们的堆排序，堆排序是可以保证稳定O(nlogn)的时间复杂度的。</p>
<h2 id="41、什么是缺省函数？如果有一个空类，它会默认添加哪些函数"><a href="#41、什么是缺省函数？如果有一个空类，它会默认添加哪些函数" class="headerlink" title="41、什么是缺省函数？如果有一个空类，它会默认添加哪些函数"></a>41、什么是缺省函数？如果有一个空类，它会默认添加哪些函数</h2><p>在C++中，如果一个类没有显式地定义「构造函数、析构函数、拷贝构造函数、赋值运算符重载函数」，那么编译器会自动生成这些函数，这些函数被称为缺省函数。</p>
<p>构造一个空类，会添加以下函数：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-number">1</span>)  <span class="hljs-keyword">Empty</span>()<span class="hljs-punctuation">;</span> <span class="hljs-comment">// 缺省构造函数//</span><br><span class="hljs-number">2</span>)  <span class="hljs-keyword">Empty</span>( <span class="hljs-keyword">const</span> <span class="hljs-keyword">Empty</span>&amp; )<span class="hljs-punctuation">;</span> <span class="hljs-comment">// 拷贝构造函数//</span><br><span class="hljs-number">3</span>)  ~<span class="hljs-keyword">Empty</span>()<span class="hljs-punctuation">;</span> <span class="hljs-comment">// 析构函数//</span><br><span class="hljs-number">4</span>)  <span class="hljs-keyword">Empty</span>&amp; <span class="hljs-keyword">operator</span>=( <span class="hljs-keyword">const</span> <span class="hljs-keyword">Empty</span>&amp; )<span class="hljs-punctuation">;</span> <span class="hljs-comment">// 赋值运算符//</span><br></code></pre></td></tr></table></figure>

<h2 id="42、STL中unordered-map和map以及set、unordered-set的区别和应用场景"><a href="#42、STL中unordered-map和map以及set、unordered-set的区别和应用场景" class="headerlink" title="42、STL中unordered_map和map以及set、unordered_set的区别和应用场景"></a>42、STL中unordered_map和map以及set、unordered_set的区别和应用场景</h2><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map支持键值的自动排序，底层机制是红黑树，红黑树的查询和维护时间复杂度均为$O(logn)$，但是空间占用比较大，因为每个节点要保持父节点、孩子节点及颜色的信息</p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>set与map类似，Set的底层实现通常也是红黑树。Set是一种特殊的Map，只有键没有值。</p>
<h2 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h2><p>unordered_map是C++ 11新添加的容器，底层机制是哈希表，通过hash函数计算元素位置，其查询时间复杂度为O(1)，维护时间与bucket桶所维护的list长度有关，但是建立hash表耗时较大.</p>
<h2 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h2><p>unordered_set: 与unordered_map类似，unordered_set的底层实现通常也是哈希表。unordered_set是一种特殊的unordered_map，只有键没有值。</p>
<p>从底层机制和特点可以看出：map适用于有序数据的应用场景，unordered_map适用于高效查询的应用场景.</p>
<h2 id="43、strcpy函数和strncpy函数的区别？哪个函数更安全？"><a href="#43、strcpy函数和strncpy函数的区别？哪个函数更安全？" class="headerlink" title="43、strcpy函数和strncpy函数的区别？哪个函数更安全？"></a>43、strcpy函数和strncpy函数的区别？哪个函数更安全？</h2><p>strcpy函数</p>
<p>如果参数 dest 所指的内存空间不够大，可能会造成缓冲溢出(buffer Overflow)的错误情况，在编写程序时请特别留意，或者用strncpy()来取代。</p>
<p>strncpy函数</p>
<p>用来复制源字符串的前n个字符，src 和 dest 所指的内存区域不能重叠，且 dest 必须有足够的空间放置n个字符。</p>
<h2 id="44、什么是内存泄露，如何检测与避免"><a href="#44、什么是内存泄露，如何检测与避免" class="headerlink" title="44、什么是内存泄露，如何检测与避免"></a>44、什么是内存泄露，如何检测与避免</h2><p><strong>内存泄露</strong></p>
<p>一般我们常说的内存泄漏是指<strong>堆内存的泄漏</strong>。堆内存是指程序从堆中分配的，大小任意的(内存块的大小可以在程序运行期决定)内存块，使用完后必须显式释放的内存。应用程序一般使用malloc,、realloc、 new等函数从堆中分配到块内存，使用完后，程序必须负责调用相应的free或delete释放该内存块，否则，这块内存就不能被再次使用，我们就说这块内存泄漏了</p>
<p><strong>避免内存泄露的几种方式</strong></p>
<ul>
<li>计数法：使用new或者malloc时，让该数+1，delete或free时，该数-1，程序执行完打印这个计数，如果不为0则表示存在内存泄露</li>
<li>一定要将基类的析构函数声明为<strong>虚函数</strong></li>
<li>对象数组的释放一定要用<strong>delete []</strong></li>
<li>有new就有delete，有malloc就有free，保证它们一定成对出现</li>
</ul>
<p><strong>检测工具</strong></p>
<ul>
<li>Linux下可以使用<strong>Valgrind工具</strong></li>
<li>Windows下可以使用<strong>CRT库</strong></li>
</ul>
<h2 id="45、设计模式相关"><a href="#45、设计模式相关" class="headerlink" title="45、设计模式相关"></a>45、设计模式相关</h2><p>设计模式是指在软件开发中，经过验证的，用于解决在特定环境下，重复出现的，特定问题的解决方案</p>
<p>按照设计目的分为三类：创建型模式、结构型模式和行为模式</p>
<p>分别对应了面向对象开发的三个问题：如何创建对象、如何组合对象、如何处理对象之间的动态通信和职责分配。</p>
<p>常见的设计模式有以下几种</p>
<ol>
<li>工厂模式：将对象的创建和使用分离，客户端只需知道产品的接口，无需关心具体实现。</li>
<li>单例模式：保证一个类只有一个实例，并提供全局访问点。</li>
<li>观察者模式：对象间的一种一对多的依赖关系，当一个对象状态发生改变时，所有依赖它的对象都会得到通知并自动更新。</li>
<li>装饰器模式：动态地给一个对象添加一些额外的职责，同时又不改变其结构。</li>
<li>策略模式：定义一系列算法，将每个算法封装起来并可互换使用，使得算法的变化不会影响到使用算法的客户端。</li>
<li>适配器模式：将一个类的接口转换成客户端所期望的另一个接口，使得原本由于接口不兼容而不能一起工作的类可以一起工作。</li>
<li>模板方法模式：定义一个算法的骨架，将一些步骤延迟到子类中实现，使得子类可以不改变算法的结构即可重定义该算法的某些特定步骤。</li>
<li>建造者模式：将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。</li>
</ol>
<h1 id="C-11-新特性"><a href="#C-11-新特性" class="headerlink" title="C++11 新特性"></a>C++11 新特性</h1><h2 id="1、语法的改进"><a href="#1、语法的改进" class="headerlink" title="1、语法的改进"></a>1、语法的改进</h2><p>（1） 统一的初始化方法</p>
<p>（2）成员变量默认初始化</p>
<p>（3）<strong>auto关键字：允许编译器自动推断变量的类型，减少类型声明的冗余。</strong></p>
<p>（4）decltype求表达式的类型</p>
<p>（5）<strong>智能指针</strong></p>
<p>（6）<strong>空指针 nullptr: 提供了明确表示空指针的关键字，替代了传统的 NULL 。</strong></p>
<p>（7）<strong>基于范围的for循环: 简化遍历容器元素的语法</strong></p>
<p>（8）<strong>右值引⽤和move语义 引⼊右值引⽤和移动构造函数，允许⾼效地将资源从⼀个对象移动到另⼀个对象，提⾼性能。</strong></p>
<h2 id="2、标准库扩充"><a href="#2、标准库扩充" class="headerlink" title="2、标准库扩充"></a>2、标准库扩充</h2><p>（9）⽆序容器（哈希表） ⽤法和功能同map⼀模⼀样，区别在于哈希表的效率更⾼ </p>
<p>（10）正则表达式 可以认为正则表达式实质上是⼀个字符串，该字符串描述了⼀种特定模式的字符串 </p>
<p>（11）<strong>Lambda表达式： 允许在代码中定义匿名函数</strong></p>
<h2 id="3、智能指针"><a href="#3、智能指针" class="headerlink" title="3、智能指针"></a>3、智能指针</h2><p>1、shared_ptr</p>
<p>shared_ptr的实现机制是在拷⻉构造时使⽤同⼀份引⽤计数</p>
<p>（1）⼀个模板指针T* ptr 指向实际的对象  （2）⼀个引⽤次数 必须new出来的，不然会多个shared_ptr⾥⾯会有不同的引⽤次数⽽导致多次delete （3）重载operator*和operator-&gt; 使得能像指针⼀样使⽤shared_ptr （4）重载copy constructor 使其引⽤次数加⼀（拷⻉构造函数) （5）重载operator&#x3D;（赋值运算符） 如果原来的shared_ptr已经有对象，则让其引⽤次数减⼀并判断引⽤是否为零(是否调⽤delete)，然后将新的对象 引⽤次数加⼀ （6）重载析构函数 使引⽤次数减⼀并判断引⽤是否为零; (是否调⽤delete)</p>
<p>2、线程安全问题</p>
<p>（1）同⼀个shared_ptr被多个线程“读”是安全的; （2）同⼀个shared_ptr被多个线程“写”是不安全的;  </p>
<p><strong>证明：在多个线程中同时对⼀个shared_ptr循环执⾏两遍swap。 shared_ptr的swap函数的作⽤就是和另外⼀个 shared_ptr交换引⽤对象和引⽤计数，是写操作。执⾏两遍swap之后, shared_ptr引⽤的对象的值应该不变）</strong> （什么意思？</p>
<p>（3）共享引⽤计数的不同的shared_ptr被多个线程”写“ 是安全的。</p>
<p>3、 unique_ptr </p>
<p>1、unique_ptr”唯⼀”拥有其所指对象 同⼀时刻只能有⼀个unique_ptr指向给定对象，离开作⽤域时，若其指向对象，则将其所指对象销毁（默认 delete）。  2、定义unique_ptr时 需要将其绑定到⼀个new返回的指针上。  3、unique_ptr不⽀持普通的拷⻉和赋值（因为拥有指向的对象） 但是可以拷⻉和赋值⼀个将要被销毁的unique_ptr；可以通过release或者reset将指针所有权从⼀个（⾮const） unique_ptr转移到另⼀个unique。 </p>
<p>4、weak_ptr </p>
<p>1、weak_ptr是为了配合shared_ptr⽽引⼊的⼀种智能指针 它的最⼤作⽤在于协助shared_ptr⼯作，像旁观者那样观测资源的使⽤情况，<strong>但weak_ptr没有共享资源，它的构造不会引起指针引⽤计数的增加</strong>。  2、和shared_ptr指向相同内存 shared_ptr析构之后内存释放，在使⽤之前使⽤函数lock()检查weak_ptr是否为空指针。</p>
<h2 id="4、类型推导"><a href="#4、类型推导" class="headerlink" title="4、类型推导"></a>4、类型推导</h2><p>1、auto</p>
<p>auto可以让编译器在编译期就推导出变ᰁ的类型 </p>
<p>（1）auto的使⽤必须⻢上初始化，否则⽆法推导出类型 </p>
<p>（2）auto在⼀⾏定义多个变ᰁ时，各个变ᰁ的推导不能产⽣⼆义性，否则编译失败 </p>
<p>（3）auto不能⽤作函数参数 </p>
<p>（4）在类中auto不能⽤作⾮静态成员变ᰁ量</p>
<p>（5）auto不能定义数组，可以定义指针</p>
<p>（6）auto⽆法推导出模板参数 </p>
<p>（7）在不声明为引⽤或指针时，auto会<strong>忽略</strong>等号<strong>右边的引⽤类型和cv限定</strong> </p>
<p>（8）在声明为引⽤或者指针时，auto会<strong>保留</strong>等号右边的引⽤和cv属性</p>
<p>2、decltype：</p>
<p> decltype则⽤于推导表达式类型，这⾥只⽤于编译器分析表达式的类型，表达式实际不会进⾏运算 decltype不会像auto⼀样忽略引⽤和cv属性，decltype会保留表达式的引⽤和cv属性  对于decltype(exp)有： </p>
<ol>
<li>exp是表达式，decltype(exp)和exp类型相同</li>
<li>exp是函数调⽤，decltype(exp)和函数返回值类型相同 </li>
<li>其它情况，若exp是左值，decltype(exp)是exp类型的左值引⽤</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt; </span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(T t, U u)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(t + u)</span> </span><br><span class="hljs-function"></span>&#123; <span class="hljs-keyword">return</span> t + u; &#125; <br></code></pre></td></tr></table></figure>

<h2 id="5、右值引用"><a href="#5、右值引用" class="headerlink" title="5、右值引用"></a>5、右值引用</h2><p>左值右值：</p>
<p>左值： 可以放在等号左边，可以取地址并有名字 </p>
<p>右值： 不可以放在等号左边，不能取地址，没有名字。 字符串字⾯值”abcd”也是左值，不是右值 ，++i、–i是左值，i++、i–是右值  </p>
<p>1、将亡值  将亡值是指C++11新增的和右值引⽤相关的表达式，将亡值可以理解为即将要销毁的值，通过“盗取”其它变量内存空间⽅式获取的值，在确保其它变量不再被使⽤或者 即将被销毁时，可以避免内存空间的释放和分配，延⻓变量值的⽣命周期，常⽤来完成移动构造或者移动赋值的特殊任务。</p>
<p>2、左值引⽤ 左值引⽤就是对左值进⾏引⽤的类型，是对象的⼀个别名 并不拥有所绑定对象的堆存，所以必须⽴即初始化。 对于左值引⽤，等号右边的值必须可以取地址，如果不能取地 址，则会编译失败，或者可以使⽤const引⽤形式 </p>
<p>3、右值引⽤ 表达式等号右边的值需要是右值，<strong>可以使⽤std::move函数强制把左值转换为右值。</strong></p>
<p> 4、移动语义  可以理解为转移所有权，对于移动语义，类似于转让或者资源窃取的意思，对于那块资源，转为⾃⼰所拥有，别⼈ 不再拥有也不会再使⽤。 通过移动构造函数使⽤移动语义，也就是std::move；移动语义仅针对于那些实现了移动构造函数的类的对象，对于那种基本类型int、float等没有任何优化作⽤，还是会拷⻉，因为它们实现没有对应的移动构造函数  </p>
<p>浅拷⻉：  a和b的指针指向了同⼀块内存，就是浅拷⻉，只是数据的简单赋值； </p>
<p>深拷⻉：  深拷⻉就是再拷⻉对象时，如果被拷⻉对象内部还有指针引⽤指向其它资源，⾃⼰需要᯿新开辟⼀块新内存 存储资源 </p>
<p>5、完美转发 写⼀个接受任意实参的函数模板，并转发到其它函数，⽬标函数会收到与转发函数完全相同的实参，通过 std::forward()实现</p>
<h2 id="6、nullptr"><a href="#6、nullptr" class="headerlink" title="6、nullptr"></a>6、nullptr</h2><p> nullptr是⽤来代替NULL，<em><em>⼀般C++会把NULL、0视为同⼀种东⻄，这取决去编译器如何定义NULL，有的定义为 ((void</em>)0)，有的定义为0</em>**</p>
<p>C++不允许直接将void* 隐式转换到其他类型，在进⾏C++重载时会发⽣混乱 </p>
<p>例如： </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">char</span> *)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> )</span></span>;<br></code></pre></td></tr></table></figure>

<p>如果NULL被定义为 ((void*)0)，那么当编译char *ch &#x3D; NULL时，NULL被定义为 0  当foo(NULL)时，此时NULL为0，会去调⽤foo(int )，从⽽发⽣混乱 。为解决这个问题，从⽽需要使⽤NULL时，⽤nullptr代替：</p>
<p>  C++11引⼊nullptr关键字来区分空指针和0。nullptr 的类型为 nullptr_t，能够转换为任何指针或成员指针的类型， 也可以进⾏相等或不等的⽐较。</p>
<h2 id="7、范围for循环"><a href="#7、范围for循环" class="headerlink" title="7、范围for循环"></a>7、范围for循环</h2><p>基于范围的迭代写法，for（变ᰁ：对象）表达式  对string对象的每个字符做⼀些操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">str</span> <span class="hljs-params">(<span class="hljs-string">&quot;some thing&quot;</span>)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : str) cout &lt;&lt; c &lt;&lt; endl;<span class="hljs-comment">// 输出字符串里的每个字符</span><br></code></pre></td></tr></table></figure>

<p>对vector中的元素进⾏遍历：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">arr</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-number">100</span>)</span></span>;<br><span class="hljs-keyword">for</span> (std::vector&lt;<span class="hljs-type">int</span>&gt;::iterator i = arr.<span class="hljs-built_in">begin</span>(); i != arr.<span class="hljs-built_in">end</span>(); i ++) &#123;<br> std::cout &lt;&lt; *i &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-comment">// 范围for循环</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i : arr) &#123;<br> std::cout &lt;&lt; i &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="8、lambda表达式"><a href="#8、lambda表达式" class="headerlink" title="8、lambda表达式"></a>8、lambda表达式</h2><p>lambda表达式表示⼀个可调⽤的代码单元，没有命名的内联函数，不需要函数名因为我们直接（⼀次性的）⽤ 它，不需要其他地⽅调⽤它。</p>
<p>1、lambda 表达式的语法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[capture list] (parameter list) -&gt; <span class="hljs-keyword">return</span> type &#123;function body &#125;<br><span class="hljs-comment">// [捕获列表] (参数列表) -&gt; 返回类型 &#123;函数体 &#125;</span><br><span class="hljs-comment">// 只有 [capture list] 捕获列表和 &#123;function body &#125; 函数体是必选的</span><br><span class="hljs-keyword">auto</span> lam =[]() -&gt; <span class="hljs-type">int</span> &#123; cout &lt;&lt; <span class="hljs-string">&quot;Hello, World!&quot;</span>; <span class="hljs-keyword">return</span> <span class="hljs-number">88</span>; &#125;;<br><span class="hljs-keyword">auto</span> ret = <span class="hljs-built_in">lam</span>(); <br>cout&lt;&lt;ret&lt;&lt;endl;<span class="hljs-comment">//输出88</span><br></code></pre></td></tr></table></figure>

<p>2、lambda 表达式的特点：</p>
<p>（1）变量捕获才是成就lambda卓越的秘⽅ </p>
<p>1、[] 不捕获任何变量,这种情况下lambda表达式内部不能访问外部的变量</p>
<p>2、 [&amp;] 以引⽤⽅式捕获所有变量（保证lambda执⾏时变量存在） </p>
<p>3、[&#x3D;] ⽤值的⽅式捕获所有变量（创建时拷⻉，修改对lambda内对象⽆影响) </p>
<p>4、[&#x3D;, &amp;foo] 以引⽤捕获变量foo, 但其余变量都靠值捕获  </p>
<p>5 、[&amp;, foo] 以值捕获foo, 但其余变量都靠引⽤捕获 </p>
<p>6、[bar] 以值⽅式捕获bar; 不捕获其它变量</p>
<p>7、[this] 捕获所在类的this指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>, c = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">auto</span> lam2 = [&amp;, a]()&#123; <span class="hljs-comment">//b,c以引⽤捕获， a以值捕获</span><br> b = <span class="hljs-number">5</span>;<br> c = <span class="hljs-number">6</span>; <span class="hljs-comment">//a = 1，a不能赋值</span><br> cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; endl; <span class="hljs-comment">//输出 1 5 6</span><br>&#125;;<br><span class="hljs-built_in">lam2</span>();<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fcn</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//值捕获</span><br> <span class="hljs-type">size_t</span> v1 = <span class="hljs-number">42</span>;<br> <span class="hljs-keyword">auto</span> f = [v1] &#123;<span class="hljs-keyword">return</span> v1;&#125;;<br> v1 = <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">auto</span> j = <span class="hljs-built_in">f</span>(); <span class="hljs-comment">//j = 42，创建时拷⻉，修改对lambda内对象⽆影响</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fcn</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//可变lambda</span><br> <span class="hljs-type">size_t</span> v1 = <span class="hljs-number">42</span>;<br> <span class="hljs-keyword">auto</span> f = [v1] () <span class="hljs-keyword">mutable</span> &#123;<span class="hljs-keyword">return</span> ++v1;&#125;; <span class="hljs-comment">//修改值捕获可加mutable</span><br> v1 = <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">auto</span> j = <span class="hljs-built_in">f</span>(); <span class="hljs-comment">//j = 43</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fcn</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//引⽤捕获</span><br> <span class="hljs-type">size_t</span> v1 = <span class="hljs-number">42</span>; <span class="hljs-comment">//⾮const</span><br> <span class="hljs-keyword">auto</span> f = [&amp;v1] () &#123;<span class="hljs-keyword">return</span> ++v1;&#125;;<br> v1 = <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">auto</span> j = <span class="hljs-built_in">f</span>(); <span class="hljs-comment">//注意此时 j = 1</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>（2）lambda最⼤的⼀个优势是在使⽤STL中的算法(algorithms)库 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; a, <span class="hljs-type">int</span>&amp; b)</span> </span>&#123; <span class="hljs-comment">//谓词函数</span><br> <span class="hljs-keyword">return</span> a &gt; b;<br>&#125;<br>std::<span class="hljs-built_in">sort</span>(arr, arr + <span class="hljs-number">6</span>, compare);<br><span class="hljs-comment">//lambda形式</span><br>std::<span class="hljs-built_in">sort</span>(arr, arr + <span class="hljs-number">6</span>, [](<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; a, <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; b)&#123;<span class="hljs-keyword">return</span> a &gt; b;&#125;); <span class="hljs-comment">//降序</span><br>std::for_each(<span class="hljs-built_in">begin</span>(arr), <span class="hljs-built_in">end</span>(arr), [](<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; e)&#123;cout &lt;&lt; <span class="hljs-string">&quot;After:&quot;</span> &lt;&lt; e &lt;&lt; endl;&#125;); <br><span class="hljs-comment">//6, 5, 4, 3, 2, 1 </span><br></code></pre></td></tr></table></figure>

<h1 id="测开通用知识"><a href="#测开通用知识" class="headerlink" title="测开通用知识"></a>测开通用知识</h1><h2 id="1、谈一谈对测试的理解？"><a href="#1、谈一谈对测试的理解？" class="headerlink" title="1、谈一谈对测试的理解？"></a>1、谈一谈对测试的理解？</h2><p>1、测试不仅仅是找出错误，还包括验证软件的功能、性能、可靠性以及用户体验等方面，发现其中的问题并及时解决。</p>
<p>2、测试可以提前发现和修复存在的缺陷，减少后期的维护成本，对于保障软件的质量和提升用户满意度十分重要。</p>
<h2 id="2、测试开发需要哪些知识？"><a href="#2、测试开发需要哪些知识？" class="headerlink" title="2、测试开发需要哪些知识？"></a>2、测试开发需要哪些知识？</h2><p>1、编程技能，测试人员需要至少掌握一门编程语言，编写一些自动化脚本和工具。</p>
<p>2、掌握测试的基本知识，比如理解不同类型的测试、如单元测试、集成测试、系统测试和验收测试等，掌握黑盒测试和白盒测试的原理和使用场景。</p>
<p>3、了解如何进行需求分析，能够设计有效的测试用例和测试计划</p>
<p>4、熟悉常用的测试工具和框架，比如JMeter、Jenkins等</p>
<h2 id="3、测试需要哪些能力？"><a href="#3、测试需要哪些能力？" class="headerlink" title="3、测试需要哪些能力？"></a>3、测试需要哪些能力？</h2><p>1、分析能力：测试开发首先要能够理解复杂的软件系统和业务流程，并设计有效的测试用例。</p>
<p>2、技术能力：对于测试开发职位，编程能力也是必要的，测试开发要求测试人员了解不同的编程语言和测试框架，能够编写自动化的测试脚本。</p>
<p>3、细节和认真观察的能力：测试要对细节高度敏感，善于发现bug。</p>
<p>4、沟通能力：要与开发团队、产品经理进行沟通，确保测试的结果被准确传达。</p>
<p>5、学习能力：测试是一个不断发展的领域，需要不断地学习相关的测试知识和业务知识。</p>
<p>6、解决问题的能力：遇到问题是能够有效的分析问题的根源并提出解决方案。</p>
<h2 id="4、讲一下你们的测试流程"><a href="#4、讲一下你们的测试流程" class="headerlink" title="4、讲一下你们的测试流程"></a>4、讲一下你们的测试流程</h2><p>1、需求分析：测试首先要了解软件的功能需求，所以需要开需求评审会议，分析和讨论软件的具体功能需求。</p>
<p>2、制定测试计划：针对软件的需求，明确测试的范围、方法、资源分配、时间表和测试的目标。</p>
<p>3、测试用例设计：基于制定的测试计划，设计详细的测试用例。这些测试用例应该覆盖软件所有的功能点，包括正常情况和边界情况的测试。</p>
<p>4、针对提出的测试用例进行开会讨论，修改并审核，防止错误测试用例的发生。</p>
<p>5、搭建和配置合适的测试环境，执行测试用例。记录测试结果，将测试过程中发现的缺陷（bug）报告给开发团队。</p>
<p>6、回归测试：每当代码发生更改时，执行回归测试以确保新的更改没有破坏现有的功能。</p>
<p>7、性能测试：评估系统的响应时间、稳定性和扩展性。</p>
<p>8、部署项目到预生产环境，在预生产环境进行测试。</p>
<p>9、编写测试报告，总结测试的结果，包括测试覆盖率，发现的缺陷和为解决的问题。</p>
<p>10、项目上线后，根据反馈进行复盘和总结。</p>
<p>PS：根据岸基界面的开发流程可以结合自己的实际操作进行描述，这样更真实和有效。</p>
<h2 id="5、针对测试流程，会输出哪些材料？"><a href="#5、针对测试流程，会输出哪些材料？" class="headerlink" title="5、针对测试流程，会输出哪些材料？"></a>5、针对测试流程，会输出哪些材料？</h2><p>1、测试计划：描述整个测试过程的策略、范围、资源、时间表和目标</p>
<p>2、测试用例：详细的步骤、预期结果和测试数据，用于验证软件功能是否符合需求</p>
<p>3、测试脚本：自动化测试的脚本代码</p>
<p>4、错误报告：在测试过程中发现的缺陷、包括缺陷描述、重现步骤、影响范围和严重程度</p>
<p>5、测试执行日志：记录测试用例执行的详细过程，以及测试用例的执行结果</p>
<p>6、测试环境的配置文档</p>
<p>7、测试报告：总结整个测试周期的活动、发现的缺陷、测试覆盖率和最终的测试评估。</p>
<h2 id="6、说一下测试常用方法"><a href="#6、说一下测试常用方法" class="headerlink" title="6、说一下测试常用方法"></a>6、说一下测试常用方法</h2><p>1、功能测试：检查软件的各项功能是否按照需求规格书执行，包括用户界面、数据库、安全性等。</p>
<p>2、单元测试：测试软件中最小的可测试部分，验证这些单元在各种条件下都按预期工作</p>
<p>3、集成测试：测试多个单元、模块或组件协同工作时是否能正常工作。</p>
<p>4、系统测试：测试完整、集成的软件系统来评估系统的符合度，通常包括功能性和非功能性测试。</p>
<p>5、回归测试：在发⽣修改之后重新测试先前的测试⽤例以保证修改的正确性。</p>
<p>6、性能测试：检查软件的速度、响应时间、稳定性、资源消耗等性能指标。包括<strong>负载测试</strong>、 <strong>压⼒测试</strong>和<strong>稳定性测试</strong>。</p>
<p>7、 验收测试：确定软件是否满⾜其业务需求。验收测试是软件交付之前的最后⼀阶段测试。 验收测试包括 Alpha 测试和 Beta 测试。</p>
<p>Alpha测试：是由<strong>⽤户在开发者的场所来进⾏的</strong>，在⼀个受控的环境中进⾏。 </p>
<p>Beta测试：<strong>由软件的最终⽤户在⼀个或多个⽤户场所来进⾏</strong>的，开发者通常不在现场，⽤户记录测试中遇到的问题并报告给开发者，开发者对系统进⾏最后的修改，并开始准备发布最终的软件。</p>
<h2 id="7、说一说对单元测试和集成测试的了解"><a href="#7、说一说对单元测试和集成测试的了解" class="headerlink" title="7、说一说对单元测试和集成测试的了解"></a>7、说一说对单元测试和集成测试的了解</h2><p>1、单元测试是针对软件的<strong>最⼩可测试部分</strong>（通常是⼀个函数、⽅法或类）进⾏的测试。通常在编写或修改代码后⽴即进⾏，以快速发现和修正代码中的错误，常⽤的⼯具包括JUnit （Java）、PyTest（Python）等。</p>
<p>2、集成测试是在<strong>多个模块或组件被集成在⼀起后进⾏的测试</strong>，⽤来验证不同模块之间的接⼝和交互是否按预期⼯作，通常使⽤集成测试框架，⽐如<strong>Postman</strong>（API测试）、<strong>Selenium</strong> （Web应⽤集成测试）来进⾏。</p>
<p>涉及到<strong>增量集成</strong>：逐步添加新的模块并测试；<strong>大爆炸集成</strong>：集成所有模块后一次性测试。</p>
<h2 id="8、系统测试和集成测试的区别和使用场景"><a href="#8、系统测试和集成测试的区别和使用场景" class="headerlink" title="8、系统测试和集成测试的区别和使用场景"></a>8、系统测试和集成测试的区别和使用场景</h2><p>1、系统测试是在整个软件系统完成集成后进⾏的测试。它的⽬的是<strong>验证整个系统是否符合指定的需求</strong>，关注整个系统的⾏为，测试涵盖所有集成的模块，以确保它们作为⼀个完整的系统正确地协同⼯作，包含功能性测试（如功能完整性、⽤户界⾯、⽤户流程）和⾮功能性测试（如性能、安全性、兼容性）。</p>
<p>2、 集成测试是在多个软件模块或组件被集成在⼀起时进⾏的测试。它的⽬的是<strong>验证这些模块或组件之间的交互</strong>，关注于模块之间的接⼝和交互。确保不同模块的数据交换和功能协作 符合预期，主要⽤来检查数据传递、接⼝调⽤、异常处理等模块间交互的⽅⾯。</p>
<p>集成测试通常在单元测试之后、系统测试之前进⾏，当整个应⽤开发接近完成时，进⾏系统测试。</p>
<h2 id="9、什么是黑盒测试"><a href="#9、什么是黑盒测试" class="headerlink" title="9、什么是黑盒测试"></a>9、什么是黑盒测试</h2><p>黑盒测试，也被称为功能测试或⾏为测试，测试者只关注软件的输⼊和输出，不需要了解程序的内部实现，主要验证软件的功能是否符合⽤户需求和规格说明。常⽤的测试⽅法包括<strong>等价类划分、边界值分析、因果图法、状态转换测试、错误猜测等</strong>。 </p>
<p>⿊盒测试：想象你在玩⼀款新游戏，你只关⼼游戏的功能、操作和画⾯，⽽不需要知道游戏的源代码或内部实现。你测试游戏的可玩性、故事情节等，这就是⿊盒测试。</p>
<h2 id="10、什么是白盒测试"><a href="#10、什么是白盒测试" class="headerlink" title="10、什么是白盒测试"></a>10、什么是白盒测试</h2><p>白盒测试，也称为结构测试或透明盒测试，测试者需要了解程序的内部⼯作机制，包括代码、 逻辑流程、内部结构，主要验证代码的逻辑路径、分⽀覆盖、循环、语句覆盖等，常⽤的测试⽅法包括<strong>路径覆盖、条件覆盖、循环覆盖、语句覆盖等，主要适⽤于单元测试和集成测试</strong>。</p>
<p>⽩盒测试：如果你是游戏开发者，你可能需要检查游戏的源代码，确保每个游戏功能都按照设计要求正确实现。这就是⽩盒测试。</p>
<h2 id="11、说一说等价类划分和边界值法"><a href="#11、说一说等价类划分和边界值法" class="headerlink" title="11、说一说等价类划分和边界值法"></a>11、说一说等价类划分和边界值法</h2><p>1、等价类划分</p>
<p>等价类划分是将系统的输入域划分为若干部分，然后从每个部分选取少量代表性数据进行测试。等价类划分认为如果⼀个测试⽤例在某个等价类中的⼀个值上通过测试，那么它在这个类中的其他值上也会通过，<strong>适⽤于输⼊数据较多的情况，有助于减少测试⽤例的数量并保证覆盖率。</strong></p>
<p>有效等价类：符合规格说明的输入条件</p>
<p>无效等价类：不符合规格说明的输入条件</p>
<p><strong>通过测试有效等价类来验证系统的正确性，通过⽆效等价类来验证系统的健壮性。</strong></p>
<p>2、边界值法</p>
<p>软件错误往往发⽣在输⼊或输出范围的边缘，所以边界值分析专注于测试输⼊数据的边界条 件，⽽不是中间值，包括正常边界值（最⼤、最⼩值）和异常边界最⼤值+1、最⼩值-1），适⽤于测试那些对输⼊数据有明确范围或限制的功能。</p>
<h2 id="12、等价类划分的难点是什么？"><a href="#12、等价类划分的难点是什么？" class="headerlink" title="12、等价类划分的难点是什么？"></a>12、等价类划分的难点是什么？</h2><p>1、正确定义等价类：确定等价类的难点在于正确理解需求和规格说明。如果对需求的理解不准确或不全⾯，可能导致等价类的定义不准确，从⽽影响测试覆盖率和有效性。</p>
<p>2、识别有效和⽆效的等价类：不仅要识别有效的等价类（符合规格说明的输⼊条件），还要 能够识别出⽆效的等价类（不符合规格说明的输⼊条件）</p>
<p>3、处理复杂的输⼊条件：当输⼊条件⾮常复杂或者相互依赖时，定义清晰且准确的等价类变得更加困难。</p>
<h2 id="13、接口测试用例的编写需要注意哪些要点"><a href="#13、接口测试用例的编写需要注意哪些要点" class="headerlink" title="13、接口测试用例的编写需要注意哪些要点"></a>13、接口测试用例的编写需要注意哪些要点</h2><p>1、明确接⼝规格：理解接⼝的功能、输⼊输出参数、数据格式、请求⽅法（如GET、 POST、PUT、DELETE等）和预期的⾏为。</p>
<p>2、返回值：各种情况下（正确的输⼊值和异常的输⼊值）下的响应内容是否正常 。</p>
<p>3、接⼝的业务逻辑和功能是否正常</p>
<p>4、数据库校验 </p>
<p>5、性能测试（接⼝ tps, 响应时间等） </p>
<p>6、安全性，敏感信息加密，权限控制等。</p>
<h2 id="14、接口测试有哪些工具"><a href="#14、接口测试有哪些工具" class="headerlink" title="14、接口测试有哪些工具"></a>14、接口测试有哪些工具</h2><p>Postman： API测试⼯具，⽤于发送各种HTTP请求，并检查响应，⽀持⾃动化测试脚本编写。</p>
<p>JMeter :主要⽤于性能测试和负载测试，但也可以⽤于API测试。 </p>
<p>Swagger UI ： ⽤于设计、构建、⽂档化和测试REST API的⼯具</p>
<h2 id="15、你是如何测试接口的"><a href="#15、你是如何测试接口的" class="headerlink" title="15、你是如何测试接口的"></a>15、你是如何测试接口的</h2><p>1、理解接⼝⽂档，了解接⼝的业务功能，请求⽅法、请求参数、响应结构、错误码以及对应的数据库存储 </p>
<p>2、编写测试⽤例，涵盖正常的输⼊情况（验证接⼝的功能性）和异常的输⼊情况（验证接⼝的健壮性和错误处理 ）</p>
<p>3、使⽤测试⼯具，⽐如 Postman 执⾏测试⽤例，观察响应是否符合预期，验证响应的状态码、响应体内容、响应时间等。</p>
<h2 id="16、性能测试时，一般关注哪些指标？"><a href="#16、性能测试时，一般关注哪些指标？" class="headerlink" title="16、性能测试时，一般关注哪些指标？"></a>16、性能测试时，一般关注哪些指标？</h2><p>1、TPS：每秒事务数量，代表性能的好坏，TPS越高，性能越好。</p>
<p>2、平均响应时间：请求的平均耗时，时间越短、性能越好。</p>
<p>3、并发数：同时向服务端发起请求的虚拟用户数量，在不同的工具里可以利用不同的线程或进程来实现。</p>
<p>4、错误率：失败请求的比例，越低性能越好。</p>
<h2 id="17、功能测试用例一般包含哪些内容？"><a href="#17、功能测试用例一般包含哪些内容？" class="headerlink" title="17、功能测试用例一般包含哪些内容？"></a>17、功能测试用例一般包含哪些内容？</h2><p>1、测试⽤例<strong>ID</strong>：⼀个唯⼀标识符，⽤于区分和引⽤测试⽤例。 </p>
<p>2、测试⽤例<strong>标题</strong>：简短描述测试⽤例的⽬的或主要功能。</p>
<p>3、功能模块：指明此测试⽤例所属的软件功能模块或部分。</p>
<p>4、测试⽬的&#x2F;描述：对测试⽤例的⽬标和测试内容的详细描述。 </p>
<p>5、<strong>前置条件</strong>：执⾏测试⽤例之前需要满⾜的条件，<strong>如特定的系统状态或配置</strong>。 </p>
<p>6、<strong>测试步骤</strong>：详细描述如何执⾏测试，包括⽤户如何与系统交互，每⼀步应该输⼊什么数 据，选择哪些选项等。 </p>
<p>7、测试数据：在测试中使⽤的具体数据，包括输⼊值和需要验证的输出值。 </p>
<p>8、<strong>预期结果</strong>：描述在成功执⾏测试步骤后预期的系统⾏为或输出。 </p>
<p>9、<strong>实际结果</strong>：在执⾏测试后记录的实际结果，⽤于与预期结果进⾏⽐较。 </p>
<p>10、通过&#x2F;失败标准：定义何种条件下测试⽤例被认为是通过或失败。 </p>
<p>11、<strong>测试环境</strong>：描述执⾏测试⽤例所需的软件、硬件、⽹络配置等环境信息。 </p>
<p>12、备注信息：任何额外的信息，⽐如相关的依赖、特殊注意事项等。 </p>
<p>13、<strong>缺陷&#x2F;问题ID</strong>：如果测试失败，关联的缺陷或问题的标识符。</p>
<h2 id="18、如何写测试用例"><a href="#18、如何写测试用例" class="headerlink" title="18、如何写测试用例"></a>18、如何写测试用例</h2><p>1、测试⼈员尽早介⼊，彻底理解清楚需求，这个是写好测试⽤例的基础</p>
<p>2、如果以前有类似的需求，可以参考类似需求的测试⽤例，然后还需要看类似需求的bug情况 </p>
<p>3、清楚输⼊、输出的各种可能性，以及各种输⼊的之间的关联关系，理解清楚需求的执⾏逻 辑，通过等价类、边界值、判定表等⽅法找出⼤部分⽤例 </p>
<p>4、找到需求相关的⼀些特性，补充测试⽤例 </p>
<p>5、根据⾃⼰的经验分析遗漏的测试场景 多总结类似功能点的测试点，才能够写出质量越来越⾼的测试⽤例 </p>
<p>6、书写格式清晰</p>
<h2 id="19、说一下设计测试用例的方法"><a href="#19、说一下设计测试用例的方法" class="headerlink" title="19、说一下设计测试用例的方法"></a>19、说一下设计测试用例的方法</h2><p>⿊盒测试⽅法： </p>
<p>1、等价类划分法：将输⼊数据划分为不同的等价类，每个等价类都有相似的⾏为。然后从每 个等价类中选择测试⽤例。 </p>
<p>2、边界值分析法：关注输⼊值的边界情况，测试接近边界值和边界之间的情况。</p>
<p>3、 因果图法：使⽤因果图来识别和描述系统中各种因果关系，辅助设计测试⽤例。 </p>
<p>4、决策表测试：创建决策表，列出不同的输⼊组合和相应的输出，确保所有可能的组合都得 到测试。</p>
<p>6、 状态转换测试：适⽤于有状态的系统，测试系统在不同状态下的⾏为和状态之间的转换。 </p>
<p>⽩盒测试⽅法： </p>
<p>1、语句覆盖：确保每个源代码语句都⾄少执⾏⼀次。测试⽤例的⽬标是覆盖代码的所有语 句。</p>
<p>2、 分⽀覆盖：确保每个分⽀语句都⾄少执⾏⼀次，以测试代码中的条件语句。</p>
<p>3、 路径覆盖：通过执⾏代码的所有可能路径来测试系统，包括所有可能的条件分⽀和循环。 </p>
<p>4、条件覆盖：测试代码中条件表达式的所有可能取值，以确保所有条件的不同情况都被覆盖。 </p>
<p>5、循环覆盖：确保测试覆盖了循环的不同情况，包括循环的⼊⼝、中间和退出。</p>
<h2 id="20、如何提高用例的覆盖率"><a href="#20、如何提高用例的覆盖率" class="headerlink" title="20、如何提高用例的覆盖率"></a>20、如何提高用例的覆盖率</h2><p>1、根据需求⽂档编写⽤例，确保每条需求都能被对应的⽤例覆盖 </p>
<p>2、要充分理解业务，挖掘隐形需求，并编写对应的⽤例 </p>
<p>3、除了正常的业务场景，多考虑⼀些异常的场景和数据 </p>
<p>4、要从多个维度对软件进⾏测试，功能、性能、安全等各⽅⾯来考虑 </p>
<p>5、多站在⽤户的⻆度去思考问题，模拟⽤户的使⽤场景 </p>
<p>6、组织⽤例评审</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>八股基础</div>
      <div>http://example.com/2024/05/10/八股基础/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>ZDS</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年5月10日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/05/27/%E5%9F%BA%E4%BA%8E%E8%B7%B3%E8%A1%A8%E7%9A%84KV%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E9%A1%B9%E7%9B%AE/" title="基于跳表的KV存储引擎项目">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">基于跳表的KV存储引擎项目</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/05/09/%E6%B0%B4%E4%B8%8B%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%B2%B8%E5%9F%BA%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91/" title="水下机器人岸基客户端开发">
                        <span class="hidden-mobile">水下机器人岸基客户端开发</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>

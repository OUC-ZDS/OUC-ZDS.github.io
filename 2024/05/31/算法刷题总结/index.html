

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/icon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="ZDS">
  <meta name="keywords" content="">
  
    <meta name="description" content="单调栈刷题总结1、力扣题目（每日温度）https:&#x2F;&#x2F;leetcode.cn&#x2F;problems&#x2F;daily-temperatures&#x2F; （下一个更大元素|）https:&#x2F;&#x2F;leetcode.cn&#x2F;problems&#x2F;next-greater-element-i&#x2F; （下一个更大元素||）https:&#x2F;&#x2F;leetcode.cn&#x2F;problems&#x2F;next-greater-element-ii&#x2F; （接雨水">
<meta property="og:type" content="article">
<meta property="og:title" content="算法刷题总结">
<meta property="og:url" content="http://example.com/2024/05/31/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="佑安的个人博客">
<meta property="og:description" content="单调栈刷题总结1、力扣题目（每日温度）https:&#x2F;&#x2F;leetcode.cn&#x2F;problems&#x2F;daily-temperatures&#x2F; （下一个更大元素|）https:&#x2F;&#x2F;leetcode.cn&#x2F;problems&#x2F;next-greater-element-i&#x2F; （下一个更大元素||）https:&#x2F;&#x2F;leetcode.cn&#x2F;problems&#x2F;next-greater-element-ii&#x2F; （接雨水">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="c:\Users\zhangdengsheng\AppData\Roaming\Typora\typora-user-images\image-20240509151300969.png">
<meta property="og:image" content="c:\Users\zhangdengsheng\AppData\Roaming\Typora\typora-user-images\image-20240527141917546.png">
<meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20201123195242899.png">
<meta property="og:image" content="c:\Users\zhangdengsheng\AppData\Roaming\Typora\typora-user-images\image-20240529151310928.png">
<meta property="og:image" content="c:\Users\zhangdengsheng\AppData\Roaming\Typora\typora-user-images\image-20240530134545898.png">
<meta property="article:published_time" content="2024-05-31T00:47:36.000Z">
<meta property="article:modified_time" content="2024-05-31T09:43:37.977Z">
<meta property="article:author" content="ZDS">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="c:\Users\zhangdengsheng\AppData\Roaming\Typora\typora-user-images\image-20240509151300969.png">
  
  
  
  <title>算法刷题总结 - 佑安的个人博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>佑安的个人博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="算法刷题总结"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-05-31 08:47" pubdate>
          2024年5月31日 早上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          38k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          319 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">算法刷题总结</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="单调栈刷题总结"><a href="#单调栈刷题总结" class="headerlink" title="单调栈刷题总结"></a>单调栈刷题总结</h1><h2 id="1、力扣题目"><a href="#1、力扣题目" class="headerlink" title="1、力扣题目"></a>1、力扣题目</h2><p>（每日温度）<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/daily-temperatures/">https://leetcode.cn/problems/daily-temperatures/</a></p>
<p>（下一个更大元素|）<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-greater-element-i/">https://leetcode.cn/problems/next-greater-element-i/</a></p>
<p>（下一个更大元素||）<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-greater-element-ii/">https://leetcode.cn/problems/next-greater-element-ii/</a></p>
<p>（接雨水）<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trapping-rain-water/">https://leetcode.cn/problems/trapping-rain-water/</a></p>
<p>（最大矩形面积）<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">https://leetcode.cn/problems/largest-rectangle-in-histogram/</a></p>
<h2 id="2、学习笔记"><a href="#2、学习笔记" class="headerlink" title="2、学习笔记"></a>2、学习笔记</h2><p>（1）什么是单调栈：利用一维数组模拟栈，按照从大到小或者从小到大的顺序，去记录遍历过的元素或者元素下标，利用空间换取时间的一种方式。</p>
<p>（2）什么时候适用单调栈解题：当需要寻找一个元素的左边或者右边第一个比自己大或者小的元素的时候，可以考虑使用单调栈。</p>
<p>（3）在使用单调栈的时候首先要明确如下几点：</p>
<ol>
<li>单调栈里存放的元素是什么？</li>
</ol>
<p>单调栈里只需要存放元素的下标i就可以了，如果需要使用对应的元素，直接T[i]就可以获取。</p>
<ol>
<li>单调栈里元素是递增呢？ 还是递减呢？</li>
</ol>
<p><strong>注意以下讲解中，顺序的描述为 从栈头到栈底的顺序</strong>，因为单纯的说从左到右或者从前到后，不说栈头朝哪个方向的话，大家一定比较懵。</p>
<p>这里我们要使用递增循序（再强调一下是指从栈头到栈底的顺序），因为只有递增的时候，栈里要加入一个元素i的时候，才知道栈顶元素在数组中右面第一个比栈顶元素大的元素是i。</p>
<p>即：如果求一个元素右边第一个更大元素，单调栈就是递增的，如果求一个元素右边第一个更小元素，单调栈就是递减的。</p>
<p>（4）使用单调栈主要有三个判断条件：</p>
<ul>
<li>当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况</li>
<li>当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况</li>
<li>当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况</li>
</ul>
<h2 id="3、刷题总结"><a href="#3、刷题总结" class="headerlink" title="3、刷题总结"></a>3、刷题总结</h2><h3 id="（1）每日温度："><a href="#（1）每日温度：" class="headerlink" title="（1）每日温度："></a>（1）每日温度：</h3><p>理清楚单调栈在递增情况下，三个判断条件对应的处理逻辑，本题求的是下一个比自己高的元素距离自己的距离，所以在收集结果的时候统计的是下标之间的差值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; T)</span> </span>&#123;<br>        <span class="hljs-comment">// 递增栈</span><br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(T.size(), <span class="hljs-number">0</span>)</span></span>;<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; T.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (T[i] &lt; T[st.<span class="hljs-built_in">top</span>()]) &#123;                       <span class="hljs-comment">// 情况一</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (T[i] == T[st.<span class="hljs-built_in">top</span>()]) &#123;               <span class="hljs-comment">// 情况二</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; T[i] &gt; T[st.<span class="hljs-built_in">top</span>()]) &#123; <span class="hljs-comment">// 情况三 收集结果是两个元素之间的距离</span><br>                    result[st.<span class="hljs-built_in">top</span>()] = i - st.<span class="hljs-built_in">top</span>();<br>                    st.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="（2）下一个更大元素-："><a href="#（2）下一个更大元素-：" class="headerlink" title="（2）下一个更大元素|："></a>（2）下一个更大元素|：</h3><p>相较于上面一道题目，讨论一个外壳，其本质还是单调栈的思路。不同的是，需要在nums2中找nums1中的元素的下一个比它大的值，可以看出顺序还是从小到大的单调栈。但是需要map做映射，方便判断nums2[i]是否在nums1中出现过。C++中，当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的。</p>
<p>接下来就要分析如下三种情况：</p>
<ol>
<li>情况一：当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况</li>
</ol>
<p>此时满足递增栈（栈头到栈底的顺序），所以直接入栈。</p>
<ol>
<li>情况二：当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况</li>
</ol>
<p>如果相等的话，依然直接入栈，因为我们要求的是右边第一个比自己大的元素，而不是大于等于！</p>
<ol>
<li>情况三：当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况</li>
</ol>
<p>此时如果入栈就不满足递增栈了，这也是找到右边第一个比自己大的元素的时候。</p>
<p>判断栈顶元素是否在nums1里出现过，（注意栈里的元素是nums2的元素），如果出现过，开始记录结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(nums1.size(), <span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-keyword">if</span> (nums1.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result;<br><br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; umap; <span class="hljs-comment">// key:下标元素，value：下标</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums1.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            umap[nums1[i]] = i;<br>        &#125;<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums2.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums2[i] &lt; nums2[st.<span class="hljs-built_in">top</span>()]) &#123;           <span class="hljs-comment">// 情况一</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums2[i] == nums2[st.<span class="hljs-built_in">top</span>()]) &#123;   <span class="hljs-comment">// 情况二</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">else</span> &#123;                                    <span class="hljs-comment">// 情况三</span><br>                <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; nums2[i] &gt; nums2[st.<span class="hljs-built_in">top</span>()]) &#123;<br>                    <span class="hljs-keyword">if</span> (umap.<span class="hljs-built_in">count</span>(nums2[st.<span class="hljs-built_in">top</span>()]) &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 看map里是否存在这个元素</span><br>                        <span class="hljs-type">int</span> index = umap[nums2[st.<span class="hljs-built_in">top</span>()]]; <span class="hljs-comment">// 根据map找到nums2[st.top()] 在 nums1中的下标。记录结果这块逻辑有一点小绕，要清楚，此时栈顶元素在nums2数组中右面第一个大的元素是nums2[i]（即当前遍历元素</span><br>                        result[index] = nums2[i];<br>                    &#125;<br>                    st.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="（3）下一个更大元素"><a href="#（3）下一个更大元素" class="headerlink" title="（3）下一个更大元素||"></a>（3）下一个更大元素||</h3><p>对比上一题，数组变成环形了，需要模拟走了两边数组来解题，（1 2  1 1 2 1）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElements</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(nums.size(), <span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>() * <span class="hljs-number">2</span>; i++) &#123; <br>            <span class="hljs-comment">// 模拟遍历两边nums，注意一下都是用i % nums.size()来操作 防止遍历越界</span><br>            <span class="hljs-keyword">if</span> (nums[i % nums.<span class="hljs-built_in">size</span>()] &lt; nums[st.<span class="hljs-built_in">top</span>()]) st.<span class="hljs-built_in">push</span>(i % nums.<span class="hljs-built_in">size</span>());<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i % nums.<span class="hljs-built_in">size</span>()] == nums[st.<span class="hljs-built_in">top</span>()]) st.<span class="hljs-built_in">push</span>(i % nums.<span class="hljs-built_in">size</span>()); <br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i % nums.<span class="hljs-built_in">size</span>()] &gt; nums[st.<span class="hljs-built_in">top</span>()]) &#123;<br>                    result[st.<span class="hljs-built_in">top</span>()] = nums[i % nums.<span class="hljs-built_in">size</span>()];<br>                    st.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>                st.<span class="hljs-built_in">push</span>(i % nums.<span class="hljs-built_in">size</span>());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="（4）接雨水"><a href="#（4）接雨水" class="headerlink" title="（4）接雨水"></a>（4）接雨水</h3><img src="C:\Users\zhangdengsheng\AppData\Roaming\Typora\typora-user-images\image-20240509151300969.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<p>处理逻辑同单调栈的从小到大顺序相同，在收获结果的时候，要注意计算方式。</p>
<p>当当前元素大于栈顶元素了，取栈顶元素，将栈顶元素弹出，这个就是凹槽的底部，也就是中间位置，下标记为mid，对应的高度为height[mid]。</p>
<p>此时的栈顶元素st.top()，就是凹槽的左边位置，下标为st.top()，对应的高度为height[st.top()]。</p>
<p>当前遍历的元素i，就是凹槽右边的位置，下标为i，对应的高度为height[i]。</p>
<p>此时大家应该可以发现其实就是<strong>栈顶和栈顶的下一个元素以及要入栈的元素，三个元素来接水！</strong></p>
<p>那么雨水高度是 min(凹槽左边高度, 凹槽右边高度) - 凹槽底部高度，代码为：<code>int h = min(height[st.top()], height[i]) - height[mid];</code></p>
<p>雨水的宽度是 凹槽右边的下标 - 凹槽左边的下标 - 1（因为只求中间宽度），代码为：<code>int w = i - st.top() - 1 ;</code></p>
<p>当前凹槽雨水的体积就是：<code>h * w</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (height.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 可以不加</span><br>        stack&lt;<span class="hljs-type">int</span>&gt; st; <span class="hljs-comment">// 存着下标，计算的时候用下标对应的柱子高度</span><br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; height.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (height[i] &lt; height[st.<span class="hljs-built_in">top</span>()]) &#123;     <span class="hljs-comment">// 情况一</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">if</span> (height[i] == height[st.<span class="hljs-built_in">top</span>()]) &#123;  <span class="hljs-comment">// 情况二</span><br>                st.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 其实这一句可以不加，效果是一样的，但处理相同的情况的思路却变了。</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">else</span> &#123;                                <span class="hljs-comment">// 情况三</span><br>                <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; height[i] &gt; height[st.<span class="hljs-built_in">top</span>()]) &#123; <span class="hljs-comment">// 注意这里是while</span><br>                    <span class="hljs-type">int</span> mid = st.<span class="hljs-built_in">top</span>();<br>                    st.<span class="hljs-built_in">pop</span>();<br>                    <span class="hljs-keyword">if</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>                        <span class="hljs-type">int</span> h = <span class="hljs-built_in">min</span>(height[st.<span class="hljs-built_in">top</span>()], height[i]) - height[mid];<br>                        <span class="hljs-type">int</span> w = i - st.<span class="hljs-built_in">top</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意减一，只求中间宽度</span><br>                        sum += h * w;<br>                    &#125;<br>                &#125;<br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="（5）矩形柱子的最大面积"><a href="#（5）矩形柱子的最大面积" class="headerlink" title="（5）矩形柱子的最大面积"></a>（5）矩形柱子的最大面积</h3><p>本题将单调栈的顺序变成了从大到小，处理逻辑也要取反。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; heights)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        heights.<span class="hljs-built_in">insert</span>(heights.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">0</span>); <span class="hljs-comment">// 数组头部加入元素0</span><br>        heights.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 数组尾部加入元素0</span><br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">// 第一个元素已经入栈，从下标1开始</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; heights.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (heights[i] &gt; heights[st.<span class="hljs-built_in">top</span>()]) &#123; <span class="hljs-comment">// 情况一</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (heights[i] == heights[st.<span class="hljs-built_in">top</span>()]) &#123; <span class="hljs-comment">// 情况二</span><br>                st.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 这个可以加，可以不加，效果一样，思路不同</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 情况三</span><br>                <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; heights[i] &lt; heights[st.<span class="hljs-built_in">top</span>()]) &#123; <span class="hljs-comment">// 注意是while</span><br>                    <span class="hljs-type">int</span> mid = st.<span class="hljs-built_in">top</span>();<br>                    st.<span class="hljs-built_in">pop</span>();<br>                    <span class="hljs-keyword">if</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>                        <span class="hljs-type">int</span> left = st.<span class="hljs-built_in">top</span>();<br>                        <span class="hljs-type">int</span> right = i;<br>                        <span class="hljs-type">int</span> w = right - left - <span class="hljs-number">1</span>;<br>                        <span class="hljs-type">int</span> h = heights[mid];<br>                        result = <span class="hljs-built_in">max</span>(result, w * h);<br>                    &#125;<br>                &#125;<br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="动态规划刷题总结"><a href="#动态规划刷题总结" class="headerlink" title="动态规划刷题总结"></a>动态规划刷题总结</h1><p>DP（动态规划）当前状态是由上一时刻的状态推导而来的。</p>
<p>动态规划五部曲：</p>
<p>1、确定dp数组以及其下标的含义</p>
<p>2、确定递推公式（状态转移公式）</p>
<p>3、dp数组如何初始化</p>
<p>4、确定遍历顺序</p>
<p>5、打印出dp数组，判断问题出在哪。</p>
<h2 id="1、斐波那契数列"><a href="#1、斐波那契数列" class="headerlink" title="1、斐波那契数列"></a>1、斐波那契数列</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fibonacci-number/">https://leetcode.cn/problems/fibonacci-number/</a></p>
<p>入门级别的动态规划，重点在于动态规划五部曲的使用，方法论的实现。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">// 方法一：动规五部曲</span><br>    <span class="hljs-comment">//     if(n &lt;= 1) return n;</span><br>    <span class="hljs-comment">//     vector&lt;int&gt; dp(n+1);// 1、确定dp数组即下标含义：下标为i的元素的斐波那契数列的值</span><br>    <span class="hljs-comment">//     dp[0] = 0;</span><br>    <span class="hljs-comment">//     dp[1] = 1; // 3、dp数组初始化</span><br>    <span class="hljs-comment">//     for(int i=2;i&lt;=n;i++)&#123;// 4、确定遍历顺序</span><br>    <span class="hljs-comment">//         dp[i] = dp[i-1] + dp[i-2];// 2、确定递推公式</span><br>    <span class="hljs-comment">//     &#125;</span><br>    <span class="hljs-comment">//     return dp[n];</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// 方法二：用两个数组维护就可以实现，节约空间</span><br>    <span class="hljs-keyword">if</span>(n &lt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;<br>    <span class="hljs-type">int</span> dp[<span class="hljs-number">2</span>];<span class="hljs-comment">// 确定dp数组</span><br>    dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    dp[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-comment">//dp数组初始化</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-type">int</span> sum = dp[<span class="hljs-number">0</span>]+dp[<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>]= dp[<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">1</span>]=sum; <span class="hljs-comment">// 变相实现递推公式：dp[i] = dp[i-1]+dp[i-2];</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2、爬楼梯"><a href="#2、爬楼梯" class="headerlink" title="2、爬楼梯"></a>2、爬楼梯</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/">https://leetcode.cn/problems/climbing-stairs/</a></p>
<p>动规五部曲：</p>
<p>定义一个一维数组来记录不同楼层的状态</p>
<p>1、确定dp数组以及下标的含义</p>
<p>dp[i]： <strong>爬到第i层楼梯，有dp[i]种方法</strong></p>
<p>2、确定递推公式</p>
<p>如何可以推出dp[i]呢？</p>
<p>从dp[i]的定义可以看出，dp[i] 可以有两个方向推出来。</p>
<p>首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。（题目中可以每次只跳一步）</p>
<p>还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么。（题目中可以每次跳两步）</p>
<p>那么dp[i]就是 dp[i - 1]与dp[i - 2]之和！</p>
<p>所以dp[i] &#x3D; dp[i - 1] + dp[i - 2] 。</p>
<p>在推导dp[i]的时候，一定要时刻想着dp[i]的定义，否则容易跑偏。这体现出确定dp数组以及下标的含义的重要性！</p>
<p>3、dp数组的初始化</p>
<p>本题中n是正整数，所以不用去定义dp[0]的含义，我们可以直接从dp[1]开始定义</p>
<p>那么初始化dp[1]&#x3D;1,dp[2]&#x3D;2;遍历的时候从3开始即可。</p>
<p>PS dp[0]&#x3D;1认为什么都不干也是一种方法。</p>
<p>4、确定遍历顺序</p>
<p>由递推公式可以看出遍历顺序一定是从前往后</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n; <span class="hljs-comment">// 因为下面直接对dp[2]操作了，防止空指针</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-comment">// dp数组</span><br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;/ dp数组初始化<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++) &#123; <span class="hljs-comment">// 注意i是从3开始的 ，遍历顺序</span><br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<span class="hljs-comment">// 递推公式</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>爬楼梯拓展</strong>：如果每次你可以爬至多m (1 &lt;&#x3D; m &lt; n)个台阶。你有多少种不同的方法可以爬到楼顶呢？–变成一个完全背包问题了。1阶，2阶，…. m阶就是物品，楼顶就是背包。每一阶可以重复使用，例如跳了1阶，还可以继续跳1阶。问跳到楼顶有几种方法其实就是问装满背包有几种方法。（求排列数）</p>
<p>1、确定dp数组以及下标的含义</p>
<p><strong>dp[i]：爬到有i个台阶的楼顶，有dp[i]种方法</strong>。</p>
<p>2、确定递推公式</p>
<p>本题呢，dp[i]有几种来源，dp[i - 1]，dp[i - 2]，dp[i - 3] 等等，即：dp[i - j]那么递推公式为：dp[i] +&#x3D; dp[i - j]</p>
<p>3、dp数组如何初始化</p>
<p>既然递归公式是 dp[i] +&#x3D; dp[i - j]，那么dp[0] 一定为1，dp[0]是递归中一切数值的基础所在，如果dp[0]是0的话，其他数值都是0了。下标非0的dp[i]初始化为0，因为dp[i]是靠dp[i-j]累计上来的，dp[i]本身为0这样才不会影响结果</p>
<p>4、确定遍历顺序</p>
<p>这是背包里求排列问题，即：<strong>1、2 步 和 2、1 步都是上三个台阶，但是这两种方法不一样！</strong>所以需将target放在外循环，将nums放在内循环。每一步可以走多次，这是完全背包，内循环需要从前向后遍历。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<span class="hljs-comment">// 1、确定dp数组</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<span class="hljs-comment">// 3、dp数组初始化，装满容量为0的背包由1种方法（什么都不放）</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-comment">//4、确定遍历顺序，因为求的是排列数（1、2和2,1是两种方法）外层循环遍历背包，内层遍历物品，且从前向后遍历，确保物品可以重复选取</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123; <br>                <span class="hljs-keyword">if</span> (i - j &gt;= <span class="hljs-number">0</span>) dp[i] += dp[i - j];<span class="hljs-comment">// 2、确定递推公式</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="3、使用最小花费爬楼梯"><a href="#3、使用最小花费爬楼梯" class="headerlink" title="3、使用最小花费爬楼梯"></a>3、使用最小花费爬楼梯</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-cost-climbing-stairs/">https://leetcode.cn/problems/min-cost-climbing-stairs/</a></p>
<p>1、确定dp数组以及下标的含义</p>
<p>**dp[i]的定义：到达第i台阶所花费的最少体力为dp[i]**。</p>
<p>2、确定递推公式</p>
<p>**可以有两个途径得到dp[i]，一个是dp[i-1] 一个是dp[i-2]**。</p>
<p>dp[i - 1] 跳到 dp[i] 需要花费 dp[i - 1] + cost[i - 1]。</p>
<p>dp[i - 2] 跳到 dp[i] 需要花费 dp[i - 2] + cost[i - 2]。</p>
<p>那么究竟是选从dp[i - 1]跳还是从dp[i - 2]跳呢？</p>
<p>一定是选最小的，所以dp[i] &#x3D; min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);</p>
<p>3、dp数组如何初始化</p>
<p>根据dp数组的定义，到达第0台阶所花费的最小体力为dp[0]，那么有同学可能想，那dp[0] 应该是 cost[0]，例如 cost &#x3D; [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] 的话，dp[0] 就是 cost[0] 应该是1。</p>
<p>题目描述中明确说了 “你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。” 也就是说 到达 第 0 个台阶是不花费的，但从 第0 个台阶 往上跳的话，需要花费 cost[0]。</p>
<p>所以初始化 dp[0] &#x3D; 0，dp[1] &#x3D; 0;</p>
<p>4、确定遍历顺序</p>
<p>因为是模拟台阶，而且dp[i]由dp[i-1]dp[i-2]推出，所以是从前到后遍历cost数组就可以。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(cost.size() + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 默认第一步都是不花费体力的</span><br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= cost.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            dp[i] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>] + cost[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + cost[i - <span class="hljs-number">2</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[cost.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="4、不同路径"><a href="#4、不同路径" class="headerlink" title="4、不同路径"></a>4、不同路径</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/">https://leetcode.cn/problems/unique-paths/</a></p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<span class="hljs-comment">// 1、[i][j]的定义：从（0,0）到（n-1，m-1）有dp[i][j]种方法</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<span class="hljs-comment">// 建立dp数组（二维数组的定义）</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<span class="hljs-comment">// 3、dp数组初始化（横着走、竖着走只有一种方法）</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<span class="hljs-comment">// 4、遍历顺序，从左往右依次遍历即可</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<span class="hljs-comment">// 2、递推公式</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="5、不同路径"><a href="#5、不同路径" class="headerlink" title="5、不同路径||"></a>5、不同路径||</h2><p>如果路径上有了障碍物，如何计算有几种方式到达目标位置呢？</p>
<p>如果遇到障碍，其实就把对应的dp数组置为0就可以了（这条路径上有障碍，就到不了目的地了）。</p>
<p>所以，当（i，j）位置有障碍物，dp数组要重置为0，所以初始化的部分要考虑障碍物情况。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n &amp;&amp; obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>; j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<span class="hljs-comment">// 数组初始化</span><br></code></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;<span class="hljs-comment">// 带障碍物的网格</span><br>        <span class="hljs-type">int</span> m = obstacleGrid.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//行数</span><br>        <span class="hljs-type">int</span> n = obstacleGrid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<span class="hljs-comment">//列数</span><br>	<span class="hljs-keyword">if</span> (obstacleGrid[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span> || obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) <span class="hljs-comment">//如果在起点或终点出现了障碍，直接返回0</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<span class="hljs-comment">// 定义dp数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n &amp;&amp; obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>; j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<span class="hljs-comment">// 初始化</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<span class="hljs-comment">//初始化的部分，很容易忽略了障碍之后应该都是0的情况。</span><br></code></pre></td></tr></table></figure>

<h2 id="6、背包理论基础1"><a href="#6、背包理论基础1" class="headerlink" title="6、背包理论基础1"></a>6、背包理论基础1</h2><p>1、01背包</p>
<p>有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p>
<p>（1）确定dp数组及其含义</p>
<p>第一种写法， 是使用二维数组，即dp[i] [j]表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。</p>
<p>（2）确定递推公式</p>
<p>dp[i] [j]可以由两种方式推导出来：</p>
<ul>
<li><p>不放物品：由dp[i-1] [j]表示，背包容量为j，不放物品的最大价值，则dp[i-1] [j] &#x3D; dp[i] [j]（物品重量大于背包容量）包里不放物品时候的价值</p>
</li>
<li><p>放物品：由dp[i-1] [j-weight]表示，背包容量为j-weight，不放物品的最大价值，则dp[i] [j] &#x3D; dp[i-1] [j-weight] + value[i]</p>
</li>
</ul>
<p>则递推公式为 dp[i] [j] &#x3D; max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]);</p>
<p>（3）dp数组的初始化</p>
<p>首先从dp[i] [j]的定义出发，如果背包容量j为0的话，即dp[i] [0]，无论是选取哪些物品，背包价值总和一定为0；</p>
<p>由状态转移方程 dp[i] [j] &#x3D; max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]); 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。</p>
<p>dp[0] [j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。那么很明显当 j &lt; weight[0]的时候，dp[0] [j] 应该是 0，因为背包容量比编号0的物品重量还小。当j &gt;&#x3D; weight[0]时，dp[0] [j] 应该是value[0]，因为背包容量放足够放编号0物品。</p>
<p>dp[0] [j] 和 dp[i] [0] 都已经初始化了，那么其他下标应该初始化多少呢？</p>
<p>其实从递归公式： dp[i] [ j] &#x3D; max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]); 可以看出dp[i] [j] 是由左上方数值推导出来了，那么 其他下标初始为什么数值都可以，因为都会被覆盖。</p>
<p>（4）确定遍历顺序</p>
<p>对于二维数组的01背包问题，先遍历物品再遍历背包和先遍历背包再遍历物品都可以。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//二维dp数组实现</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, bagweight;<span class="hljs-comment">// bagweight代表行李箱空间</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">weight</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 存储每件物品所占空间</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">value</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;  <span class="hljs-comment">// 存储每件物品价值</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        cin &gt;&gt; weight[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>        cin &gt;&gt; value[j];<br>    &#125;<br>    <span class="hljs-comment">// dp数组, dp[i][j]代表行李箱空间为j的情况下,从下标为[0, i]的物品里面任意取,能达到的最大价值</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(weight.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(bagweight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><br>    <span class="hljs-comment">// 初始化, 因为需要用到dp[i - 1]的值</span><br>    <span class="hljs-comment">// j &lt; weight[0]已在上方被初始化为0</span><br>    <span class="hljs-comment">// j &gt;= weight[0]的值就初始化为value[0]</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = weight[<span class="hljs-number">0</span>]; j &lt;= bagweight; j++) &#123;<br>        dp[<span class="hljs-number">0</span>][j] = value[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历科研物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagweight; j++) &#123; <span class="hljs-comment">// 遍历行李箱容量</span><br>            <span class="hljs-comment">// 如果装不下这个物品,那么就继承dp[i - 1][j]的值</span><br>            <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>            <span class="hljs-comment">// 如果能装下,就将值更新为 不装这个物品的最大值 和 装这个物品的最大值 中的 最大值</span><br>            <span class="hljs-comment">// 装这个物品的最大值由容量为j - weight[i]的包任意放入序号为[0, i - 1]的最大值 + 该物品的价值构成</span><br>            <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; dp[weight.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][bagweight] &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; n &gt;&gt; bagweight) &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="7、背包理论基础2"><a href="#7、背包理论基础2" class="headerlink" title="7、背包理论基础2"></a>7、背包理论基础2</h2><p>考虑用一维数组（滚动数组的形式）</p>
<p>1、确定dp数组的定义</p>
<p>在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。</p>
<p>2、一维dp数组的递推公式</p>
<p>dp[j]为 容量为j的背包所背的最大价值，那么如何推导dp[j]呢？</p>
<p>dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。</p>
<p>dp[j - weight[i]] + value[i] 表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）</p>
<p>此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1] [j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值，</p>
<p>所以递归公式为：dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);</p>
<p>3、dp数组的初始化</p>
<p><strong>关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱</strong>。</p>
<p>dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。</p>
<p>那么dp数组除了下标0的位置，初始为0，其他下标应该初始化多少呢？</p>
<p>看一下递归公式：dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);</p>
<p>dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。</p>
<p><strong>这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了</strong>。</p>
<p>那么我假设物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了。</p>
<p>4、遍历顺序</p>
<p>为了保证物品只被使用一次，需要倒序遍历背包容量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>这里大家发现和二维dp的写法中，遍历背包的顺序是不一样的！</strong></p>
<p>二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。</p>
<p>为什么呢？</p>
<p><strong>倒序遍历是为了保证物品i只被放入一次！</strong>。但如果一旦正序遍历了，那么物品0就会被重复加入多次！</p>
<p>举一个例子：物品0的重量weight[0] &#x3D; 1，价值value[0] &#x3D; 15</p>
<p>如果正序遍历</p>
<p>dp[1] &#x3D; dp[1 - weight[0]] + value[0] &#x3D; 15</p>
<p>dp[2] &#x3D; dp[2 - weight[0]] + value[0] &#x3D; 30</p>
<p>此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。</p>
<p>为什么倒序遍历，就可以保证物品只放入一次呢？</p>
<p>倒序就是先算dp[2]</p>
<p>dp[2] &#x3D; dp[2 - weight[0]] + value[0] &#x3D; 15 （dp数组已经都初始化为0）</p>
<p>dp[1] &#x3D; dp[1 - weight[0]] + value[0] &#x3D; 15</p>
<p>所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_1_wei_bag_problem</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; weight = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>    vector&lt;<span class="hljs-type">int</span>&gt; value = &#123;<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;;<br>    <span class="hljs-type">int</span> bagWeight = <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(bagWeight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test_1_wei_bag_problem</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="8、分割等和子集"><a href="#8、分割等和子集" class="headerlink" title="8、分割等和子集"></a>8、分割等和子集</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-equal-subset-sum/">https://leetcode.cn/problems/partition-equal-subset-sum/</a></p>
<p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。根据题目描述，可以抽象成01背包问题，如果几个元素的和加起来能等于和的一半，即sum&#x2F;2，那就说明可以拆成两个子集。即背包容量为sum&#x2F;2，每个物品的重量为其大小，即nums[i]。</p>
<p>1、确定dp数组的含义：</p>
<p><strong>dp[j]表示 背包总容量（所能装的总重量）是j，放进物品后，背的最大重量为dp[j]</strong></p>
<p>如果背包容量为target， dp[target]就是装满 背包之后的重量，所以 当 dp[target] &#x3D;&#x3D; target 的时候，背包就装满了。</p>
<p>2、确定递推公式</p>
<p>01背包的递推公式为：dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);</p>
<p>本题，相当于背包里放入数值，那么物品i的重量是nums[i]，其价值也是nums[i]。</p>
<p>所以递推公式：dp[j] &#x3D; max(dp[j], dp[j - nums[i]] + nums[i]);</p>
<p>3、dp数组初始化</p>
<p>本题题目中 只包含正整数的非空数组，所以非0下标的元素初始化为0就可以。</p>
<p>4、确定遍历顺序</p>
<p>背包容量倒序遍历</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// dp[i]中的i表示背包内总和</span><br>        <span class="hljs-comment">// 题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200</span><br>        <span class="hljs-comment">// 总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以了</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">10001</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            sum += nums[i];<br>        &#125;<br>        <span class="hljs-comment">// 也可以使用库函数一步求和</span><br>        <span class="hljs-comment">// int sum = accumulate(nums.begin(), nums.end(), 0);</span><br>        <span class="hljs-keyword">if</span> (sum % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> target = sum / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-comment">// 开始 01背包</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = target; j &gt;= nums[i]; j--) &#123; <span class="hljs-comment">// 每一个元素一定是不可重复放入，所以从大到小遍历</span><br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - nums[i]] + nums[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 集合中的元素正好可以凑成总和target</span><br>        <span class="hljs-keyword">if</span> (dp[target] == target) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>9、最后一块石头的重量2</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/last-stone-weight-ii/">https://leetcode.cn/problems/last-stone-weight-ii/</a></p>
<p>有一堆石头，每块石头的重量都是正整数。</p>
<p>每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;&#x3D; y。那么粉碎的可能结果如下：</p>
<p>如果 x &#x3D;&#x3D; y，那么两块石头都会被完全粉碎；</p>
<p>如果 x !&#x3D; y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。</p>
<p>最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。</p>
<p>原理等同上一台的分割等和子集，也把石头分成两堆，背包容量为target（总石头重量的一半），dp[target]表示装满一半石头最大有多少，那剩下的一堆就是sum - dp[target]。两者相减就是剩余的最小值。</p>
<p>1、确定dp数组以及下标的含义</p>
<p>**dp[j]表示容量（这里说容量更形象，其实就是重量）为j的背包，最多可以背最大重量为dp[j]**。</p>
<p>可以回忆一下01背包中，dp[j]的含义，容量为j的背包，最多可以装的价值为 dp[j]。</p>
<p>相对于 01背包，本题中，石头的重量是 stones[i]，石头的价值也是 stones[i] ，可以 “最多可以装的价值为 dp[j]” &#x3D;&#x3D; “最多可以背的重量为dp[j]”</p>
<p>2、确定递推公式</p>
<p>01背包的递推公式为：dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);</p>
<p>本题则是：<strong>dp[j] &#x3D; max(dp[j], dp[j - stones[i]] + stones[i]);</strong></p>
<p>3、dp数组如何初始化</p>
<p>既然 dp[j]中的j表示容量，那么最大容量（重量）是多少呢，就是所有石头的重量和。</p>
<p>因为提示中给出1 &lt;&#x3D; stones.length &lt;&#x3D; 30，1 &lt;&#x3D; stones[i] &lt;&#x3D; 1000，所以最大重量就是30 * 1000 。</p>
<p>而我们要求的target其实只是最大重量的一半，所以dp数组开到15000大小就可以了。</p>
<p>当然也可以把石头遍历一遍，计算出石头总重量 然后除2，得到dp数组的大小。</p>
<p>我这里就直接用15000了。</p>
<p>接下来就是如何初始化dp[j]呢，因为重量都不会是负数，所以dp[j]都初始化为0就可以了，这样在递归公式dp[j] &#x3D; max(dp[j], dp[j - stones[i]] + stones[i]);中dp[j]才不会初始值所覆盖。</p>
<p>4、遍历顺序</p>
<p>外层遍历石头，内存倒序遍历容量。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lastStoneWeightII</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; stones)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">15001</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; stones.<span class="hljs-built_in">size</span>(); i++) sum += stones[i];<br>        <span class="hljs-type">int</span> target = sum / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; stones.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = target; j &gt;= stones[i]; j--) &#123; <span class="hljs-comment">// 遍历背包</span><br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - stones[i]] + stones[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum - dp[target] - dp[target];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="9、目标和"><a href="#9、目标和" class="headerlink" title="9、目标和"></a>9、目标和</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/target-sum/">https://leetcode.cn/problems/target-sum/</a></p>
<p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p>
<p>既然目标值为target，那么就一定有：加法组合 - 减法组合 &#x3D; target。</p>
<p>加法组合 + 减法组合&#x3D; sum，而sum是固定的。减法组合&#x3D; sum - 加法组合</p>
<p>公式来了， 加法组合- (sum - 加法组合) &#x3D; target 推导出 加法组合&#x3D; (target + sum)&#x2F;2 。</p>
<p>target是固定的，sum是固定的，加法组合就可以求出来。</p>
<p>此时问题就是在集合nums中找出值为(target + sum)&#x2F;2的加法组合。—转化为01背包问题（元素不能重复使用）</p>
<p>假设加法的总和为x，那么减法对应的总和就是sum - x。</p>
<p>所以我们要求的是 x - (sum - x) &#x3D; target</p>
<p>x &#x3D; (target + sum) &#x2F; 2–&gt;x即为背包容量–&gt;<strong>转化为求装满背包容量为x的背包一共有几种方法</strong>。</p>
<p><strong>注意：</strong></p>
<p>这里的背包容量是一个取整的表达式，例如sum 是5，S是2的话其实就是无解的，所以</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> ((S + sum) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 此时没有方案</span><br></code></pre></td></tr></table></figure>

<p>同时如果 S的绝对值已经大于sum，那么也是没有方案的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(S) &gt; sum) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 此时没有方案</span><br></code></pre></td></tr></table></figure>

<p>1、确定dp数组及其含义：</p>
<p>dp[j]表示装满容量为j的背包一共有dp[j]种方法。</p>
<p>2、推导递推公式</p>
<p>有哪些来源可以推出dp[j]呢？</p>
<p>只要搞到nums[i]，凑成dp[j]就有dp[j - nums[i]] 种方法。注意这里说的是装满背包的方法总数，</p>
<p>例如：dp[j]，j 为5，</p>
<ul>
<li>已经有一个1（nums[i]） 的话，有 dp[4]种方法 凑成 容量为5的背包。背包里已经有一个1了，对于容量为5的背包来说，装满它有dp[5-1]种方法，即dp[4]种方法。下述同理。</li>
<li>已经有一个2（nums[i]） 的话，有 dp[3]种方法 凑成 容量为5的背包。</li>
<li>已经有一个3（nums[i]） 的话，有 dp[2]中方法 凑成 容量为5的背包</li>
<li>已经有一个4（nums[i]） 的话，有 dp[1]中方法 凑成 容量为5的背包</li>
<li>已经有一个5 （nums[i]）的话，有 dp[0]中方法 凑成 容量为5的背包</li>
</ul>
<p>那么凑整dp[5]有多少方法呢，也就是把 所有的 dp[j - nums[i]] 累加起来。</p>
<p>递推公式为：dp[j] &#x3D; dp[j] + dp[j-nums[i]]</p>
<p>3、dp数组初始化</p>
<p>如果数组[0] ，target &#x3D; 0，那么 bagSize &#x3D; (target + sum) &#x2F; 2 &#x3D; 0。 dp[0]也应该是1， 也就是说给数组里的元素 0 前面无论放加法还是减法，都是 1 种方法。</p>
<p>所以本题我们应该初始化 dp[0] 为 1。装满容量为0的背包有1种方法，—什么都不放。</p>
<p>4、确定遍历顺序</p>
<p>外层遍历物品，内层倒序遍历背包容量（确保每个物品只被使用一次）</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++) sum += nums[i]; <span class="hljs-comment">// 求和</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(target) &gt; sum) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//目标和的绝对值大于总和，没有解决方案</span><br>    <span class="hljs-keyword">if</span>((target+sum)%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 向下取整 没有解决方案</span><br>    <span class="hljs-comment">// 转化为01背包问题</span><br>    <span class="hljs-type">int</span> bagsize = (target+sum)/<span class="hljs-number">2</span>;<span class="hljs-comment">//背包容量</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(bagsize+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<span class="hljs-comment">//定义dp数组</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<span class="hljs-comment">//初始化，不取任何数，背包容量为0，算一种方案；</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<span class="hljs-comment">// 先遍历物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j =bagsize;j&gt;=nums[i];j--)&#123;<span class="hljs-comment">// 倒序遍历背包容量，防止物品重复使用</span><br>            dp[j] = dp[j] +dp[j-nums[i]];<span class="hljs-comment">// 求装满背包有几种方法的递推公式。</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[bagsize];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="10、一和零"><a href="#10、一和零" class="headerlink" title="10、一和零"></a>10、一和零</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ones-and-zeroes/">https://leetcode.cn/problems/ones-and-zeroes/</a></p>
<p>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。</p>
<p>请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。</p>
<p>本题的本质其实是01背包问题：这个背包容量有两个纬度m和n，不同长度的字符串就是不同大小的物品</p>
<p>一个字符串由x个0和y个1组成（重量）x要满足m，y要满足n。</p>
<p>1、确定dp数值及其含义</p>
<p>dp[i] [j] 表示最多含有i个0和j个1的strs的最大子集的大小（元素个数)为dp[i] [j]。</p>
<p>2、确定递推公式：</p>
<p>还是分为拿还是不拿</p>
<p>不拿：dp[i] [j] </p>
<p>拿：dp[i-zeronum] [j-onenum] + 1 </p>
<p>dp[i] [j]是可以由前一个strs推导出来的，如果字符串strs里有一个元素有x个o和y个1，那么dp[i] [j] &#x3D; dp[i-x] [j-y]  +1</p>
<p>去的是dp[i] [j] 的最大值</p>
<p>所以dp[i] [j] &#x3D; max(dp[i] [j], dp[i - zeronum] [j - onenum] + 1);</p>
<p>字符串的zeronum和onenum相当于物品的重量（weight[i]），字符串本身的个数相当于物品的价值（value[i]）。</p>
<p>3、dp数组初始化</p>
<p>物品价值是非负的，初始化为0即可，保证会被递推公式覆盖。</p>
<p>4、确定遍历顺序</p>
<p>物品就是strs里的字符串，背包容量就是m和n。先遍历物品再遍历背包，且倒序遍历背包容量。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMaxForm</span><span class="hljs-params">(vector&lt;string&gt;&amp; strs, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<span class="hljs-comment">//   默认初始化为0；</span><br>        <span class="hljs-keyword">for</span>(string str:strs)&#123;<br>            <span class="hljs-type">int</span> zeronum = <span class="hljs-number">0</span>,onenum =<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c :str)&#123;<span class="hljs-comment">// 字符串只由0和1组成</span><br>            <span class="hljs-keyword">if</span>( c == <span class="hljs-string">&#x27;0&#x27;</span>)zeronum++;<br>            <span class="hljs-keyword">else</span> onenum++;<br>            &#125;<span class="hljs-comment">//遍历物品，统计每个物品（字符串）所包含的0和1的个数（重量）</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =m;i&gt;=zeronum;i--)&#123;<span class="hljs-comment">// 倒序遍历背包容量</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=n;j&gt;=onenum;j--)&#123;<span class="hljs-comment">// 倒序遍历背包容量</span><br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j],dp[i-zeronum][j-onenum]+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>            <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="11、完全背包理论基础"><a href="#11、完全背包理论基础" class="headerlink" title="11、完全背包理论基础"></a>11、完全背包理论基础</h2><p>有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品都有无限个（也就是可以放入背包多次）</strong>，求解将哪些物品装入背包里物品价值总和最大。</p>
<p>可以看到，对于完全背包来说，每件物品的数量不受限制，可以重复使用同一件物品。由此体现出遍历顺序的区别上，对于01背包，首先，<strong>for循环的顺序可以发生变化了</strong>，先遍历物品再遍历背包或者先遍历背包再遍历物品都可以，因为都能保证下标j之前的dp[j]都是遍历过的值，能有效覆盖，其次，对于<strong>遍历背包容量，不用再从大到小遍历</strong>，使得物品只能被添加一次了，因为完全背包问题中，每件物品可以使用无限次。</p>
<p>以上讨论是针对纯完全背包问题的，当题目要求发生变化，对于两层循环的遍历顺序就有了要求，针对不同的变体形式，主要体现在遍历顺序的不同。</p>
<h2 id="12、零钱兑换"><a href="#12、零钱兑换" class="headerlink" title="12、零钱兑换||"></a>12、零钱兑换||</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change-ii/">https://leetcode.cn/problems/coin-change-ii/</a></p>
<p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币<strong>组合数</strong>。假设每一种面额的硬币有无限个。</p>
<p>根据题目描述可以看出，每种面额的硬币都有无限个，可以抽象成完全背包问题。</p>
<p>但本题和纯完全背包不一样，<strong>纯完全背包是凑成背包最大价值是多少，而本题是要求凑成总金额的物品组合个数！</strong></p>
<p>注意题目描述中是凑成总金额的硬币组合数，为什么强调是组合数呢？</p>
<p>例如示例一：</p>
<p>5 &#x3D; 2 + 2 + 1</p>
<p>5 &#x3D; 2 + 1 + 2</p>
<p>这是一种组合，都是 2 2 1。</p>
<p>如果问的是排列数，那么上面就是两种排列了。</p>
<p><strong>组合不强调元素之间的顺序，排列强调元素之间的顺序</strong></p>
<p>1、确定dp数组以及下标的含义</p>
<p>dp[j]：凑成总金额j的货币组合数为dp[j]（方法数）</p>
<p>2、确定递推公式</p>
<p>dp[j] 就是所有的dp[j - coins[i]]（考虑coins[i]的情况）相加。</p>
<p>所以递推公式：dp[j] +&#x3D; dp[j - coins[i]];</p>
<p><strong>这个递推公式大家应该不陌生了，我在讲解01背包题目的时候在9、目标和中就讲解了，求装满背包有几种方法，公式都是：dp[j] +&#x3D; dp[j - nums[i]];</strong></p>
<p>3、dp数组初始化</p>
<p>dp[0] &#x3D;1;凑成金额为0有1种方法，什么都不拿。</p>
<p>4、遍历顺序有讲究！</p>
<p>纯完全背包求得装满背包的最大价值是多少，和凑成总和的元素有没有顺序没关系，即：有顺序也行，没有顺序也行！而本题要求凑成总和的组合数，元素之间明确要求没有顺序。所以纯完全背包是能凑成总和就行，不用管怎么凑的。本题是求凑出来的方案个数，且每个方案个数是为组合数。那么本题，两个for循环的先后顺序可就有说法了。</p>
<p>我们先来看 外层for循环遍历物品（钱币），内层for遍历背包（金钱总额）的情况。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; coins.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = coins[i]; j &lt;= amount; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] += dp[j - coins[i]];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>假设：coins[0] &#x3D; 1，coins[1] &#x3D; 5。</p>
<p>那么就是先把1加入计算，然后再把5加入计算，得到的方法数量只有{1, 5}这种情况。而不会出现{5, 1}的情况。</p>
<p><strong>所以这种遍历顺序中dp[j]里计算的是组合数！</strong></p>
<p>如果把两个for交换顺序，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= amount; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; coins.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>        <span class="hljs-keyword">if</span> (j - coins[i] &gt;= <span class="hljs-number">0</span>) dp[j] += dp[j - coins[i]];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>背包容量的每一个值，都是经过 1 和 5 的计算，包含了{1, 5} 和 {5, 1}两种情况。</p>
<p><strong>此时dp[j]里算出来的就是排列数！</strong></p>
<p>本题求得是组合数，为此，先遍历物品，再遍历背包容量。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> amount, vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; coins.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = coins[i]; j &lt;= amount; j++) &#123; <span class="hljs-comment">// 遍历背包</span><br>                dp[j] += dp[j - coins[i]];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[amount];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="13、组合总和4"><a href="#13、组合总和4" class="headerlink" title="13、组合总和4"></a>13、组合总和4</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iv/">https://leetcode.cn/problems/combination-sum-iv/</a></p>
<p>给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。</p>
<p>示例:</p>
<ul>
<li>nums &#x3D; [1, 2, 3]</li>
<li>target &#x3D; 4</li>
</ul>
<p>所有可能的组合为： (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1)</p>
<p>请注意，<strong>顺序不同的序列</strong>被视作不同的组合。</p>
<p>由题可知，求的是排列数！</p>
<p>其余推导和上面的零钱兑换||一致，给出代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">combinationSum4</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(target+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<span class="hljs-comment">//dp数组初始化，凑成和为0有1种方法，就是不取任何数</span><br>        <span class="hljs-comment">// 求排列数，考虑顺序，所以先遍历背包，再遍历物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;=target;i++)&#123;<span class="hljs-comment">//先遍历背包</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;nums.<span class="hljs-built_in">size</span>();j++)&#123;<span class="hljs-comment">//再遍历物品</span><br>            <span class="hljs-keyword">if</span> (i - nums[j] &gt;= <span class="hljs-number">0</span> &amp;&amp; dp[i] &lt; INT_MAX - dp[i - nums[j]]) &#123;<br>                    dp[i] = dp[i] +dp[i-nums[j]];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[target];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>C++测试用例有两个数相加超过int的数据，所以需要在if里加上dp[i] &lt; INT_MAX - dp[i - num]。</p>
<p>14、零钱兑换</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/">https://leetcode.cn/problems/coin-change/</a></p>
<p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<p>1、确定dp数组以及下标的含义</p>
<p><strong>dp[j]：凑足总额为j所需钱币的最少个数为dp[j]</strong></p>
<p>2、确定递推公式</p>
<p>凑足总额为j - coins[i]的最少个数为dp[j - coins[i]]，那么只需要加上一个钱币coins[i]即dp[j - coins[i]] + 1就是dp[j]（考虑coins[i]）</p>
<p>所以dp[j] 要取所有 dp[j - coins[i]] + 1 中最小的。</p>
<p>递推公式：dp[j] &#x3D; min(dp[j - coins[i]] + 1, dp[j]);</p>
<p>3、dp数组如何初始化</p>
<p>首先凑足总金额为0所需钱币的个数一定是0，那么dp[0] &#x3D; 0;</p>
<p>其他下标对应的数值呢？</p>
<p>考虑到递推公式的特性，dp[j]必须初始化为一个最大的数，否则就会在min(dp[j - coins[i]] + 1, dp[j])比较的过程中被初始值覆盖。</p>
<p>所以下标非0的元素都是应该是最大值。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>, INT_MAX)</span></span>;<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>

<p>4、确定遍历顺序</p>
<p>本题求钱币最小个数，<strong>那么钱币有顺序和没有顺序都可以，都不影响钱币的最小个数</strong>。</p>
<p>所以本题并不强调集合是组合还是排列。</p>
<p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p>
<p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p>
<p><strong>所以本题的两个for循环的关系是：外层for循环遍历物品，内层for遍历背包或者外层for遍历背包，内层for循环遍历物品都是可以的！</strong></p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins, <span class="hljs-type">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>, INT_MAX)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; coins.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = coins[i]; j &lt;= amount; j++) &#123; <span class="hljs-comment">// 遍历背包</span><br>                <span class="hljs-keyword">if</span> (dp[j - coins[i]] != INT_MAX) &#123; <span class="hljs-comment">// 如果dp[j - coins[i]]是初始值则跳过</span><br>                    dp[j] = <span class="hljs-built_in">min</span>(dp[j - coins[i]] + <span class="hljs-number">1</span>, dp[j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (dp[amount] == INT_MAX) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> dp[amount];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="14、零钱兑换"><a href="#14、零钱兑换" class="headerlink" title="14、零钱兑换"></a>14、零钱兑换</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/">https://leetcode.cn/problems/coin-change/</a></p>
<p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<p>1、确定dp数组以及下标的含义</p>
<p><strong>dp[j]：凑足总额为j所需钱币的最少个数为dp[j]</strong></p>
<p>2、确定递推公式</p>
<p>凑足总额为j - coins[i]的最少个数为dp[j - coins[i]]，那么只需要加上一个钱币coins[i]即dp[j - coins[i]] + 1就是dp[j]（考虑coins[i]）</p>
<p>所以dp[j] 要取所有 dp[j - coins[i]] + 1 中最小的。</p>
<p>递推公式：dp[j] &#x3D; min(dp[j - coins[i]] + 1, dp[j]);</p>
<p>3、dp数组如何初始化</p>
<p>首先凑足总金额为0所需钱币的个数一定是0，那么dp[0] &#x3D; 0;</p>
<p>其他下标对应的数值呢？</p>
<p>考虑到递推公式的特性，dp[j]必须初始化为一个最大的数，否则就会在min(dp[j - coins[i]] + 1, dp[j])比较的过程中被初始值覆盖。</p>
<p>所以下标非0的元素都是应该是最大值。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>, INT_MAX)</span></span>;<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>

<p>4、确定遍历顺序</p>
<p>本题求钱币最小个数，<strong>那么钱币有顺序和没有顺序都可以，都不影响钱币的最小个数</strong>。</p>
<p>所以本题并不强调集合是组合还是排列。</p>
<p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p>
<p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p>
<p><strong>所以本题的两个for循环的关系是：外层for循环遍历物品，内层for遍历背包或者外层for遍历背包，内层for循环遍历物品都是可以的！</strong></p>
<p>那么我采用coins放在外循环，target在内循环的方式。</p>
<p>本题钱币数量可以无限使用，那么是完全背包。所以遍历的内循环是正序</p>
<p>综上所述，遍历顺序为：coins（物品）放在外循环，target（背包）在内循环。且内循环正序。</p>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins, <span class="hljs-type">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>, INT_MAX)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; coins.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = coins[i]; j &lt;= amount; j++) &#123; <span class="hljs-comment">// 遍历背包</span><br>                <span class="hljs-keyword">if</span> (dp[j - coins[i]] != INT_MAX) &#123; <span class="hljs-comment">// 如果dp[j - coins[i]]是初始值则跳过</span><br>                    dp[j] = <span class="hljs-built_in">min</span>(dp[j - coins[i]] + <span class="hljs-number">1</span>, dp[j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (dp[amount] == INT_MAX) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> dp[amount];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="15、完全平方数"><a href="#15、完全平方数" class="headerlink" title="15、完全平方数"></a>15、完全平方数</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/perfect-squares/">https://leetcode.cn/problems/perfect-squares/</a></p>
<p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p>
<p>给你一个整数 n ，返回和为 n 的完全平方数的 最少数量</p>
<p>1、确定dp数组（dp table）以及下标的含义</p>
<p><strong>dp[j]：和为j的完全平方数的最少数量为dp[j]</strong></p>
<p>2、确定递推公式</p>
<p>dp[j] 可以由dp[j - i * i]推出， dp[j - i * i] + 1 便可以凑成dp[j]。</p>
<p>此时我们要选择最小的dp[j]，所以递推公式：dp[j] &#x3D; min(dp[j - i * i] + 1, dp[j]);</p>
<p>3、dp数组如何初始化</p>
<p>dp[0]表示 和为0的完全平方数的最小数量，那么dp[0]一定是0。</p>
<p>有同学问题，那0 * 0 也算是一种啊，为啥dp[0] 就是 0呢？</p>
<p>看题目描述，找到若干个完全平方数（比如 1, 4, 9, 16, …），题目描述中可没说要从0开始，dp[0]&#x3D;0完全是为了递推公式。</p>
<p>非0下标的dp[j]应该是多少呢？</p>
<p>从递归公式dp[j] &#x3D; min(dp[j - i * i] + 1, dp[j]);中可以看出每次dp[j]都要选最小的，<strong>所以非0下标的dp[j]一定要初始为最大值，这样dp[j]在递推的时候才不会被初始值覆盖</strong>。</p>
<p>4、确定遍历顺序</p>
<p>我们知道这是完全背包，</p>
<p>如果求组合数就是外层for循环遍历物品，内层for遍历背包。</p>
<p>如果求排列数就是外层for遍历背包，内层for循环遍历物品。</p>
<p><strong>所以本题外层for遍历背包，内层for遍历物品，还是外层for遍历物品，内层for遍历背包，都是可以的</strong></p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, INT_MAX)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i * i &lt;= n; i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i * i; j &lt;= n; j++) &#123; <span class="hljs-comment">// 遍历背包</span><br>                dp[j] = <span class="hljs-built_in">min</span>(dp[j - i * i] + <span class="hljs-number">1</span>, dp[j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="16、单词拆分"><a href="#16、单词拆分" class="headerlink" title="16、单词拆分"></a>16、单词拆分</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-break/">https://leetcode.cn/problems/word-break/</a></p>
<p>单词就是物品，字符串s就是背包，单词能否组成字符串s，就是问物品能不能把背包装满。</p>
<p>拆分时可以重复使用字典中的单词，说明就是一个完全背包！</p>
<p>动规五部曲分析如下：</p>
<p>1、确定dp数组以及下标的含义</p>
<p><strong>dp[i] : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词</strong>。</p>
<p>2、确定递推公式</p>
<p>如果确定dp[j] 是true，且 [j, i] 这个区间的子串出现在字典里，那么dp[i]一定是true。（j &lt; i ）。</p>
<p>所以递推公式是 if([j, i] 这个区间的子串出现在字典里 &amp;&amp; dp[j]是true) 那么 dp[i] &#x3D; true。</p>
<p>3、dp数组如何初始化</p>
<p>从递推公式中可以看出，dp[i] 的状态依靠 dp[j]是否为true，那么dp[0]就是递推的根基，dp[0]一定要为true，否则递推下去后面都都是false了。</p>
<p>那么dp[0]有没有意义呢？</p>
<p>dp[0]表示如果字符串为空的话，说明出现在字典里。</p>
<p>但题目中说了“给定一个非空字符串 s” 所以测试数据中不会出现i为0的情况，那么dp[0]初始为true完全就是为了推导公式。</p>
<p>下标非0的dp[i]初始化为false，只要没有被覆盖说明都是不可拆分为一个或多个在字典中出现的单词。</p>
<p>4、确定遍历顺序</p>
<p>题目中说是拆分为一个或多个在字典中出现的单词，所以这是完全背包。</p>
<p>而本题其实我们求的是<strong>排列数</strong>，为什么呢。 拿 s &#x3D; “applepenapple”, wordDict &#x3D; [“apple”, “pen”] 举例。</p>
<p>“apple”, “pen” 是物品，那么我们要求 物品的组合一定是 “apple” + “pen” + “apple” 才能组成 “applepenapple”。</p>
<p>“apple” + “apple” + “pen” 或者 “pen” + “apple” + “apple” 是不可以的，那么我们就是<strong>强调物品之间顺序</strong>。</p>
<p>所以说，本题一定是 先遍历 背包，再遍历物品。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;<br>        <span class="hljs-function">unordered_set&lt;string&gt; <span class="hljs-title">wordSet</span><span class="hljs-params">(wordDict.begin(), wordDict.end())</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(s.size() + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= s.<span class="hljs-built_in">size</span>(); i++) &#123;   <span class="hljs-comment">// 遍历背包</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;       <span class="hljs-comment">// 遍历物品</span><br>                string word = s.<span class="hljs-built_in">substr</span>(j, i - j); <span class="hljs-comment">//substr(起始位置，截取的个数)</span><br>                <span class="hljs-keyword">if</span> (wordSet.<span class="hljs-built_in">find</span>(word) != wordSet.<span class="hljs-built_in">end</span>() &amp;&amp; dp[j]) &#123;<br>                    dp[i] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[s.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="背包问题总结"><a href="#背包问题总结" class="headerlink" title="背包问题总结"></a>背包问题总结</h2><p>关于递推公式</p>
<p>问能否能装满背包（或者最多装多少）：dp[j] &#x3D; max(dp[j], dp[j - nums[i]] + nums[i]); </p>
<p>问装满背包有几种方法：dp[j] &#x3D; dp[j] + dp[j - nums[i]]</p>
<p>问背包装满最大价值：dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]); </p>
<p>问装满背包所有物品的最小个数：dp[j] &#x3D; min(dp[j - coins[i]] + 1, dp[j]);</p>
<p>关于遍历顺序</p>
<p>01背包：解二维dp数组01背包先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。一维dp数组01背包只能先遍历物品再遍历背包容量，且第二层for循环是从大到小遍历。</p>
<p>完全背包：完全背包的一维dp数组实现，先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。</p>
<p>但是仅仅是纯完全背包的遍历顺序是这样的，题目稍有变化，两个for循环的先后顺序就不一样了。</p>
<p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p>
<p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p>
<h2 id="17、打家劫舍"><a href="#17、打家劫舍" class="headerlink" title="17、打家劫舍"></a>17、打家劫舍</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber/">https://leetcode.cn/problems/house-robber/</a></p>
<p>1、确定dp数组（dp table）以及下标的含义</p>
<p>**dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]**。</p>
<p>2、确定递推公式</p>
<p>决定dp[i]的因素就是第i房间偷还是不偷。</p>
<p>如果偷第i房间，那么dp[i] &#x3D; dp[i - 2] + nums[i] ，即：第i-1房一定是不考虑的，找出 下标i-2（包括i-2）以内的房屋，最多可以偷窃的金额为dp[i-2] 加上第i房间偷到的钱。</p>
<p>如果不偷第i房间，那么dp[i] &#x3D; dp[i - 1]，即考 虑i-1房，（<strong>注意这里是考虑，并不是一定要偷i-1房，这是很多同学容易混淆的点</strong>）</p>
<p>然后dp[i]取最大值，即dp[i] &#x3D; max(dp[i - 2] + nums[i], dp[i - 1]);</p>
<p>3、dp数组如何初始化</p>
<p>从递推公式dp[i] &#x3D; max(dp[i - 2] + nums[i], dp[i - 1]);可以看出，递推公式的基础就是dp[0] 和 dp[1]</p>
<p>从dp[i]的定义上来讲，dp[0] 一定是 nums[0]，dp[1]就是nums[0]和nums[1]的最大值即：dp[1] &#x3D; max(nums[0], nums[1]);</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size())</span></span>;<br>dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br></code></pre></td></tr></table></figure>

<p>4、确定遍历顺序</p>
<p>dp[i] 是根据dp[i - 2] 和 dp[i - 1] 推导出来的，那么一定是从前到后遍历！</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">2</span>] + nums[i], dp[i - <span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//没有元素，偷不到，返回零</span><br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 只有一个元素，下标零就是最大值</span><br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">dp</span>(nums.<span class="hljs-built_in">size</span>());<span class="hljs-comment">// dp数组</span><br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>],nums[<span class="hljs-number">1</span>]);<span class="hljs-comment">// dp数组的初始化</span><br>        <span class="hljs-comment">// 遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>],dp[i<span class="hljs-number">-2</span>]+nums[i]);<span class="hljs-comment">// 递推公式，偷当前家还是不偷当前家，取最大值</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="18、打家劫舍"><a href="#18、打家劫舍" class="headerlink" title="18、打家劫舍||"></a>18、打家劫舍||</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-ii/">https://leetcode.cn/problems/house-robber-ii/</a></p>
<p>对比上一题，房屋成环了，也是相邻的不能偷，因此需要分类讨论了。</p>
<p>情况1：考虑不包含首位元素</p>
<p>情况2：考虑不包含尾元素</p>
<p>情况3：考虑不包含首元素</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 注意注释中的情况二情况三，以及把198.打家劫舍的代码抽离出来了</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> result1 = <span class="hljs-built_in">robRange</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>); <span class="hljs-comment">// 情况二</span><br>        <span class="hljs-type">int</span> result2 = <span class="hljs-built_in">robRange</span>(nums, <span class="hljs-number">1</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>); <span class="hljs-comment">// 情况三</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(result1, result2);<br>    &#125;<br>    <span class="hljs-comment">// 198.打家劫舍的逻辑</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">robRange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (end == start) <span class="hljs-keyword">return</span> nums[start];<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size())</span></span>;<br>        dp[start] = nums[start];<br>        dp[start + <span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[start], nums[start + <span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start + <span class="hljs-number">2</span>; i &lt;= end; i++) &#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">2</span>] + nums[i], dp[i - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[end];<br>    &#125;<br>&#125;;<span class="hljs-comment">// 情况2、3包含了情况1，故不必单独写情况1的处理逻辑了。</span><br></code></pre></td></tr></table></figure>

<h2 id="19、打家劫舍"><a href="#19、打家劫舍" class="headerlink" title="19、打家劫舍|||"></a>19、打家劫舍|||</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-iii/">https://leetcode.cn/problems/house-robber-iii/</a></p>
<p><strong>树形dp</strong></p>
<p>所有房屋以二叉树的结构排列，相邻节点不能偷。</p>
<p>1、确定递归函数的参数和返回值</p>
<p>这里我们要求一个节点 偷与不偷的两个状态所得到的金钱，那么返回值就是一个长度为2的数组。</p>
<p>参数为当前节点，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">robTree</span><span class="hljs-params">(TreeNode* cur)</span> </span>&#123;<br></code></pre></td></tr></table></figure>

<p>其实这里的返回数组就是dp数组。</p>
<p>所以dp数组（dp table）以及下标的含义：dp[0] 表示下标为0记录不偷该节点所得到的的最大金钱，dp[1]表示下标为1记录偷该节点所得到的的最大金钱。</p>
<p><strong>所以本题dp数组就是一个长度为2的数组！</strong></p>
<p>那么有同学可能疑惑，长度为2的数组怎么标记树中每个节点的状态呢？</p>
<p><strong>别忘了在递归的过程中，系统栈会保存每一层递归的参数</strong>。</p>
<p>2、确定终止条件</p>
<p>在遍历的过程中，如果遇到空节点的话，很明显，无论偷还是不偷都是0，所以就返回</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br></code></pre></td></tr></table></figure>

<p>这也相当于dp数组的初始化</p>
<p>3、确定遍历顺序</p>
<p>首先明确的是使用后序遍历。 因为要通过递归函数的返回值来做下一步计算。</p>
<p>通过递归左节点，得到左节点偷与不偷的金钱。</p>
<p>通过递归右节点，得到右节点偷与不偷的金钱。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 下标0：不偷，下标1：偷</span><br>vector&lt;<span class="hljs-type">int</span>&gt; left = <span class="hljs-built_in">robTree</span>(cur-&gt;left); <span class="hljs-comment">// 左</span><br>vector&lt;<span class="hljs-type">int</span>&gt; right = <span class="hljs-built_in">robTree</span>(cur-&gt;right); <span class="hljs-comment">// 右</span><br><span class="hljs-comment">// 中</span><br></code></pre></td></tr></table></figure>

<p>4、确定单层递归的逻辑</p>
<p>如果是偷当前节点，那么左右孩子就不能偷，val1 &#x3D; cur-&gt;val + left[0] + right[0]; （<strong>如果对下标含义不理解就再回顾一下dp数组的含义</strong>）</p>
<p>如果不偷当前节点，那么左右孩子就可以偷，至于到底偷不偷一定是选一个最大的，所以：val2 &#x3D; max(left[0], left[1]) + max(right[0], right[1]);</p>
<p>最后当前节点的状态就是{val2, val1}; 即：{不偷当前节点得到的最大金钱，偷当前节点得到的最大金钱}</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; left = <span class="hljs-built_in">robTree</span>(cur-&gt;left); <span class="hljs-comment">// 左</span><br>vector&lt;<span class="hljs-type">int</span>&gt; right = <span class="hljs-built_in">robTree</span>(cur-&gt;right); <span class="hljs-comment">// 右</span><br><span class="hljs-comment">// 偷cur</span><br><span class="hljs-type">int</span> val1 = cur-&gt;val + left[<span class="hljs-number">0</span>] + right[<span class="hljs-number">0</span>];<br><span class="hljs-comment">// 不偷cur</span><br><span class="hljs-type">int</span> val2 = <span class="hljs-built_in">max</span>(left[<span class="hljs-number">0</span>], left[<span class="hljs-number">1</span>]) + <span class="hljs-built_in">max</span>(right[<span class="hljs-number">0</span>], right[<span class="hljs-number">1</span>]);<br><span class="hljs-keyword">return</span> &#123;val2, val1&#125;;<br></code></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result = <span class="hljs-built_in">robTree</span>(root);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(result[<span class="hljs-number">0</span>],result[<span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">robTree</span><span class="hljs-params">(TreeNode *cur)</span></span>&#123; <span class="hljs-comment">// 二叉树的后序遍历 返回的是dp数组，0代表不偷，1代表偷 // 1、确定返回值和参数</span><br><span class="hljs-comment">// 2、确定终止条件</span><br>    <span class="hljs-keyword">if</span>(cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br><span class="hljs-comment">// 3、确定单层递归的逻辑</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; left = <span class="hljs-built_in">robTree</span>(cur-&gt;left);<span class="hljs-comment">//左，统计左孩偷与不偷的钱币</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; right = <span class="hljs-built_in">robTree</span>(cur-&gt;right);<span class="hljs-comment">// 右，统计右孩子偷与不偷的钱币</span><br>    <span class="hljs-type">int</span> val1 = cur-&gt;val + left[<span class="hljs-number">0</span>] +right[<span class="hljs-number">0</span>];<span class="hljs-comment">//偷当前节点，左右孩子都不能偷 中</span><br>    <span class="hljs-type">int</span> val2 = <span class="hljs-built_in">max</span>(left[<span class="hljs-number">0</span>],left[<span class="hljs-number">1</span>]) + <span class="hljs-built_in">max</span>(right[<span class="hljs-number">0</span>],right[<span class="hljs-number">1</span>]);<span class="hljs-comment">//不偷当前节点，选择孩子偷与不偷的最大钱币数量 中</span><br>    <span class="hljs-keyword">return</span> &#123;val2,val1&#125;;<span class="hljs-comment">// 返回的就是传入的节点不偷与偷的最大金币</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="20、买卖股票的最佳时机"><a href="#20、买卖股票的最佳时机" class="headerlink" title="20、买卖股票的最佳时机"></a>20、买卖股票的最佳时机</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/</a></p>
<p>只允许买卖一次</p>
<p>1、确定dp数组（dp table）以及下标的含义</p>
<p>dp[i] [0] 表示第i天持有股票所得最多利润 ，<strong>这里可能有同学疑惑，本题中只能买卖一次，持有股票之后哪还有现金呢？</strong>–说成利润就好理解了</p>
<p>其实一开始利润是0，那么加入第i天买入股票利润就是 -prices[i]， 这是一个负数。</p>
<p>dp[i] [1] 表示第i天不持有股票所得最多利润</p>
<p><strong>注意这里说的是“持有”，“持有”不代表就是当天“买入”！也有可能是昨天就买入了，今天保持持有的状态</strong></p>
<p>很多同学把“持有”和“买入”没区分清楚。</p>
<p>2、确定递推公式</p>
<p>如果第i天持有股票即dp[i] [0]， 那么可以由两个状态推出来</p>
<ul>
<li>第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1] [0]</li>
<li>第i天买入股票，所得现金就是买入今天的股票后所得利润即：-prices[i]</li>
</ul>
<p>那么dp[i] [0]应该选所得现金最大的，所以<strong>dp[i] [0] &#x3D; max(dp[i - 1] [0], -prices[i]);</strong></p>
<p>如果第i天不持有股票即dp[i] [1]， 也可以由两个状态推出来</p>
<ul>
<li>第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1] [1]</li>
<li>第i天卖出股票，所得现金就是按照今天股票价格卖出后所得利润即：prices[i] + dp[i - 1] [0]</li>
</ul>
<p>同样dp[i] [1]取最大的，dp[i] [1] &#x3D; max(dp[i - 1] [1], prices[i] + dp[i - 1] [0]);</p>
<p>3、dp数组如何初始化</p>
<p>由递推公式 dp[i] [0] &#x3D; max(dp[i - 1] [0], -prices[i]); 和 dp[i] [1] &#x3D; max(dp[i - 1] [1], prices[i] + dp[i - 1] [0]);可以看出</p>
<p>其基础都是要从dp[0] [0]和dp[0] [1]推导出来。</p>
<p>那么dp[0] [0]表示第0天持有股票，此时的持有股票就一定是买入股票了，因为不可能有前一天推出来，所以dp[0] [0] -&#x3D; prices[0];</p>
<p>dp[0] [1]表示第0天不持有股票，不持有股票那么利润就是0，所以dp[0] [1] &#x3D; 0;</p>
<p>4、确定遍历顺序</p>
<p>从递推公式可以看出dp[i]都是由dp[i - 1]推导出来的，那么一定是从前向后遍历。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len = prices.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(len,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] -= prices[<span class="hljs-number">0</span>];<span class="hljs-comment">// dp数组初始化，第0天持有，等于当天买入，所得收益为-prices[0]；</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">// 第0天不持有，收益就是0</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">1</span>; i&lt;len;i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],-prices[i]);<span class="hljs-comment">//当天买入，利润为-prices[0]</span><br>            dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>],prices[i]+dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]);<span class="hljs-comment">// 前一天不持有，和前一天持有今天卖出取最大值</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[len<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;; <span class="hljs-comment">// 为什么最后结果是dp[len-1][1]而不是dp[len-1][0]:因为不持有股票（卖出）一定比持有利润高--只卖买一次。</span><br></code></pre></td></tr></table></figure>

<h2 id="21、买卖股票的最佳时机"><a href="#21、买卖股票的最佳时机" class="headerlink" title="21、买卖股票的最佳时机||"></a>21、买卖股票的最佳时机||</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/</a></p>
<p>可以买卖无数次。</p>
<p>因为一只股票可以买卖多次，所以当第i天买入股票的时候，所持有的现金可能有之前买卖过的利润，<strong>即i-1天有利润。</strong></p>
<p>所以区别在于递推公式不同，dp[i] [0] &#x3D; max(dp[i - 1] [0], <strong>dp[i - 1] [1] - prices[i]</strong>); 第i天持有股票的利润发生了变化，可以在买入时有之前卖出的利润。</p>
<p>代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>    <span class="hljs-comment">// 贪心算法</span><br>    <span class="hljs-comment">//     int result = 0;</span><br>    <span class="hljs-comment">//     for(int i = 1;i &lt; prices.size();i++)&#123;</span><br>    <span class="hljs-comment">//         result += max(prices[i]-prices[i-1],0);// 只收集每天的正利润，局部最优得到全局最优</span><br>    <span class="hljs-comment">//     &#125;</span><br>    <span class="hljs-comment">//     return result;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// 动态规划</span><br>    <span class="hljs-type">int</span> len = prices.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(len,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>));<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">1</span>;i&lt;len;i++)&#123;<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]-prices[i]);<span class="hljs-comment">// 要考虑i-1天持有，第i天卖出的收益（因为可以多次买卖，所以第i-1天有收益）</span><br>        dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>],prices[i]+dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[len<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="22、买卖股票的最佳时机"><a href="#22、买卖股票的最佳时机" class="headerlink" title="22、买卖股票的最佳时机|||"></a>22、买卖股票的最佳时机|||</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/</a></p>
<p>最多买卖两次</p>
<p>有了多种状态加以区分。</p>
<p>1、确定dp数组以及下标的含义</p>
<p>一天一共就有五个状态，</p>
<ol>
<li>没有操作 （其实我们也可以不设置这个状态） 0</li>
<li>第一次持有股票 1</li>
<li>第一次不持有股票 2</li>
<li>第二次持有股票 3</li>
<li>第二次不持有股票 4</li>
</ol>
<p>dp[i] [j]中 i表示第i天，j为 [0 - 4] 五个状态，dp[i] [j]表示第i天状态j的收益。</p>
<p>需要注意：dp[i] [1]，<strong>表示的是第i天，持有股票的状态，并不是说一定要第i天买入股票，这是很多同学容易陷入的误区</strong>。</p>
<p>例如 dp[i] [1] ，并不是说 第i天一定买入股票，有可能 第 i-1天 就买入了，那么 dp[i] [1] 延续持有股票的这个状态。</p>
<p>2、确定递推公式</p>
<p>达到dp[i] [1]状态，有两个具体操作：</p>
<ul>
<li>操作一：第i天买入股票了，那么dp[i] [ 1] &#x3D; dp[i-1] [0] - prices[i]</li>
<li>操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i] [1] &#x3D; dp[i - 1] [1]</li>
</ul>
<p>那么dp[i] [1]究竟选 dp[i-1] [0] - prices[i]，还是dp[i - 1] [ 1]呢？</p>
<p>一定是选最大的，所以 dp[i] [1] &#x3D; max(dp[i-1] [0] - prices[i], dp[i - 1] [1]);</p>
<p>同理dp[i] [2]也有两个操作：</p>
<ul>
<li>操作一：第i天卖出股票了，那么dp[i] [2] &#x3D; dp[i - 1] [1] + prices[i]</li>
<li>操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp[i] [2] &#x3D; dp[i - 1] [2]</li>
</ul>
<p>所以dp[i] [2] &#x3D; max(dp[i - 1] [1] + prices[i], dp[i - 1] [2])</p>
<p>同理可推出剩下状态部分：</p>
<p>dp[i] [3] &#x3D; max(dp[i - 1] [3], dp[i - 1] [2] - prices[i]);</p>
<p>dp[i] [4] &#x3D; max(dp[i - 1] [4], dp[i - 1] [3] + prices[i]);</p>
<p>3、数组初始化</p>
<p>0天没有操作，这个最容易想到，就是0，即：dp[0] [0] &#x3D; 0;</p>
<p>第0天做第一次买入的操作，dp[0] [1] &#x3D; -prices[0];</p>
<p>第0天做第一次卖出的操作，这个初始值应该是多少呢？</p>
<p>此时还没有买入，怎么就卖出呢？ 其实大家可以理解当天买入，当天卖出，收益不变，所以dp[0] [2] &#x3D; 0;</p>
<p>第0天第二次买入操作，初始值应该是多少呢？应该不少同学疑惑，第一次还没买入呢，怎么初始化第二次买入呢？</p>
<p>第二次买入依赖于第一次卖出的状态，其实相当于第0天第一次买入了，第一次卖出了，然后再买入一次（第二次买入），那么现在手头上没有收益，只要买入，现金就做相应的减少。</p>
<p>所以第二次买入操作，初始化为：dp[0] [3] &#x3D; -prices[0];</p>
<p>同理第二次卖出初始化dp[0] [4] &#x3D; 0;当天买入当天卖出</p>
<p>4、确定遍历顺序</p>
<p>从递归公式其实已经可以看出，一定是从前向后遍历，因为dp[i]，依靠dp[i - 1]的数值。</p>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (prices.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(prices.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">5</span>, <span class="hljs-number">0</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>            dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);<br>            dp[i][<span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);<br>            dp[i][<span class="hljs-number">3</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>] - prices[i]);<br>            dp[i][<span class="hljs-number">4</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">4</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>] + prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[prices.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][<span class="hljs-number">4</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="23、买卖股票的最佳时机IV"><a href="#23、买卖股票的最佳时机IV" class="headerlink" title="23、买卖股票的最佳时机IV"></a>23、买卖股票的最佳时机IV</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/</a></p>
<p>最多可以有k次买卖，奇数次是买入，偶数次是卖出</p>
<p>1、确定dp数组以及下标的含义</p>
<p>在上一题中，我们定义了一个二维dp数组，本题其实依然可以用一个二维dp数组。</p>
<p>使用二维数组 dp[i] [j] ：第i天的状态为j，所剩下的最大利润是dp[i] [j]</p>
<p>j的状态表示为：</p>
<ul>
<li>0 表示不操作</li>
<li>1 第一次买入</li>
<li>2 第一次卖出</li>
<li>3 第二次买入</li>
<li>4 第二次卖出</li>
<li>…..</li>
</ul>
<p><strong>大家应该发现规律了吧 ，除了0以外，偶数就是卖出，奇数就是买入</strong>。</p>
<p>题目要求是至多有K笔交易，那么j的范围就定义为 2 * k + 1 就可以了。</p>
<p>所以二维dp数组的C++定义为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(prices.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br></code></pre></td></tr></table></figure>

<p>2、确定递推公式</p>
<p>达到dp[i] [1]状态，有两个具体操作：</p>
<ul>
<li>操作一：第i天买入股票了，那么dp[i] [1] &#x3D; dp[i - 1] [0] - prices[i]</li>
<li>操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i] [1] &#x3D; dp[i - 1] [1]</li>
</ul>
<p>选最大的，所以 dp[i] [1] &#x3D; max(dp[i - 1] [0] - prices[i], dp[i - 1] [1]);</p>
<p>同理dp[i] [2]也有两个操作：</p>
<ul>
<li>操作一：第i天卖出股票了，那么dp[i] [2] &#x3D; dp[i - 1] [1] + prices[i]</li>
<li>操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp[i] [2] &#x3D; dp[i - 1] [2]</li>
</ul>
<p>所以dp[i] [2] &#x3D; max(dp[i - 1] [1] + prices[i], dp[i - 1] [2])</p>
<p>同理可以类比剩下的状态，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span> * k - <span class="hljs-number">1</span>; j += <span class="hljs-number">2</span>) &#123;<br>    dp[i][j + <span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j] - prices[i]);<br>    dp[i][j + <span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">2</span>], dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] + prices[i]);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>本题和上一题的最大的区别就是这里要类比j为奇数是买，偶数是卖的状态</strong>。</p>
<p>3、dp数组如何初始化</p>
<p>第0天没有操作，这个最容易想到，就是0，即：dp[0] [0] &#x3D; 0;</p>
<p>第0天做第一次买入的操作，dp[0] [1] &#x3D; -prices[0];</p>
<p>第0天做第一次卖出的操作，这个初始值应该是多少呢？</p>
<p>此时还没有买入，怎么就卖出呢？ 其实大家可以理解<strong>当天买入，当天卖出</strong>，所以dp[0] [2] &#x3D; 0;</p>
<p>第0天第二次买入操作，初始值应该是多少呢？应该不少同学疑惑，第一次还没买入呢，怎么初始化第二次买入呢？</p>
<p>第二次买入依赖于第一次卖出的状态，其实相当于第0天第一次买入了，第一次卖出了，然后在买入一次（第二次买入），那么现在手头上没有现金，只要买入，现金就做相应的减少。</p>
<p>所以第二次买入操作，初始化为：dp[0] [3] &#x3D; -prices[0];</p>
<p>第二次卖出初始化dp[0] [4] &#x3D; 0;</p>
<p><strong>所以同理可以推出dp[0] [j]当j为奇数的时候都初始化为 -prices[0]</strong></p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">2</span> * k; j += <span class="hljs-number">2</span>) &#123;<br>    dp[<span class="hljs-number">0</span>][j] = -prices[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>4、确定遍历顺序</p>
<p>从递归公式其实已经可以看出，一定是从前向后遍历，因为dp[i]，依靠dp[i - 1]的数值。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span> k, vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span> (prices.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(prices.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<span class="hljs-comment">// 定义dp数组的大小</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">2</span> * k; j += <span class="hljs-number">2</span>) &#123;<span class="hljs-comment">// dp数组初始化 奇数次是买入，只要是买入 利润均为-prices[0]</span><br>            dp[<span class="hljs-number">0</span>][j] = -prices[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; prices.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span> * k - <span class="hljs-number">1</span>; j += <span class="hljs-number">2</span>) &#123;<br>                dp[i][j + <span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j] - prices[i]);<br>                dp[i][j + <span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">2</span>], dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] + prices[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[prices.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][<span class="hljs-number">2</span> * k];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>24、买卖股票的最佳时机含冷冻期、</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/</a></p>
<ul>
<li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li>
<li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li>
</ul>
<p>1、确定dp数组以及下标的含义</p>
<p>dp[i] [j]，第i天状态为j，收益为dp[i] [j]。</p>
<ul>
<li>状态一：持有股票状态（今天买入股票，或者是之前就买入了股票然后没有操作，一直持有）</li>
<li>不持有股票状态，这里就有两种卖出股票状态<ul>
<li>状态二：保持卖出股票的状态（两天前就卖出了股票，度过一天冷冻期。或者是前一天就是卖出股票状态，一直没操作）</li>
<li>状态三：今天卖出股票</li>
</ul>
</li>
<li>状态四：今天为冷冻期状态，但冷冻期状态不可持续，只有一天</li>
</ul>
<p>买卖股票最佳时机 1，2，3，4 的题目讲解中，今天卖出股票」我是没有单独列出一个状态的归类为「不持有股票的状态」，而本题为什么要单独列出「今天卖出股票」 一个状态呢？</p>
<p>因为本题我们有<strong>冷冻期</strong>，而冷冻期的前一天，只能是 「今天卖出股票」状态，如果是 「不持有股票状态」那么就很模糊，因为不一定是 卖出股票的操作。</p>
<p>2、确定递推公式</p>
<p><strong>达到买入股票状态</strong>（状态一）即：dp[i] [0]，有两个具体操作：</p>
<ul>
<li>操作一：前一天就是持有股票状态（状态一），<strong>dp[i] [0] &#x3D; dp[i - 1] [0]</strong></li>
<li>操作二：今天买入了，有两种情况<ul>
<li>前一天是冷冻期（状态四），dp[i - 1] [3] - prices[i]</li>
<li>前一天是保持卖出股票的状态（状态二），dp[i - 1] [1] - prices[i]</li>
</ul>
</li>
</ul>
<p>那么dp[i] [0] &#x3D; max(dp[i - 1] [0], dp[i - 1] [3] - prices[i], dp[i - 1] [1] - prices[i]);</p>
<p><strong>达到保持卖出股票状态</strong>（状态二）即：dp[i] [1]，有两个具体操作：</p>
<ul>
<li>操作一：前一天就是状态二  dp[i] [1] &#x3D; <strong>dp[i-1] [1]</strong></li>
<li>操作二：前一天是冷冻期（状态四）dp[i] [1] &#x3D;  <strong>dp[i-1] [3]</strong></li>
</ul>
<p>dp[i] [1] &#x3D; max(dp[i - 1] [1], dp[i - 1] [3]);</p>
<p><strong>达到今天就卖出股票状态</strong>（状态三），即：dp[i] [2] ，只有一个操作：</p>
<p>昨天一定是持有股票状态（状态一），今天卖出</p>
<p>即：dp[i] [2] &#x3D; <strong>dp[i - 1] [0] + prices[i];</strong></p>
<p><strong>达到冷冻期状态</strong>（状态四），即：dp[i] [3]，只有一个操作：</p>
<p>昨天卖出了股票（状态三）</p>
<p><strong>dp[i] [3] &#x3D; dp[i - 1] [2];</strong></p>
<p>综上分析，递推代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) - prices[i]);<span class="hljs-comment">//状态1，保持买入状态：前一天冷冻期，今天买入或者前一天是卖出状态。</span><br>dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>]);<span class="hljs-comment">// 状态2，保持卖出状态：前一天就卖出了，或者前一天冷冻期，今天没操作</span><br>dp[i][<span class="hljs-number">2</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i];<span class="hljs-comment">// 状态3，今天卖出股票：前一天持有股票，今天卖出</span><br>dp[i][<span class="hljs-number">3</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]; <span class="hljs-comment">// 状态4 ，处于冷冻期：则昨天卖出了股票</span><br></code></pre></td></tr></table></figure>

<p>3、dp数组如何初始化</p>
<p>dp[0] [0] &#x3D; -prices[0] ：当天买入，收益就是-prices[0]。</p>
<p>dp[0] [1] &#x3D; 0：当天买入当天卖出，收益不变，为0。</p>
<p>同理，dp[0] [2] 、dp[0] [3] 都初始化为0.</p>
<p>4、确定遍历顺序</p>
<p>从递归公式上可以看出，dp[i] 依赖于 dp[i-1]，所以是从前向后遍历。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = prices.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">4</span>, <span class="hljs-number">0</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] -= prices[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 持股票</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>] - prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] - prices[i]));<br>            dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>]);<br>            dp[i][<span class="hljs-number">2</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i];<br>            dp[i][<span class="hljs-number">3</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>], <span class="hljs-built_in">max</span>(dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]));<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>最后结果是取 状态二，状态三，和状态四的最大值，不少同学会把状态四忘了，状态四是冷冻期，最后一天如果是冷冻期也可能是最大值。</strong></p>
<h2 id="24、买卖股票的最佳时机含手续费"><a href="#24、买卖股票的最佳时机含手续费" class="headerlink" title="24、买卖股票的最佳时机含手续费"></a>24、买卖股票的最佳时机含手续费</h2><p>每次交易需支付一次手续费，无限次交易。</p>
<p>对比买卖股票的最佳时机||，只是在卖出操作时计算手续费即可，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices, <span class="hljs-type">int</span> fee)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = prices.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] -= prices[<span class="hljs-number">0</span>]; <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] - prices[i]);<br>            dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i] - fee);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="25、最长上升子序列"><a href="#25、最长上升子序列" class="headerlink" title="25、最长上升子序列"></a>25、最长上升子序列</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/">https://leetcode.cn/problems/longest-increasing-subsequence/</a></p>
<p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>
<p>当前下标i的递增子序列长度，其实和i之前的下表j的子序列长度有关系，那又是什么样的关系呢。</p>
<p>1、dp[i]的定义</p>
<p>本题中，正确定义dp数组的含义十分重要。</p>
<p><strong>dp[i]表示i之前包括i的以nums[i]结尾的最长递增子序列的长度</strong></p>
<p>为什么一定表示 “以nums[i]结尾的最长递增子序” ，因为我们在做“递增比较”的时候，如果比较 nums[j] 和 nums[i] 的大小，那么两个递增子序列一定分别以nums[j]为结尾 和 nums[i]为结尾， 要不然这个比较就没有意义了，不是尾部元素的比较那么 如何算递增呢。</p>
<p>2、状态转移方程（递推公式）</p>
<p>位置i的最长升序子序列等于<strong>j从0到i-1各个位置的最长升序子序列</strong> + 1 的最大值。</p>
<p>i因此：if (nums[i] &gt; nums[j]) dp[i] &#x3D; max(dp[i], dp[j] + 1);</p>
<p>3、dp[i]的初始化</p>
<p>每一个i，对应的dp[i]（即最长递增子序列）起始大小至少都是1.</p>
<p>4、确定遍历顺序</p>
<p>dp[i] 是有0到i-1各个位置的最长递增子序列 推导而来，那么遍历i一定是从前向后遍历。</p>
<p>j其实就是遍历0到i-1，那么是从前到后，还是从后到前遍历都无所谓，只要吧 0 到 i-1 的元素都遍历了就行了。 所以默认习惯 从前向后遍历。</p>
<p>遍历i的循环在外层，遍历j则在内层，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &gt; nums[j]) dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dp[i] &gt; result) result = dp[i]; <span class="hljs-comment">// 取长的子序列</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size(), <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] &gt; nums[j]) dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (dp[i] &gt; result) result = dp[i]; <span class="hljs-comment">// 取长的子序列</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="26、最长连续递增序列"><a href="#26、最长连续递增序列" class="headerlink" title="26、最长连续递增序列"></a>26、最长连续递增序列</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">https://leetcode.cn/problems/longest-continuous-increasing-subsequence/</a></p>
<p>本题与上题的区别在于连续。</p>
<p>1、确定dp数组（dp table）以及下标的含义</p>
<p>**dp[i]：以下标i为结尾的连续递增的子序列长度为dp[i]**。</p>
<p>注意这里的定义，一定是以下标i为结尾，并不是说一定以下标0为起始位置。</p>
<p>2、确定递推公式</p>
<p>如果 nums[i] &gt; nums[i - 1]，那么以 i 为结尾的连续递增的子序列长度 一定等于 以i - 1为结尾的连续递增的子序列长度 + 1 </p>
<p>即：<strong>dp[i] &#x3D; dp[i - 1] + 1</strong>;</p>
<p><strong>注意这里就体现出和上一道题目的区别！</strong></p>
<p>因为本题要求连续递增子序列，所以就只要比较nums[i]与nums[i - 1]，而不用去比较nums[j]与nums[i] （j是在0到i之间遍历）。</p>
<p>3、dp数组如何初始化</p>
<p>以下标i为结尾的连续递增的子序列长度最少也应该是1，即就是nums[i]这一个元素。</p>
<p>所以dp[i]应该初始1;</p>
<p>4、遍历顺序</p>
<p>从递推公式上可以看出， dp[i + 1]依赖dp[i]，所以一定是从前向后遍历</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    <span class="hljs-keyword">if</span> (nums[i] &gt; nums[i - <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 连续记录</span><br>        dp[i] = dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLengthOfLCIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">1</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size() ,<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[i - <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 连续记录</span><br>                dp[i] = dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (dp[i] &gt; result) result = dp[i];<span class="hljs-comment">//取最大的值。</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="27、最长重复子数组"><a href="#27、最长重复子数组" class="headerlink" title="27、最长重复子数组"></a>27、最长重复子数组</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">https://leetcode.cn/problems/maximum-length-of-repeated-subarray/</a></p>
<p>给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度，其实就是最长公共子序列。</p>
<p>1、确定dp数组（dp table）以及下标的含义</p>
<p>dp[i] [j] ：以下标i - 1为结尾的<strong>A</strong>，和以下标j - 1为结尾的<strong>B</strong>，最长重复子数组长度为dp[i] [j]。 （<strong>特别注意</strong>： “以下标i - 1为结尾的A” 标明一定是 以A[i-1]为结尾的字符串 ）</p>
<p>dp[i] [j]的定义也就决定着，我们在遍历dp[i] [j]的时候i 和 j都要从1开始。为什么要从i-1和j-1开始，是为了初始化方便。</p>
<p>2、确定递推公式</p>
<p>根据dp[i] [j]的定义，dp[i] [j]的状态只能由dp[i - 1] [j - 1]推导出来。</p>
<p>即当A[i - 1] 和B[j - 1]相等的时候，dp[i] [j] &#x3D; dp[i - 1] [j - 1] + 1;</p>
<p>根据递推公式可以看出，遍历i 和 j 要从1开始！</p>
<p>3、dp数组如何初始化</p>
<p>根据dp[i] [j]的定义，dp[i] [0] 和dp[0] [j]其实都是没有意义的！</p>
<p>但dp[i] [0] 和dp[0] [j]要初始值，因为 为了方便递归公式dp[i] [j] &#x3D; dp[i - 1] [j - 1] + 1;</p>
<p>所以dp[i] [0] 和dp[0] [j]初始化为0。</p>
<p>举个例子A[0]如果和B[0]相同的话，dp[1] [1] &#x3D; dp[0] [0] + 1，只有dp[0] [0]初始为0，正好符合递推公式逐步累加起来。</p>
<p>4、确定遍历顺序</p>
<p>外层for循环遍历A，内层for循环遍历B。</p>
<p>那又有同学问了，外层for循环遍历B，内层for循环遍历A。不行么？</p>
<p>也行，一样的，我这里就用外层for循环遍历A，内层for循环遍历B了。</p>
<p>同时题目要求长度最长的子数组的长度。所以在遍历的时候顺便把dp[i] [j]的最大值记录下来。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">dp</span>(nums1.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(nums2.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<span class="hljs-comment">// dp数组的定义以及初始化，这里取num.size()+1,是因为dp数组下标的含义是到[i-1]和[j-1]结尾的最长重复子数组</span><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<span class="hljs-comment">// 记录结果，这里初始化为0，是因为后面会被覆盖。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">1</span>;i&lt;=nums1.<span class="hljs-built_in">size</span>();i++)&#123;<span class="hljs-comment">// &lt;=是因为下标含义是到[i-1]结尾</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=nums2.<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums1[i<span class="hljs-number">-1</span>] == nums2[j<span class="hljs-number">-1</span>])&#123;<br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br>                &#125; <br>                <span class="hljs-keyword">if</span>(dp[i][j] &gt; result) result =dp[i][j];<span class="hljs-comment">//要求长度最长的子数组的长度。所以在遍历的时候顺便把dp[i][j]的最大值记录下来</span><br>            &#125; <br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="28、最长公共子序列"><a href="#28、最长公共子序列" class="headerlink" title="28、最长公共子序列"></a>28、最长公共子序列</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-subsequence/">https://leetcode.cn/problems/longest-common-subsequence/</a></p>
<p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</p>
<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列</p>
<p>1、确定dp数组（dp table）以及下标的含义</p>
<p>dp[i] [j]：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列的<strong>长度</strong>（个数）为dp[i] [j]。这么定义下标是为了初始化方便。</p>
<p>2、确定递推公式</p>
<p>主要就是两大情况： text1[i - 1] 与 text2[j - 1]相同，text1[i - 1] 与 text2[j - 1]不相同</p>
<p>如果text1[i - 1] 与 text2[j - 1]相同，那么找到了一个公共元素，所以dp[i] [j] &#x3D; dp[i - 1] [j - 1] + 1;</p>
<p>如果text1[i - 1] 与 text2[j - 1]不相同，那就看看text1[0, i - 2]与text2[0, j - 1]的最长公共子序列 和 text1[0, i - 1]与text2[0, j - 2]的最长公共子序列，取最大的。</p>
<p>即：dp[i] [j] &#x3D; max(dp[i - 1] [j], dp[i] [j - 1]);</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (text1[i - <span class="hljs-number">1</span>] == text2[j - <span class="hljs-number">1</span>]) &#123;<br>    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>3、dp数组如何初始化</p>
<p>先看看dp[i] [0]应该是多少呢？</p>
<p>test1[0, i-1]和空串的最长公共子序列自然是0，所以dp[i] [0] &#x3D; 0;</p>
<p>同理dp[0] [j]也是0。</p>
<p>其他下标都是随着递推公式逐步覆盖，初始为多少都可以，那么就统一初始为0。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(text1.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(text2.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br></code></pre></td></tr></table></figure>

<p>4、遍历顺序</p>
<p>从递推公式，可以看出，有三个方向可以推出dp[i] [j]，那么为了在递推的过程中，这三个方向都是经过计算的数值，所以要从前向后，从上到下来遍历这个矩阵。</p>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(text1.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(text2.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= text1.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= text2.<span class="hljs-built_in">size</span>(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (text1[i - <span class="hljs-number">1</span>] == text2[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[text1.<span class="hljs-built_in">size</span>()][text2.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="29、不相交的线"><a href="#29、不相交的线" class="headerlink" title="29、不相交的线"></a>29、不相交的线</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/uncrossed-lines/">https://leetcode.cn/problems/uncrossed-lines/</a></p>
<p>绘制一些连接两个数字 A[i] 和 B[j] 的直线，只要 A[i] &#x3D;&#x3D; B[j]，且直线不能相交！</p>
<p>直线不能相交，这就是说明在字符串A中 找到一个与字符串B相同的子序列，且这个子序列不能改变相对顺序，只要相对顺序不改变，链接相同数字的直线就不会相交。其实也就是说A和B的最长公共子序列是[1,4]，长度为2。 这个公共子序列指的是相对顺序不变（即数字4在字符串A中数字1的后面，那么数字4也应该在字符串B数字1的后面）</p>
<p>这么分析完之后，大家可以发现：<strong>本题说是求绘制的最大连线数，其实就是求两个字符串的最长公共子序列的长度！</strong></p>
<p>所以代码跟上一题一样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxUncrossedLines</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; A, vector&lt;<span class="hljs-type">int</span>&gt;&amp; B)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(A.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(B.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= A.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= B.<span class="hljs-built_in">size</span>(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (A[i - <span class="hljs-number">1</span>] == B[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[A.<span class="hljs-built_in">size</span>()][B.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="30、最大子序和"><a href="#30、最大子序和" class="headerlink" title="30、最大子序和"></a>30、最大子序和</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/">https://leetcode.cn/problems/maximum-subarray/</a></p>
<p>1、确定dp数组（dp table）以及下标的含义</p>
<p>**dp[i]：包括下标i（以nums[i]为结尾）的最大连续子序列和为dp[i]**。</p>
<p>2、确定递推公式</p>
<p>dp[i]只有两个方向可以推出来：</p>
<ul>
<li>dp[i - 1] + nums[i]，即：nums[i]加入当前连续子序列和</li>
<li>nums[i]，即：从头开始计算当前连续子序列和</li>
</ul>
<p>一定是取最大的，所以dp[i] &#x3D; max(dp[i - 1] + nums[i], nums[i]);</p>
<p>3、dp数组如何初始化</p>
<p>从递推公式可以看出来dp[i]是依赖于dp[i - 1]的状态，dp[0]就是递推公式的基础。</p>
<p>dp[0]应该是多少呢?</p>
<p>根据dp[i]的定义，很明显dp[0]应为nums[0]即dp[0] &#x3D; nums[0]。</p>
<p>4、确定遍历顺序</p>
<p>递推公式中dp[i]依赖于dp[i - 1]的状态，需要从前向后遍历。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size())</span></span>;<span class="hljs-comment">//定义dp数组，并初始化大小</span><br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<span class="hljs-comment">// 初始化数组</span><br>        <span class="hljs-type">int</span> result = dp[<span class="hljs-number">0</span>];<span class="hljs-comment">// 用来记录结果</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>] + nums[i], nums[i]); <span class="hljs-comment">// 状态转移公式</span><br>            <span class="hljs-keyword">if</span> (dp[i] &gt; result) result = dp[i]; <span class="hljs-comment">// result 保存dp[i]的最大值</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="31、判断子序列"><a href="#31、判断子序列" class="headerlink" title="31、判断子序列"></a>31、判断子序列</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/is-subsequence/">https://leetcode.cn/problems/is-subsequence/</a></p>
<p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p>
<p>这里s是t的子串，t的长度肯定大于s，所以要删除也是删除t中的元素。</p>
<p>1、确定dp数组（dp table）以及下标的含义</p>
<p>**dp[i] [j] 表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为dp[i] [j]**。</p>
<p>注意这里是判断s是否为t的子序列。即t的长度是大于等于s的。</p>
<p>2、确定递推公式</p>
<p>在确定递推公式的时候，首先要考虑如下两种操作，整理如下：</p>
<ul>
<li>if (s[i - 1] &#x3D;&#x3D; t[j - 1])<ul>
<li>t中找到了一个字符在s中也出现了</li>
</ul>
</li>
<li>if (s[i - 1] !&#x3D; t[j - 1])<ul>
<li>相当于t要删除元素，继续匹配</li>
</ul>
</li>
</ul>
<p>if (s[i - 1] &#x3D;&#x3D; t[j - 1])，那么dp[i] [j] &#x3D; dp[i - 1] [j - 1] + 1;，因为找到了一个相同的字符，相同子序列长度自然要在dp[i-1] [j-1]的基础上加1</p>
<p>if (s[i - 1] !&#x3D; t[j - 1])，此时相当于t要删除元素，t如果把当前元素t[j - 1]删除，那么dp[i] [j] 的数值就是 看s[i - 1]与 t[j - 2]的比较结果了，即：dp[i] [j] &#x3D; dp[i] [j - 1];</p>
<p>3、dp数组如何初始化</p>
<p>从递推公式可以看出dp[i] [j]都是依赖于dp[i - 1] [j - 1] 和 dp[i] [j - 1]，所以dp[0] [0]和dp[i] [0]是一定要初始化的。同理dp[0] [j]也要初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(s.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(t.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br></code></pre></td></tr></table></figure>

<p>4、确定遍历顺序</p>
<p>同理从递推公式可以看出dp[i] [j]都是依赖于dp[i - 1] [j - 1] 和 dp[i] [ j - 1]，那么遍历顺序也应该是从上到下，从左到右。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSubsequence</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(s.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(t.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<span class="hljs-comment">//定义dp数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-comment">//&lt;= 是因为表示i-1/j-1</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= t.<span class="hljs-built_in">size</span>(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (s[i - <span class="hljs-number">1</span>] == t[j - <span class="hljs-number">1</span>])<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> dp[i][j] = dp[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (dp[s.<span class="hljs-built_in">size</span>()][t.<span class="hljs-built_in">size</span>()] == s.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>dp[i] [j]表示以下标i-1为结尾的字符串s和以下标j-1为结尾的字符串t 相同子序列的长度，所以如果dp[s.size()] [t.size()] 与 字符串s的长度相同说明：s与t的最长相同子序列就是s，那么s 就是 t 的子序列。</p>
<h2 id="32、不同的子序列"><a href="#32、不同的子序列" class="headerlink" title="32、不同的子序列"></a>32、不同的子序列</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/distinct-subsequences/">https://leetcode.cn/problems/distinct-subsequences/</a></p>
<p>给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</p>
<p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p>
<p>1、确定dp数组（dp table）以及下标的含义</p>
<p>dp[i] [j]：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i] [j]。</p>
<p>记住dp数组的定义，为了理解递推公式的含义，至于为什么用i-1、j-1结尾，是为了初始化方便而已，交给递推公式就可以了。</p>
<p>2、确定递推公式</p>
<p>这一类问题，基本是要分析两种情况</p>
<ul>
<li>s[i - 1] 与 t[j - 1]相等</li>
<li>s[i - 1] 与 t[j - 1] 不相等</li>
</ul>
<p>当s[i - 1] 与 t[j - 1]相等时，dp[i] [j]可以有两部分组成。</p>
<p>一部分是用s[i - 1]来匹配，那么个数为dp[i - 1] [j - 1]。即不需要考虑当前s子串和t子串的最后一位字母，所以只需要 dp[i-1] [j-1]。</p>
<p>一部分是不用s[i - 1]来匹配，个数为dp[i - 1] [j]。用s[i-2]取匹配。例如： s： bagg 和 t： bag ，s[3] 和 t[2]是相同的，但是字符串s也可以不用s[3]来匹配，即用s[0]s[1]s[2]组成的bag。当然也可以用s[3]来匹配，即：s[0]s[1]s[3]组成的bag。</p>
<p>所以当s[i - 1] 与 t[j - 1]相等时，dp[i] [j] &#x3D; dp[i - 1] [j - 1] + dp[i - 1] [j];</p>
<p>当s[i - 1] 与 t[j - 1]不相等时，dp[i] [j]只有一部分组成，不用s[i - 1]来匹配（就是模拟在s中删除这个元素），即：dp[i - 1] [j]</p>
<p>所以递推公式为：dp[i] [j] &#x3D; dp[i - 1] [j]; &#x2F;&#x2F; 即模拟在s中删除一位来匹配。</p>
<p><strong>为什么只考虑 “不用s[i - 1]来匹配” 这种情况， 不考虑 “不用t[j - 1]来匹配” 的情况呢。这里大家要明确，我们求的是 s 中有多少个 t，而不是 求t中有多少个s，所以只考虑 s中删除元素的情况，即 不用s[i - 1]来匹配 的情况。</strong></p>
<p>3、dp数组如何初始化</p>
<p>从递推公式dp[i] [j] &#x3D; dp[i - 1] [j - 1] + dp[i - 1] [j]; 和 dp[i] [j] &#x3D; dp[i - 1] [j]; 中可以看出dp[i] [j] 是从上方和左上方推导而来，如图：，那么 dp[i] [0] 和dp[0] [j]是一定要初始化的。</p>
<p>dp[i] [0] 表示：以i-1为结尾的s可以随便删除元素，出现空字符串的个数。</p>
<p>那么dp[i] [0]一定都是1，因为也就是把以i-1为结尾的s，删除所有元素，出现空字符串的个数就是1。</p>
<p>再来看dp[0] [j]，dp[0] [j]：空字符串s可以随便删除元素，出现以j-1为结尾的字符串t的个数。</p>
<p>那么dp[0] [j]一定都是0，s如论如何也变成不了t。</p>
<p>dp[0] [0]应该是1，空字符串s，可以删除0个元素，变成空字符串t。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt;&gt; <span class="hljs-built_in">dp</span>(s.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt;(t.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= s.<span class="hljs-built_in">size</span>(); i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= t.<span class="hljs-built_in">size</span>(); j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 其实这行代码可以和dp数组初始化的时候放在一起，但我为了凸显初始化的逻辑，所以还是加上了。</span><br></code></pre></td></tr></table></figure>

<p>4、确定遍历顺序</p>
<p>从递推公式dp[i] [j] &#x3D; dp[i - 1] [j - 1] + dp[i - 1] [j]; 和 dp[i] [j] &#x3D; dp[i - 1] [j]; 中可以看出dp[i] [j]都是根据左上方和正上方推出来的。所以遍历的时候一定是从上到下，从左到右，这样保证dp[i] [j]可以根据之前计算出来的数值进行计算。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numDistinct</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">uint64_t</span>&gt;&gt; <span class="hljs-built_in">dp</span>(s.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">uint64_t</span>&gt;(t.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; t.<span class="hljs-built_in">size</span>(); j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= t.<span class="hljs-built_in">size</span>(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (s[i - <span class="hljs-number">1</span>] == t[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">1</span>][j];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<span class="hljs-comment">//模拟删s</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[s.<span class="hljs-built_in">size</span>()][t.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="33、两个字符串的删除操作"><a href="#33、两个字符串的删除操作" class="headerlink" title="33、两个字符串的删除操作"></a>33、两个字符串的删除操作</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-operation-for-two-strings/">https://leetcode.cn/problems/delete-operation-for-two-strings/</a></p>
<p>对比上一道题，不同点在于两个字符串都可以删除，而不是只能删除其中一个字符串。</p>
<p>1、确定dp数组（dp table）以及下标的含义</p>
<p>dp[i] [j]：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数为dp[i] [j]。–记住定义</p>
<p>2、确定递推公式</p>
<ul>
<li>当word1[i - 1] 与 word2[j - 1]相同的时候</li>
<li>当word1[i - 1] 与 word2[j - 1]不相同的时候</li>
</ul>
<p><strong>当word1[i - 1] 与 word2[j - 1]相同的时候，dp[i] [j] &#x3D; dp[i - 1] [j - 1];</strong></p>
<p>当word1[i - 1] 与 word2[j - 1]不相同的时候，有三种情况：</p>
<p><strong>情况一</strong>：删word1[i - 1]，最少操作次数为dp[i - 1] [j] + 1</p>
<p><strong>情况二</strong>：删word2[j - 1]，最少操作次数为dp[i] [j - 1] + 1</p>
<p>情况三：同时删word1[i - 1]和word2[j - 1]，操作的最少次数为dp[i - 1] [j - 1] + 2</p>
<p>那最后当然是取最小值，所以当word1[i - 1] 与 word2[j - 1]不相同的时候，递推公式：dp[i] [j] &#x3D; min({dp[i - 1] [j - 1] + 2, dp[i - 1] [j] + 1, dp[i] [j - 1] + 1});</p>
<p>因为 dp[i] [j - 1] + 1 &#x3D; dp[i - 1] [j - 1] + 2，所以递推公式可简化为：dp[i] [j] &#x3D; min(dp[i - 1] [j] + 1, dp[i] [j - 1] + 1);</p>
<p>这里可能不少录友有点迷糊，从字面上理解 就是 当 同时删word1[i - 1]和word2[j - 1]，dp[i] [j-1] 本来就不考虑 word2[j - 1]了，那么我在删 word1[i - 1]，是不是就达到两个元素都删除的效果，即 dp[i] [j-1] + 1。</p>
<p>3、dp数组如何初始化</p>
<p>从递推公式中，可以看出来，dp[i] [0] 和 dp[0] [j]是一定要初始化的。</p>
<p>dp[i] [0]：word2为空字符串，以i-1为结尾的字符串word1要删除多少个元素，才能和word2相同呢，很明显dp[i] [0] &#x3D; i。</p>
<p>dp[0] [j]的话同理，所以代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(word1.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(word2.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= word1.<span class="hljs-built_in">size</span>(); i++) dp[i][<span class="hljs-number">0</span>] = i;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= word2.<span class="hljs-built_in">size</span>(); j++) dp[<span class="hljs-number">0</span>][j] = j;<br></code></pre></td></tr></table></figure>

<p>4、确定遍历顺序</p>
<p>从递推公式 dp[i] [j] &#x3D; min(dp[i - 1] [j - 1] + 2, min(dp[i - 1] [j], dp[i] [j - 1]) + 1); 和dp[i] [j] &#x3D; dp[i - 1] [j - 1]可以看出dp[i] [j]都是根据左上方、正上方、正左方推出来的。</p>
<p>所以遍历的时候一定是从上到下，从左到右，这样保证dp[i] [j]可以根据之前计算出来的数值进行计算。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(string word1, string word2)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(word1.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(word2.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= word1.<span class="hljs-built_in">size</span>(); i++) dp[i][<span class="hljs-number">0</span>] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= word2.<span class="hljs-built_in">size</span>(); j++) dp[<span class="hljs-number">0</span>][j] = j;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= word1.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= word2.<span class="hljs-built_in">size</span>(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (word1[i - <span class="hljs-number">1</span>] == word2[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>, dp[i][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[word1.<span class="hljs-built_in">size</span>()][word2.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="33、编辑距离"><a href="#33、编辑距离" class="headerlink" title="33、编辑距离"></a>33、编辑距离</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/edit-distance/">https://leetcode.cn/problems/edit-distance/</a></p>
<p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<p>对比前两题，所涉及的字符串个数变成了两个，支持的操作变成了三种，由浅入深，本题是采用动态规划解决的经典问题。</p>
<p>1、确定dp数组及其下标的含义</p>
<p>**dp[i] [j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i] [j]**。（最少的编辑次数为 dp[i] [j],使得两个字符串相等)</p>
<p>2、确定递推公式</p>
<p>在确定递推公式的时候，首先要考虑清楚编辑的几种操作，整理如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (word1[i - <span class="hljs-number">1</span>] == word2[j - <span class="hljs-number">1</span>])<br>    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br><span class="hljs-keyword">if</span> (word1[i - <span class="hljs-number">1</span>] != word2[j - <span class="hljs-number">1</span>])<br>    增 <span class="hljs-number">1</span>删除等于<span class="hljs-number">2</span>添加，操作数量一样。考虑删除就可以了<br>    删 dp[i][j] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j] +<span class="hljs-number">1</span> ,dp[i][j<span class="hljs-number">-1</span>] +<span class="hljs-number">1</span>);<br><span class="hljs-comment">//rose--&gt;ros  				ros  rose</span><br>    换 dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] +<span class="hljs-number">1</span>;<br><span class="hljs-comment">// ab ac </span><br>    取最小的：dp[i][j] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] +<span class="hljs-number">1</span>,dp[i<span class="hljs-number">-1</span>][j] +<span class="hljs-number">1</span> ,dp[i][j<span class="hljs-number">-1</span>] +<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>

<p>3、dp数组初始化</p>
<p>再回顾一下dp[i] [j]的定义：</p>
<p>**dp[i] [j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i] [j]**。</p>
<p>那么dp[i] [0] 和 dp[0] [j] 表示什么呢？</p>
<p>dp[i] [0] ：以下标i-1为结尾的字符串word1，和空字符串word2，最近编辑距离为dp[i] [0]。</p>
<p>那么dp[i] [0]就应该是i，对word1里的元素全部做删除操作，即：dp[i] [0] &#x3D; i;</p>
<p>同理dp[0] [j] &#x3D; j;</p>
<p>所以C++代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= word1.<span class="hljs-built_in">size</span>(); i++) dp[i][<span class="hljs-number">0</span>] = i;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= word2.<span class="hljs-built_in">size</span>(); j++) dp[<span class="hljs-number">0</span>][j] = j;<br></code></pre></td></tr></table></figure>

<p>4、遍历顺序</p>
<p>在dp矩阵中一定是从左到右从上到下去遍历</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(string word1, string word2)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(word1.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(word2.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= word1.<span class="hljs-built_in">size</span>(); i++) dp[i][<span class="hljs-number">0</span>] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= word2.<span class="hljs-built_in">size</span>(); j++) dp[<span class="hljs-number">0</span>][j] = j;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= word1.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= word2.<span class="hljs-built_in">size</span>(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (word1[i - <span class="hljs-number">1</span>] == word2[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = <span class="hljs-built_in">min</span>(&#123;dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]&#125;) + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[word1.<span class="hljs-built_in">size</span>()][word2.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="34、回文子串"><a href="#34、回文子串" class="headerlink" title="34、回文子串"></a>34、回文子串</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindromic-substrings/">https://leetcode.cn/problems/palindromic-substrings/</a></p>
<p>1、确定dp数组（dp table）以及下标的含义</p>
<p>布尔类型的dp[i] [j]：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是dp[i] [j]为true，否则为false。</p>
<p>2、确定递推公式</p>
<p>在确定递推公式时，就要分析如下几种情况。</p>
<p>整体上是两种，就是s[i]与s[j]相等，s[i]与s[j]不相等这两种。</p>
<p>当s[i]与s[j]不相等，那没啥好说的了，dp[i] [j]一定是false。</p>
<p>当s[i]与s[j]相等时，这就复杂一些了，有如下三种情况</p>
<ul>
<li>情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串</li>
<li>情况二：下标i 与 j相差为1，例如aa，也是回文子串</li>
<li>情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看dp[i + 1] [j - 1]是否为true。</li>
</ul>
<p>以上三种情况分析完了，那么递归公式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (s[i] == s[j]) &#123;<br>    <span class="hljs-keyword">if</span> (j - i &lt;= <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 情况一 和 情况二</span><br>        result++;<br>        dp[i][j] = <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 情况三</span><br>        result++;<br>        dp[i][j] = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里的result是统计回文子串的数量。</p>
<p>3、确定遍历顺序</p>
<p>如果这矩阵是从上到下，从左到右遍历，那么会用到没有计算过的dp[i + 1] [j - 1]，也就是根据不确定是不是回文的区间[i+1,j-1]，来判断了[i,j]是不是回文，那结果一定是不对的。</p>
<p><strong>所以一定要从下到上，从左到右遍历，这样保证dp[i + 1] [j - 1]都是经过计算的</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;  <span class="hljs-comment">// 注意遍历顺序</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; s.<span class="hljs-built_in">size</span>(); j++) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] == s[j]) &#123;<br>            <span class="hljs-keyword">if</span> (j - i &lt;= <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 情况一 和 情况二</span><br>                result++;<br>                dp[i][j] = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 情况三</span><br>                result++;<br>                dp[i][j] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>整体代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">dp</span>(s.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(s.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">false</span>));<span class="hljs-comment">// 初始化为false</span><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;  <span class="hljs-comment">// 注意遍历顺序</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; s.<span class="hljs-built_in">size</span>(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (s[i] == s[j]) &#123;<br>                    <span class="hljs-keyword">if</span> (j - i &lt;= <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 情况一 和 情况二</span><br>                        result++;<br>                        dp[i][j] = <span class="hljs-literal">true</span>;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 情况三</span><br>                        result++;<br>                        dp[i][j] = <span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="35、最长回文子序列（的长度）"><a href="#35、最长回文子序列（的长度）" class="headerlink" title="35、最长回文子序列（的长度）"></a>35、最长回文子序列（的长度）</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-subsequence/">https://leetcode.cn/problems/longest-palindromic-subsequence/</a></p>
<p>1、确定dp数组（dp table）以及下标的含义</p>
<p>**dp[i] [j]：字符串s在[i, j]范围内最长的回文子序列的长度为dp[i] [j]**。</p>
<p>2、确定递推公式</p>
<p>在判断回文子串的题目中，关键逻辑就是看s[i]与s[j]是否相同。</p>
<p>如果s[i]与s[j]相同，那么dp[i] ] &#x3D; dp[i + 1] [j - 1] + 2;（dp数组的含义代表的是长度，前后加上两个字符，所以是+2）</p>
<p>如果s[i]与s[j]不相同，说明s[i]和s[j]的同时加入 并不能增加[i,j]区间回文子序列的长度，那么分别加入s[i]、s[j]看看哪一个可以组成最长的回文子序列。</p>
<p>加入s[j]的回文子序列长度为dp[i + 1] [j]。–去掉头字符，加上尾字符</p>
<p>加入s[i]的回文子序列长度为dp[i] [j - 1]。–去掉尾字符，加上头字符</p>
<p>那么dp[i] [j]一定是取最大的，即：dp[i] [j] &#x3D; max(dp[i + 1] [j], dp[i] [j - 1]);</p>
<p>3、dp数组初始化</p>
<p>首先要考虑当i 和j 相同的情况，从递推公式：dp[i] [j] &#x3D; dp[i + 1] [ j - 1] + 2; 可以看出 递推公式是计算不到 i 和j相同时候的情况。</p>
<p>所以需要手动初始化一下，当i与j相同，那么dp[i] [j]一定是等于1的，即：一个字符的回文子序列长度就是1。</p>
<p>其他情况dp[i] [j]初始为0就行，这样递推公式：dp[i] [j] &#x3D; max(dp[i + 1] [j], dp[i] [j - 1]); 中dp[i] [j]才不会被初始值覆盖。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(s.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(s.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) dp[i][i] = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<p>4、确定遍历顺序</p>
<p>从递归公式中，可以看出，dp[i] [j] 依赖于 dp[i + 1] [j - 1] ，dp[i + 1] [j] 和 dp[i] [j - 1]，<strong>所以遍历i的时候一定要从下到上遍历，这样才能保证下一行的数据是经过计算的</strong>。j的话，可以正常从左向右遍历</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestPalindromeSubseq</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(s.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(s.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) dp[i][i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; s.<span class="hljs-built_in">size</span>(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (s[i] == s[j]) &#123;<br>                    dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i + <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="回溯算法刷题总结"><a href="#回溯算法刷题总结" class="headerlink" title="回溯算法刷题总结"></a>回溯算法刷题总结</h1><h2 id="1、回溯算法理论基础"><a href="#1、回溯算法理论基础" class="headerlink" title="1、回溯算法理论基础"></a>1、回溯算法理论基础</h2><p>回溯算法也叫回溯搜索法，是一种暴力搜索方式，它是递归的副产品，有递归就会有回溯。</p>
<p>回溯法的性能如何呢，这里要和大家说清楚了，<strong>虽然回溯法很难，很不好理解，但是回溯法并不是什么高效的算法</strong>。</p>
<p><strong>因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案</strong>，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。</p>
<p>那么既然回溯法并不高效为什么还要用它呢？</p>
<p>因为没得选，一些问题能暴力搜出来就不错了，撑死了再剪枝一下，还没有更高效的解法。</p>
<p>回溯法，一般可以解决如下几种问题：</p>
<ul>
<li>组合问题：N个数里面按一定规则找出k个数的集合</li>
<li>切割问题：一个字符串按一定规则有几种切割方式</li>
<li>子集问题：一个N个数的集合里有多少符合条件的子集</li>
<li>排列问题：N个数按一定规则全排列，有几种排列方式</li>
<li>棋盘问题：N皇后，解数独等等</li>
</ul>
<p>回溯算法模板框架如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">void backtracking(参数) &#123;<br>    if (终止条件) &#123;<br>        存放结果;<br>        return;<br>    &#125;<br><br>    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        backtracking(路径，选择列表); // 递归<br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>（1）确定返回值和参数，返回值一般是void，但回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。</p>
<p>（2）确定回溯函数的终止条件</p>
<p>（3）确定单层回溯搜索的逻辑</p>
<h2 id="2、组合问题"><a href="#2、组合问题" class="headerlink" title="2、组合问题"></a>2、组合问题</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combinations/">https://leetcode.cn/problems/combinations/</a></p>
<p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p>
<p>示例: 输入: n &#x3D; 4, k &#x3D; 2 输出: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ]</p>
<p>k&#x3D;2可以通过两层for循环暴力搜索出来，当n&#x3D;100，k&#x3D;50的情况呢？连暴力搜素都无从下手，所以考虑回溯算法。</p>
<p>我们把组合问题抽象成树形结构来理解：</p>
<p><img src="C:\Users\zhangdengsheng\AppData\Roaming\Typora\typora-user-images\image-20240527141917546.png" srcset="/img/loading.gif" lazyload alt="image-20240527141917546"></p>
<p><strong>每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围</strong>。</p>
<p><strong>图中可以发现n相当于树的宽度，k相当于树的深度</strong>。</p>
<p>1、确定返回值以及参数</p>
<p>我们需要定义两个全局变量来收集结果，一个用来收集单层符合条件的结果，一个用来收集最后汇总的结果集合。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result; <span class="hljs-comment">// 存放符合条件结果的集合</span><br>vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 用来存放单层符合条件结果</span><br></code></pre></td></tr></table></figure>

<p>函数里面需要有以下参数：题目要求的n和k，这是必须的两个参数，即在n个数里找n个数的组合。为了确保每次取完一个元素，下一轮就不能在取了，需要一个参数startIndex来控制每一层取的数不会重复。具体实现看代码就明白了。</p>
<p>所以函数的参数及返回值如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> startIndex)</span></span><br></code></pre></td></tr></table></figure>

<p>2、确定回溯的终止条件</p>
<p>数组的大小path跟k相等了，说明找到了一个子集大小为k的组合了，就满足单层终止条件了。此时用result二维数组，把path保存起来，并终止本层递归。</p>
<p>所以终止条件为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() == k) &#123;<span class="hljs-comment">// path数组大小等于题目要求的子集包含的个数</span><br>    result.<span class="hljs-built_in">push_back</span>(path);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>3、单层搜索的过程</p>
<p>回溯法的搜索过程就是一个树型结构的遍历过程，在如下图中，可以看出for循环用来横向遍历，递归的过程是纵向遍历。</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201123195242899.png" srcset="/img/loading.gif" lazyload alt="77.组合1"></p>
<p>for循环每次从startIndex开始遍历，然后用path保存取到的节点i。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt;= n; i++) &#123; <span class="hljs-comment">// 控制树的横向遍历</span><br>    path.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 处理节点</span><br>    <span class="hljs-built_in">backtracking</span>(n, k, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 递归：控制树的纵向遍历，注意下一层搜索要从i+1开始</span><br>    path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯，撤销处理的节点</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看出backtracking（递归函数）通过不断调用自己一直往深处遍历，总会遇到叶子节点，遇到了叶子节点就要返回。</p>
<p>backtracking的下面部分就是回溯的操作了，撤销本次处理的结果。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-comment">// 1、确定参数和返回值</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result; <span class="hljs-comment">// 用来保存最终结果</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 用来保存单一符合条件的结果</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> startIndex)</span></span>&#123;<br><span class="hljs-comment">// 2、确定终止条件（找到结果就保存，返回）</span><br>    <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == k)&#123;<br>        result.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><span class="hljs-comment">// 3、回溯和递归的逻辑</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex;i&lt;=n;i++)&#123; <span class="hljs-comment">// 横向遍历</span><br>        path.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 处理节点</span><br>        <span class="hljs-built_in">backtracking</span>(n,k,i+<span class="hljs-number">1</span>); <span class="hljs-comment">// 递归，此时startIndex要更新，防止重复遍历（纵向遍历）</span><br>        path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯，撤销处理的节点</span><br>    &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-built_in">backtracking</span>(n,k,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>本题可以剪枝优化的，<strong>如果for循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索了</strong>。</p>
<p>注意代码中i，就是for循环里选择的起始位置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt;= n; i++) &#123;<br></code></pre></td></tr></table></figure>

<p>接下来看一下优化过程如下：</p>
<ol>
<li>已经选择的元素个数：path.size();</li>
<li>所需需要的元素个数为: k - path.size();</li>
<li>列表中剩余元素（n-i） &gt;&#x3D; 所需需要的元素个数（k - path.size()）</li>
<li>在集合n中至多要从该起始位置 : i &lt;&#x3D; n - (k - path.size()) + 1，开始遍历</li>
</ol>
<p>为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。</p>
<p>举个例子，n &#x3D; 4，k &#x3D; 3， 目前已经选取的元素为0（path.size为0），n - (k - 0) + 1 即 4 - ( 3 - 0) + 1 &#x3D; 2。</p>
<p>从2开始搜索都是合理的，可以是组合[2, 3, 4]。也就是说后面元素个数都不够凑出你要求的集合个数了，就没必要遍历了。</p>
<p>优化后的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> startIndex)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() == k) &#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt;= n - (k - path.<span class="hljs-built_in">size</span>()) + <span class="hljs-number">1</span>; i++) &#123; <span class="hljs-comment">// 优化的地方</span><br>            path.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 处理节点</span><br>            <span class="hljs-built_in">backtracking</span>(n, k, i + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯，撤销处理的节点</span><br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-built_in">backtracking</span>(n, k, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="3、组合总和"><a href="#3、组合总和" class="headerlink" title="3、组合总和|||"></a>3、组合总和|||</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iii/">https://leetcode.cn/problems/combination-sum-iii/</a></p>
<p>找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p>
<p>说明：</p>
<ul>
<li>所有数字都是正整数。</li>
<li>解集不能包含重复的组合。</li>
</ul>
<p>示例 1: 输入: k &#x3D; 3, n &#x3D; 7 输出: [[1,2,4]]</p>
<p>示例 2: 输入: k &#x3D; 3, n &#x3D; 9 输出: [[1,2,6], [1,3,5], [2,3,4]]</p>
<p>本题与上题相比，控制了组合里总共的元素个数，增加了和为n的条件。k是控制每个子集的元素个数。</p>
<p>1、确定回溯函数的参数（返回值为void）</p>
<p>同上到题目一样，依然需要path和result，分别用来收集满足单层条件的结果以及最后总的结果。</p>
<p>还需要以下参数：</p>
<p>targetSum：满足条件的子集的总和，即题目要求的n。</p>
<p>k：题目要求的子集的元素个数</p>
<p>sum：已经收集的元素的和，即path里的元素之和。</p>
<p>startIndex：下一层循环的起始位置</p>
<p>所以代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>vector&lt;<span class="hljs-type">int</span>&gt; path;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> targetSum, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startIndex)</span></span><br></code></pre></td></tr></table></figure>

<p>2、确定终止条件</p>
<p>当path里收集的元素个数等于题目要求的子集元素个数k，就可以终止搜索了，此时再判断path里元素的总和（sum）是否满足targetSum（即题目要求的n）</p>
<p>终止代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() == k) &#123;<br>    <span class="hljs-keyword">if</span> (sum == targetSum) result.<span class="hljs-built_in">push_back</span>(path);<br>    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 如果path.size() == k 但sum != targetSum 直接返回</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>3、单层搜索过程</p>
<p>组合里元素总数为9，for循环固定i&lt;&#x3D;9;</p>
<p>处理过程就是 path收集每次选取的元素，相当于树型结构里的边，sum来统计path里元素的总和。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt;= <span class="hljs-number">9</span>; i++) &#123;<br>    sum += i;<br>    path.<span class="hljs-built_in">push_back</span>(i);<br>    <span class="hljs-built_in">backtracking</span>(targetSum, k, sum, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 注意i+1调整startIndex</span><br>    sum -= i; <span class="hljs-comment">// 回溯</span><br>    path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>别忘了处理过程 和 回溯过程是一一对应的，处理有加，回溯就要有减！</strong></p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br><span class="hljs-comment">// targetSum:目标和n； k集合中元素个数；sum：已经手机的元素和；startIndex ：下一层for循环搜索的起始位置</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backTracking</span><span class="hljs-params">(<span class="hljs-type">int</span> targetSum,<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> sum,<span class="hljs-type">int</span> startIndex)</span></span>&#123;<span class="hljs-comment">// 1、确定返回值和传入的参数</span><br>    <span class="hljs-comment">// 2、确定终止条件</span><br>    <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == k)&#123;<br>        <span class="hljs-keyword">if</span>(sum == targetSum) result.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 如果path.size() == k，但是sum ！= targetSum，直接返回</span><br>    &#125;<br>    <span class="hljs-comment">// 3、单层处理逻辑</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex;i&lt;=<span class="hljs-number">9</span>;i++)&#123;<span class="hljs-comment">// 横向</span><br>        sum += i;<br>        path.<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-built_in">backTracking</span>(targetSum,k,sum,i+<span class="hljs-number">1</span>); <span class="hljs-comment">// i+1是调整startIndex的 纵向</span><br>        sum -= i;<span class="hljs-comment">// 回溯</span><br>        path.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum3</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-built_in">backTracking</span>(n,k,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>本题也可以考虑剪枝操作：当sum已经大于targetSum了，再往后遍历也找不到满足条件的子集了，所以在回溯函数之前加个判断：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (sum &gt; targetSum) &#123; <span class="hljs-comment">// 剪枝操作</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>同时，关于元素个数的限制，同上一题：for (int i &#x3D; startIndex; i &lt;&#x3D; 9 - (k - path.size()) + 1; i++) { &#x2F;&#x2F; 剪枝</p>
<p>剪枝后的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result; <span class="hljs-comment">// 存放结果集</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 符合单层条件的结果</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> targetSum, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startIndex)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sum &gt; targetSum) &#123; <span class="hljs-comment">// 剪枝操作</span><br>            <span class="hljs-keyword">return</span>; <br>        &#125;<br>        <span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() == k) &#123;<br>            <span class="hljs-keyword">if</span> (sum == targetSum) result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 如果path.size() == k 但sum != targetSum 直接返回</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt;= <span class="hljs-number">9</span> - (k - path.<span class="hljs-built_in">size</span>()) + <span class="hljs-number">1</span>; i++) &#123; <span class="hljs-comment">// 剪枝</span><br>            sum += i; <span class="hljs-comment">// 处理</span><br>            path.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 处理</span><br>            <span class="hljs-built_in">backtracking</span>(targetSum, k, sum, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 注意i+1调整startIndex</span><br>            sum -= i; <span class="hljs-comment">// 回溯</span><br>            path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯</span><br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum3</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n) &#123;<br>        result.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">// 可以不加</span><br>        path.<span class="hljs-built_in">clear</span>();   <span class="hljs-comment">// 可以不加</span><br>        <span class="hljs-built_in">backtracking</span>(n, k, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="4、组合总和"><a href="#4、组合总和" class="headerlink" title="4、组合总和"></a>4、组合总和</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum/">https://leetcode.cn/problems/combination-sum/</a></p>
<p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的数字可以无限制重复被选取。</p>
<p>与上一题相比，本题没有数量要求了，每个元素可以重复选取，但有总和的限制，间接的有了个数的限制。</p>
<p>1、确定递归（回溯）的参数</p>
<p>定义两个全局变量，result用来收集最终结果，path用来收集单层符合条件的结果。</p>
<p>然后题目中给的数组candidates和目标和target，另外需要定义一个sum来收集符合条件的path里的元素的和与target进行比较。本题依然需要startIndex来控制for循环的起始位置。</p>
<p>综上所述：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>vector&lt;<span class="hljs-type">int</span>&gt; path;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startIndex)</span></span><br></code></pre></td></tr></table></figure>

<p>2、递归的终止条件</p>
<p>当sum&#x3D;&#x3D;target的时候，收集结果。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (sum &gt; target) &#123;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (sum == target) &#123;<br>    result.<span class="hljs-built_in">push_back</span>(path);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>3、单层搜索的逻辑</p>
<p>依然是从startIndex开始搜索，但本题的元素可以重复选取，不用控制下一层从i+1开始了，因此在递归的时候传入的startIndex不用再+1了。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; candidates.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    sum += candidates[i];<span class="hljs-comment">//计算path里的元素和</span><br>    path.<span class="hljs-built_in">push_back</span>(candidates[i]);<span class="hljs-comment">//收集元素</span><br>    <span class="hljs-built_in">backtracking</span>(candidates, target, sum, i); <span class="hljs-comment">// 关键点:不用i+1了，表示可以重复读取当前的数</span><br>    sum -= candidates[i];   <span class="hljs-comment">// 回溯，回退到加上元素之前的和</span><br>    path.<span class="hljs-built_in">pop_back</span>();        <span class="hljs-comment">// 回溯，元素出栈</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result; <span class="hljs-comment">// 收集结果</span><br>    vector&lt;<span class="hljs-type">int</span>&gt;path; <span class="hljs-comment">// 单次符合条件的结果</span><br>    <span class="hljs-comment">// 1、确定返回值和参数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target,<span class="hljs-type">int</span> sum,<span class="hljs-type">int</span> startIndex)</span></span>&#123;<br>    <span class="hljs-comment">// 2、确定终止条件</span><br>        <span class="hljs-keyword">if</span>(sum &gt; target)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum == target)&#123;<br>            result.<span class="hljs-built_in">push_back</span>(path); <span class="hljs-comment">// 收集结果</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    <span class="hljs-comment">// 3、单层搜索条件</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i&lt;candidates.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            sum += candidates[i];<br>            path.<span class="hljs-built_in">push_back</span>(candidates[i]);<span class="hljs-comment">//处理节点</span><br>            <span class="hljs-built_in">backtracking</span>(candidates,target,sum,i);<span class="hljs-comment">// 此处i不用加1了，因为元素可以重复</span><br>            sum -= candidates[i];<br>            path.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">// 回溯</span><br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracking</span>(candidates,target,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>5、组合总和||</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-ii/">https://leetcode.cn/problems/combination-sum-ii/</a></p>
<p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的每个数字在每个组合中只能使用一次。</p>
<p>本题同上面一题的区别是，元素只能使用一次了，并且数组中有重复的元素，且解集不能包含重复的组合。</p>
<p>这就涉及到了组合问题的去重操作。</p>
<p>组合问题可以抽象为树形结构，那么“使用过”在这个树形结构上是有两个维度的，一个维度是同一树枝上使用过，一个维度是同一树层上使用过。<strong>没有理解这两个层面上的“使用过” 是造成大家没有彻底理解去重的根本原因。</strong></p>
<p>本题的要求是元素在同一个组合内是可以重复的，怎么重复都没事，但两个组合不能相同。</p>
<p><strong>所以我们要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重</strong>。</p>
<p>1、确定函数参数</p>
<p>其他参数同上题一样，但需要加入一个used数组，来记录同一树枝上元素的使用情况（用过1，没用过0）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result; <span class="hljs-comment">// 存放组合集合</span><br>vector&lt;<span class="hljs-type">int</span>&gt; path;           <span class="hljs-comment">// 符合条件的组合</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startIndex, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used)</span></span><br></code></pre></td></tr></table></figure>

<p>2、确定终止条件</p>
<p>同上题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (sum &gt; target) &#123;<span class="hljs-comment">// 如果有剪枝操作，这里可以省略</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (sum == target) &#123;<br>    result.<span class="hljs-built_in">push_back</span>(path);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>3、单层搜索的逻辑</p>
<p>这里要注重去重的操作，即根据used数组来判断元素是否在同一层使用过，或在同一树枝被使用过。</p>
<p>**如果<code>candidates[i] == candidates[i - 1]</code> 并且 <code>used[i - 1] == false</code>，就说明：前一个树枝，使用了candidates[i - 1]，也就是说同一树层使用过candidates[i - 1]**。此时在同一层上，有两个重复的元素candidates[i] </p>
<p>和candidates[i-1],这里就不能重复选取了，要跳过。</p>
<p>在candidates[i] &#x3D;&#x3D; candidates[i - 1]相同的情况下：</p>
<ul>
<li>used[i - 1] &#x3D;&#x3D; true，说明同一树枝candidates[i - 1]使用过</li>
<li>used[i - 1] &#x3D;&#x3D; false，说明同一树层candidates[i - 1]使用过</li>
</ul>
<p>因此单层搜索的逻辑代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target; i++) &#123;<br>    <span class="hljs-comment">// used[i - 1] == true，说明同一树枝candidates[i - 1]使用过</span><br>    <span class="hljs-comment">// used[i - 1] == false，说明同一树层candidates[i - 1]使用过</span><br>    <span class="hljs-comment">// 要对同一树层使用过的元素进行跳过</span><br>    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>] == <span class="hljs-literal">false</span>) &#123;<br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    sum += candidates[i];<br>    path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>    used[i] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-built_in">backtracking</span>(candidates, target, sum, i + <span class="hljs-number">1</span>, used); <span class="hljs-comment">// 和39.组合总和的区别1：这里是i+1，每个数字在每个组合中只能使用一次</span><br>    used[i] = <span class="hljs-literal">false</span>;<br>    sum -= candidates[i];<br>    path.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>sum + candidates[i] &lt;&#x3D; target为剪枝操作</strong>：即如果下一层的值加上当前总和已经大于目标值了，就没必要继续了。</p>
<p><strong>对总集合排序之后，如果下一层的sum（就是本层的 sum + candidates[i]）已经大于target，就可以结束本轮for循环的遍历</strong>。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startIndex, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sum == target) &#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target; i++) &#123;<br>            <span class="hljs-comment">// used[i - 1] == true，说明同一树枝candidates[i - 1]使用过</span><br>            <span class="hljs-comment">// used[i - 1] == false，说明同一树层candidates[i - 1]使用过</span><br>            <span class="hljs-comment">// 要对同一树层使用过的元素进行跳过</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>] == <span class="hljs-literal">false</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            sum += candidates[i];<br>            path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            used[i] = <span class="hljs-literal">true</span>;<span class="hljs-comment">//标记used数组</span><br>            <span class="hljs-built_in">backtracking</span>(candidates, target, sum, i + <span class="hljs-number">1</span>, used); <span class="hljs-comment">// 和组合总和的区别1，这里是i+1，每个数字在每个组合中只能使用一次</span><br>            used[i] = <span class="hljs-literal">false</span>;<span class="hljs-comment">//回溯，这里说明当uesd[i-1]=fales,其实是进行回溯，所以同一层有使用过。</span><br>            sum -= candidates[i];<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum2</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(candidates.size(), <span class="hljs-literal">false</span>)</span></span>;<br>        path.<span class="hljs-built_in">clear</span>();<br>        result.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-comment">// 首先把给candidates排序，让其相同的元素都挨在一起。</span><br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(), candidates.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">backtracking</span>(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, used);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>注意：去重操作需要对数组进行排序！</p>
<h2 id="5、分割回文串"><a href="#5、分割回文串" class="headerlink" title="5、分割回文串"></a>5、分割回文串</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-partitioning/">https://leetcode.cn/problems/palindrome-partitioning/</a></p>
<p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。</p>
<p>返回 s 所有可能的分割方案。</p>
<p>示例: 输入: “aab” 输出: [ [“aa”,”b”], [“a”,”a”,”b”] ]</p>
<p>切割问题类似于组合问题，</p>
<ul>
<li>组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中再选取第三个…..。</li>
<li>切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中再切割第三段…..。</li>
</ul>
<p>所以也可以用组合问题的思路来解决分割子串的问题，抽象成树形结构。</p>
<p>1、确定递归函数的参数</p>
<p>记录结果的result，收集单层切割结果的path，以及控制元素不重复的startIndex。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;string&gt;&gt; result;<br>vector&lt;string&gt; path; <span class="hljs-comment">// 放已经回文的子串</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> startIndex)</span></span><br></code></pre></td></tr></table></figure>

<p>2、确定终止条件</p>
<p>切割线切到子串的最后位置，切割完毕，startIndex就代表这条切割线。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> startIndex)</span> </span>&#123;<br>    <span class="hljs-comment">// 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了</span><br>    <span class="hljs-keyword">if</span> (startIndex &gt;= s.<span class="hljs-built_in">size</span>()) &#123;<br>        result.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>3、单层搜索逻辑</p>
<p>在<code>for (int i = startIndex; i &lt; s.size(); i++)</code>循环中，我们 定义了起始位置startIndex，那么 [startIndex, i] 就是要截取的子串，只要判断子串s[startIndex,i]是不是回文串，如果是，加入到单层结果中，不是则跳过。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPalindrome</span>(s, startIndex, i)) &#123; <span class="hljs-comment">// 是回文子串</span><br>        <span class="hljs-comment">// 获取[startIndex,i]在s中的子串</span><br>        string str = s.<span class="hljs-built_in">substr</span>(startIndex, i - startIndex + <span class="hljs-number">1</span>);<br>        path.<span class="hljs-built_in">push_back</span>(str);<br>    &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 如果不是则直接跳过</span><br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-built_in">backtracking</span>(s, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 寻找i+1为起始位置的子串，因为切割过得元素（位置）不能重复切割。</span><br>    path.<span class="hljs-built_in">pop_back</span>();        <span class="hljs-comment">// 回溯过程，弹出本次已经添加的子串</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>那么如何判断是否为回文子串呢，可以使用双指针法，一个指针从前向后，一个指针从后向前，如果前后指针所指向的元素是相等的，就是回文字符串了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start, j = end; i &lt; j; i++, j--) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] != s[j]) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;string&gt;&gt; result;<br>    vector&lt;string&gt; path; <span class="hljs-comment">// 放已经回文的子串</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> startIndex)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了</span><br>        <span class="hljs-keyword">if</span> (startIndex &gt;= s.<span class="hljs-built_in">size</span>()) &#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPalindrome</span>(s, startIndex, i)) &#123;   <span class="hljs-comment">// 是回文子串</span><br>                <span class="hljs-comment">// 获取[startIndex,i]在s中的子串</span><br>                string str = s.<span class="hljs-built_in">substr</span>(startIndex, i - startIndex + <span class="hljs-number">1</span>);<br>                path.<span class="hljs-built_in">push_back</span>(str);<br>            &#125; <span class="hljs-keyword">else</span> &#123;                                <span class="hljs-comment">// 不是回文，跳过</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-built_in">backtracking</span>(s, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 寻找i+1为起始位置的子串</span><br>            path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯过程，弹出本次已经添加的子串</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start, j = end; i &lt; j; i++, j--) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] != s[j]) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">partition</span>(string s) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracking</span>(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="6、复原IP地址（难）"><a href="#6、复原IP地址（难）" class="headerlink" title="6、复原IP地址（难）"></a>6、复原IP地址（难）</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/restore-ip-addresses/">https://leetcode.cn/problems/restore-ip-addresses/</a></p>
<p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p>
<p>有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p>
<p>例如：”0.1.2.201” 和 “192.168.1.1” 是 有效的 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “<a href="mailto:&#49;&#57;&#x32;&#x2e;&#49;&#x36;&#x38;&#64;&#x31;&#46;&#x31;">&#49;&#57;&#x32;&#x2e;&#49;&#x36;&#x38;&#64;&#x31;&#46;&#x31;</a>“ 是 无效的 IP 地址。</p>
<p>经过上一题可以知道，分割字符串可以抽象成树形结构，进行切割。那切割问题就可以考虑回溯算法把所有可能性搜索出来。</p>
<p><img src="C:\Users\zhangdengsheng\AppData\Roaming\Typora\typora-user-images\image-20240529151310928.png" srcset="/img/loading.gif" lazyload alt="image-20240529151310928"></p>
<p>1、确定递归函数的参数</p>
<p>result用来记录结果，startIndex用来控制下次递归的元素起始位置，保证不重复，还需要一个pointNum来统计逗号的个数，因为一个IP地址有三个逗号代表切割完毕了。</p>
<p>因此，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;string&gt; result;<span class="hljs-comment">// 记录结果</span><br><span class="hljs-comment">// startIndex: 搜索的起始位置，pointNum:添加逗点的数量</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(string&amp; s, <span class="hljs-type">int</span> startIndex, <span class="hljs-type">int</span> pointNum)</span> </span><br></code></pre></td></tr></table></figure>

<p>2、确定终止条件</p>
<p>pointNum表示逗点数量，IP地址分成四段，当pointNum等于3的时候，代表切割完成了。判断第四段的字符是否合法，如果合法就加入结果集。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (pointNum == <span class="hljs-number">3</span>) &#123; <span class="hljs-comment">// 逗点数量为3时，分隔结束</span><br>    <span class="hljs-comment">// 判断第四段子字符串是否合法，如果合法就放进result中</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isValid</span>(s, startIndex, s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)) &#123;<br>        result.<span class="hljs-built_in">push_back</span>(s);<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>3、单层搜索的逻辑</p>
<p>首先要判断每一段切割的字符是否合法，那么被切割下来的字符怎么表示？即[startIndex,i]这个区间就是截取的子串，如果这个子串合法，就加上逗点，表示已经分割。不合法就退出本层循环。递归调用时，下一层递归的startIndex要从i+2开始（因为需要在字符串中加入了分隔符<code>.</code>），同时记录分割符的数量pointNum 要 +1。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isValid</span>(s, startIndex, i)) &#123; <span class="hljs-comment">// 判断 [startIndex,i] 这个区间的子串是否合法</span><br>        s.<span class="hljs-built_in">insert</span>(s.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span> , <span class="hljs-string">&#x27;.&#x27;</span>);  <span class="hljs-comment">// 在i的后面插入一个逗点</span><br>        pointNum++;<br>        <span class="hljs-built_in">backtracking</span>(s, i + <span class="hljs-number">2</span>, pointNum);   <span class="hljs-comment">// 插入逗点之后下一个子串的起始位置为i+2</span><br>        pointNum--;                         <span class="hljs-comment">// 回溯</span><br>        s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span>);         <span class="hljs-comment">// 回溯删掉逗点</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 不合法，直接结束本层循环</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>如何判断切割的字符是否合法？主要考虑到如下三点：</p>
<ul>
<li>段位以0为开头的数字不合法</li>
<li>段位里有非正整数字符不合法</li>
<li>段位如果大于255了不合法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 判断字符串s在左闭又闭区间[start, end]所组成的数字是否合法</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (start &gt; end) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (s[start] == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; start != end) &#123; <span class="hljs-comment">// 0开头的数字不合法</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt;= end; i++) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] &gt; <span class="hljs-string">&#x27;9&#x27;</span> || s[i] &lt; <span class="hljs-string">&#x27;0&#x27;</span>) &#123; <span class="hljs-comment">// 遇到非数字字符不合法</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        num = num * <span class="hljs-number">10</span> + (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>        <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">255</span>) &#123; <span class="hljs-comment">// 如果大于255了不合法</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="7、子集问题"><a href="#7、子集问题" class="headerlink" title="7、子集问题"></a>7、子集问题</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/">https://leetcode.cn/problems/subsets/</a></p>
<p>给定一组<strong>不含重复元素</strong>的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>
<p>说明：解集不能包含重复的子集。</p>
<p>示例: 输入: nums &#x3D; [1,2,3] 输出: [ [3],  [1],  [2],  [1,2,3],  [1,3],  [2,3],  [1,2],  [] ]</p>
<p>本题求得是组合数，元素不能重复选，所以还是需要startIndex来控制搜索的起始位置。求的是所有可能得子集，如果抽象成一个树形结构，之前的题目是收集叶子结点，而本题相当与<strong>收集树的所有节点</strong>。</p>
<p>1、确定递归函数的参数</p>
<p>收集单层结果的path，收集最终结果的result，控制搜索起始位置的startIndex</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>vector&lt;<span class="hljs-type">int</span>&gt; path;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> startIndex)</span></span><br></code></pre></td></tr></table></figure>

<p>2、确定单层递归逻辑</p>
<p>剩余集合为空的时候就可以退出了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (startIndex &gt;= nums.<span class="hljs-built_in">size</span>()) &#123;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>其实可以不需要加终止条件，因为startIndex &gt;&#x3D; nums.size()，本层for循环本来也结束了</strong>。</p>
<p>3、单层递归的逻辑</p>
<p>求子集问题，不需要剪枝操作，就是收集所有的节点就可以了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    path.<span class="hljs-built_in">push_back</span>(nums[i]);    <span class="hljs-comment">// 子集收集元素</span><br>    <span class="hljs-built_in">backtracking</span>(nums, i + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 注意从i+1开始，元素不重复取</span><br>    path.<span class="hljs-built_in">pop_back</span>();            <span class="hljs-comment">// 回溯</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>那result什么时候收集呢？在递归的一开始就收集path的结果，防止漏掉结果</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> startIndex)</span> </span>&#123;<br>        result.<span class="hljs-built_in">push_back</span>(path); <span class="hljs-comment">// 收集子集，要放在终止添加的上面，否则会漏掉自己</span><br>        <span class="hljs-keyword">if</span> (startIndex &gt;= nums.<span class="hljs-built_in">size</span>()) &#123; <span class="hljs-comment">// 终止条件可以不加</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<span class="hljs-comment">//收集路径</span><br>            <span class="hljs-built_in">backtracking</span>(nums, i + <span class="hljs-number">1</span>);<span class="hljs-comment">// 递归，i+1开始，避免重复</span><br>            path.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//回溯</span><br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracking</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="8、子集问题"><a href="#8、子集问题" class="headerlink" title="8、子集问题||"></a>8、子集问题||</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets-ii/">https://leetcode.cn/problems/subsets-ii/</a></p>
<p>给定一个可能<strong>包含重复元素</strong>的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>
<p>说明：解集不能包含重复的子集。</p>
<p>本题数组里<strong>有重复元素</strong>并且要求子集不重复，也就是要考虑去重的逻辑了。即树枝去重还是树层去重。</p>
<p>注意去重之前要对数组进行排序！</p>
<p><img src="C:\Users\zhangdengsheng\AppData\Roaming\Typora\typora-user-images\image-20240530134545898.png" srcset="/img/loading.gif" lazyload alt="image-20240530134545898"></p>
<p>求子集就是收集所有节点，同时加上去重操作。本题是树层去重</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">used[i - 1] == true，说明同一树枝candidates[i - 1]使用过<br>used[i - 1] == false，说明同一树层candidates[i - 1]使用过<br></code></pre></td></tr></table></figure>

<p>跟上一题代码相比，只需要加上去重操作即可，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> startIndex, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used)</span> </span>&#123;<br>        result.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-comment">// used[i - 1] == true，说明同一树枝candidates[i - 1]使用过</span><br>            <span class="hljs-comment">// used[i - 1] == false，说明同一树层candidates[i - 1]使用过</span><br>            <span class="hljs-comment">// 而我们要对同一树层使用过的元素进行跳过</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>] == <span class="hljs-literal">false</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            used[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">backtracking</span>(nums, i + <span class="hljs-number">1</span>, used);<br>            used[i] = <span class="hljs-literal">false</span>;<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsetsWithDup</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(nums.size(), <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 去重需要排序</span><br>        <span class="hljs-built_in">backtracking</span>(nums, <span class="hljs-number">0</span>, used);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="9、递增子序列（坑）"><a href="#9、递增子序列（坑）" class="headerlink" title="9、递增子序列（坑）"></a>9、递增子序列（坑）</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/non-decreasing-subsequences/">https://leetcode.cn/problems/non-decreasing-subsequences/</a></p>
<p>给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。</p>
<p>示例:</p>
<ul>
<li>输入: [4, 6, 7, 7]</li>
<li>输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]</li>
</ul>
<p>在子集问题中，我们通过对数组进行排序以及一个used数组标记元素使用与否来去重，达到收集所有节点的目的。</p>
<p>但本题求自增子序列，你就不能先对数组进行排序了，那样就改变题目给出的数组顺序，就没有意义了。</p>
<p>1、确定递归函数参数</p>
<p>本题求子序列，很明显一个元素不能重复使用，所以需要startIndex，调整下一层递归的起始位置。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>vector&lt;<span class="hljs-type">int</span>&gt; path;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> startIndex)</span></span><br></code></pre></td></tr></table></figure>

<p>2、终止条件</p>
<p>本题其实类似求子集问题，也是要遍历树形结构找每一个节点，所以和子集问题一样，可以不加终止条件，startIndex每次都会加1，并不会无限递归。</p>
<p>但本题收集结果有所不同，题目要求递增子序列大小至少为2，所以代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) &#123;<br>    result.<span class="hljs-built_in">push_back</span>(path);<br>    <span class="hljs-comment">// 注意这里不要加return，因为要取树上的所有节点</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>3、单层搜索的逻辑</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">unordered_set&lt;<span class="hljs-type">int</span>&gt; uset; <span class="hljs-comment">// 使用set来对本层元素进行去重</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    <span class="hljs-keyword">if</span> ((!path.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i] &lt; path.<span class="hljs-built_in">back</span>())<br>            || uset.<span class="hljs-built_in">find</span>(nums[i]) != uset.<span class="hljs-built_in">end</span>()) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    uset.<span class="hljs-built_in">insert</span>(nums[i]); <span class="hljs-comment">// 记录这个元素在本层用过了，本层后面不能再用了</span><br>    path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>    <span class="hljs-built_in">backtracking</span>(nums, i + <span class="hljs-number">1</span>);<br>    path.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里使用set来记录每一层递归时，本层使用过哪些元素，对于已经使用过的就跳出搜索。 uset.find(nums[i]) !&#x3D; uset.end()表示在set里搜索到了跟nums[i]相同的元素，所以终止本层for循环<strong>。因为找不到才会返回uset.end()。</strong></p>
<p>这里数值范围较小的话，可用数组替换set，因为程序运行的时候对unordered_set 频繁的insert，unordered_set需要做哈希映射（也就是把key通过hash function映射为唯一的哈希值）相对费时间，而且每次重新定义set，insert的时候其底层的符号表也要做相应的扩充，也是费事的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> used[<span class="hljs-number">201</span>] = &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 这里使用数组来进行去重操作，题目说数值范围[-100, 100]</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    <span class="hljs-keyword">if</span> ((!path.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i] &lt; path.<span class="hljs-built_in">back</span>())<br>            || used[nums[i] + <span class="hljs-number">100</span>] == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    used[nums[i] + <span class="hljs-number">100</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 记录这个元素在本层用过了，本层后面不能再用了</span><br>    path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>    <span class="hljs-built_in">backtracking</span>(nums, i + <span class="hljs-number">1</span>);<br>    path.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp">lass Solution &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> startIndex)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">// 元素个数至少为2个</span><br>            result.<span class="hljs-built_in">push_back</span>(path);<br>        &#125;<br>        <span class="hljs-type">int</span> used[<span class="hljs-number">201</span>] = &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 这里使用数组来进行去重操作，题目说数值范围[-100, 100]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> ((!path.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i] &lt; path.<span class="hljs-built_in">back</span>())<br>                    || used[nums[i] + <span class="hljs-number">100</span>] == <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">// 检查是否同一树层有重复元素</span><br>                    <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            used[nums[i] + <span class="hljs-number">100</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 记录这个元素在本层用过了，本层后面不能再用了</span><br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtracking</span>(nums, i + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">findSubsequences</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracking</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="10、全排列"><a href="#10、全排列" class="headerlink" title="10、全排列"></a>10、全排列</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/">https://leetcode.cn/problems/permutations/</a></p>
<p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p>
<p>示例:</p>
<ul>
<li><p>输入: [1,2,3]</p>
</li>
<li><p>输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ]</p>
</li>
</ul>
<p>排列问题与组合问题的区别在于，元素能否重复使用，此处不需要startIndex来控制元素的起始位置了。</p>
<p>1、确定递归函数的参数</p>
<p>收集单层结果的path，收集最终结果的result，还需要一个used数组来标记已经选中的元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>vector&lt;<span class="hljs-type">int</span>&gt; path;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used)</span></span><br></code></pre></td></tr></table></figure>

<p>2、确定终止条件</p>
<p>当path里的元素个数等于数组nums的大小时，说明到了叶子结点，可以收集结果了。</p>
<p>3、单层搜索的逻辑</p>
<p>排列问题，每次都要从头搜索，所以不需要startIndex，但需要used数组来标记哪些元素已经被选取了，在一个排列里，一个元素只能使用一次。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    <span class="hljs-keyword">if</span> (used[i] == <span class="hljs-literal">true</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// path里已经收录的元素，直接跳过</span><br>    used[i] = <span class="hljs-literal">true</span>;<br>    path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>    <span class="hljs-built_in">backtracking</span>(nums, used);<br>    path.<span class="hljs-built_in">pop_back</span>();<br>    used[i] = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-comment">// 1、确定参数和返回值，每次搜索，从头遍历，元素需要重复使用，所以不需要startIndex</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,vector&lt;<span class="hljs-type">bool</span>&gt;&amp;used)</span></span>&#123; <span class="hljs-comment">// used数组用来记录哪个元素被使用了</span><br>    <span class="hljs-comment">// 2、确定终止条件</span><br>    <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-comment">//找到了一组</span><br>        result.<span class="hljs-built_in">push_back</span>(path); <span class="hljs-comment">// 收集结果</span><br>    &#125;<br>    <span class="hljs-comment">// 3、单层递归逻辑</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-keyword">if</span>(used[i]==<span class="hljs-literal">true</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 表示该元素已经使用过，跳过，在一个排列里元素不能重复选取</span><br>        used[i] = <span class="hljs-literal">true</span>;<span class="hljs-comment">//标记当前元素已被使用</span><br>        path.<span class="hljs-built_in">push_back</span>(nums[i]);<span class="hljs-comment">// 收集</span><br>        <span class="hljs-built_in">backtracking</span>(nums,used);<br>        path.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">// 回溯</span><br>        used[i] =<span class="hljs-literal">false</span>;<span class="hljs-comment">//回溯</span><br>    &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>    result.<span class="hljs-built_in">clear</span>();<br>    path.<span class="hljs-built_in">clear</span>();<br>    vector&lt;<span class="hljs-type">bool</span>&gt;<span class="hljs-built_in">used</span>(nums.<span class="hljs-built_in">size</span>(),<span class="hljs-literal">false</span>);<br>    <span class="hljs-built_in">backtracking</span>(nums,used);<br>    <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="11、全排列"><a href="#11、全排列" class="headerlink" title="11、全排列|||"></a>11、全排列|||</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations-ii/">https://leetcode.cn/problems/permutations-ii/</a></p>
<p>给定一个可<strong>包含重复数字</strong>的序列 nums ，按任意顺序 返回所有<strong>不重复的全排列</strong>。</p>
<p>示例 1：</p>
<ul>
<li>输入：nums &#x3D; [1,1,2]</li>
<li>输出： [[1,1,2], [1,2,1], [2,1,1]]</li>
</ul>
<p>题目要求数组中有重复元素、但排列不许重复，就涉及到了去重操作。树层去重</p>
<p>本题实质上就是对上题在树层上进行去重，</p>
<p>used[i-1] &#x3D; false;说明同一树层上有元素使用过</p>
<p>used[i-1] &#x3D; true；说明同一树枝上有元素使用。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used)</span> </span>&#123;<span class="hljs-comment">//1、确定参数和返回值</span><br>        <span class="hljs-comment">// 此时说明找到了一组结果</span><br>        <span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>()) &#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<span class="hljs-comment">// 2、确定终止条件</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<span class="hljs-comment">// 3、单层搜索逻辑</span><br>            <span class="hljs-comment">// used[i - 1] == true，说明同一树枝nums[i - 1]使用过</span><br>            <span class="hljs-comment">// used[i - 1] == false，说明同一树层nums[i - 1]使用过</span><br>            <span class="hljs-comment">// 如果同一树层nums[i - 1]使用过则直接跳过，树层去重</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>] == <span class="hljs-literal">false</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (used[i] == <span class="hljs-literal">false</span>) &#123;<span class="hljs-comment">// 同一个排列不能重复使用同一个元素</span><br>                used[i] = <span class="hljs-literal">true</span>;<br>                path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                <span class="hljs-built_in">backtracking</span>(nums, used);<br>                path.<span class="hljs-built_in">pop_back</span>();<br>                used[i] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permuteUnique</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 排序</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(nums.size(), <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">backtracking</span>(nums, used);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 时间复杂度: 最差情况所有元素都是唯一的。复杂度和全排列1都是 O(n! * n) 对于 n 个元素一共有 n! 中排列方案。而对于每一个答案，我们需要 O(n) 去复制最终放到 result 数组</span><br><span class="hljs-comment">// 空间复杂度: O(n) 回溯树的深度取决于我们有多少个元素</span><br></code></pre></td></tr></table></figure>

<h2 id="12、N皇后"><a href="#12、N皇后" class="headerlink" title="12、N皇后"></a>12、N皇后</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-queens/">https://leetcode.cn/problems/n-queens/</a></p>
<p> 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p>
<p>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>
<p>首先来看一下皇后们的约束条件：</p>
<ol>
<li>不能同行</li>
<li>不能同列</li>
<li>不能同斜线</li>
</ol>
<p>1、确定递归函数的参数</p>
<p>定义全局变量二维数组result来记录最终结果。</p>
<p>参数n是棋盘的大小，然后用row来记录当前遍历到棋盘的第几层：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;string&gt;&gt; result;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> row, vector&lt;string&gt;&amp; chessboard)</span></span><br></code></pre></td></tr></table></figure>

<p>2、递归终止条件</p>
<p>二维矩阵中矩阵的高就是这棵树的高度，矩阵的宽就是树形结构中每一个节点的宽度。</p>
<p>那么我们用皇后们的约束条件，来回溯搜索这棵树，<strong>只要搜索到了树的叶子节点，说明就找到了皇后们的合理位置了</strong>。即棋盘的层数row和棋盘高度n一致，即到了叶子结点：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (row == n) &#123;<br>    result.<span class="hljs-built_in">push_back</span>(chessboard);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>3、单层搜索的逻辑</p>
<p>递归深度就是row控制棋盘的行，每一层里for循环的col控制棋盘的列，一行一列，确定了放置皇后的位置。</p>
<p>每次都是要从新的一行的起始位置开始搜，所以都是从0开始。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> col = <span class="hljs-number">0</span>; col &lt; n; col++) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isValid</span>(row, col, chessboard, n)) &#123; <span class="hljs-comment">// 验证合法就可以放</span><br>        chessboard[row][col] = <span class="hljs-string">&#x27;Q&#x27;</span>; <span class="hljs-comment">// 放置皇后</span><br>        <span class="hljs-built_in">backtracking</span>(n, row + <span class="hljs-number">1</span>, chessboard);<br>        chessboard[row][col] = <span class="hljs-string">&#x27;.&#x27;</span>; <span class="hljs-comment">// 回溯，撤销皇后</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>验证棋盘是否合法</li>
</ul>
<p>按照如下标准去重：</p>
<ol>
<li>不能同行</li>
<li>不能同列</li>
<li>不能同斜线 （45度和135度角）</li>
</ol>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, vector&lt;string&gt;&amp; chessboard, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">// 检查列</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) &#123; <span class="hljs-comment">// 这是一个剪枝</span><br>        <span class="hljs-keyword">if</span> (chessboard[i][col] == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 检查 45度角是否有皇后</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = row - <span class="hljs-number">1</span>, j = col - <span class="hljs-number">1</span>; i &gt;=<span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>; i--, j--) &#123;<br>        <span class="hljs-keyword">if</span> (chessboard[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 检查 135度角是否有皇后</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = row - <span class="hljs-number">1</span>, j = col + <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;<br>        <span class="hljs-keyword">if</span> (chessboard[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最终代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>vector&lt;vector&lt;string&gt;&gt; result;<br><span class="hljs-comment">// n 为输入的棋盘大小</span><br><span class="hljs-comment">// row 是当前递归到棋盘的第几行了</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> row, vector&lt;string&gt;&amp; chessboard)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (row == n) &#123;<br>        result.<span class="hljs-built_in">push_back</span>(chessboard);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> col = <span class="hljs-number">0</span>; col &lt; n; col++) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isValid</span>(row, col, chessboard, n)) &#123; <span class="hljs-comment">// 验证合法就可以放</span><br>            chessboard[row][col] = <span class="hljs-string">&#x27;Q&#x27;</span>; <span class="hljs-comment">// 放置皇后</span><br>            <span class="hljs-built_in">backtracking</span>(n, row + <span class="hljs-number">1</span>, chessboard);<br>            chessboard[row][col] = <span class="hljs-string">&#x27;.&#x27;</span>; <span class="hljs-comment">// 回溯，撤销皇后</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, vector&lt;string&gt;&amp; chessboard, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">// 检查列</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) &#123; <span class="hljs-comment">// 这是一个剪枝</span><br>        <span class="hljs-keyword">if</span> (chessboard[i][col] == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 检查 45度角是否有皇后</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = row - <span class="hljs-number">1</span>, j = col - <span class="hljs-number">1</span>; i &gt;=<span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>; i--, j--) &#123;<br>        <span class="hljs-keyword">if</span> (chessboard[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 检查 135度角是否有皇后</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = row - <span class="hljs-number">1</span>, j = col + <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;<br>        <span class="hljs-keyword">if</span> (chessboard[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-type">int</span> n) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-function">std::vector&lt;std::string&gt; <span class="hljs-title">chessboard</span><span class="hljs-params">(n, std::string(n, <span class="hljs-string">&#x27;.&#x27;</span>))</span></span>;<br>        <span class="hljs-built_in">backtracking</span>(n, <span class="hljs-number">0</span>, chessboard);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="13、解数独"><a href="#13、解数独" class="headerlink" title="13、解数独"></a>13、解数独</h2><p>1、确定递归函数参数以及返回值</p>
<p><strong>递归函数的返回值需要是bool类型，为什么呢？</strong></p>
<p>因为解数独找到一个符合的条件（就在树的叶子节点上）立刻就返回，相当于找从根节点到叶子节点一条唯一路径，所以需要使用bool返回值。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span></span><br></code></pre></td></tr></table></figure>

<p>2、递归终止条件</p>
<p>本题递归不用终止条件，解数独是要遍历整个树形结构寻找可能的叶子节点就立刻返回。</p>
<p>3、单层搜索逻辑</p>
<p>在树形图中可以看出我们需要的是一个二维的递归 （一行一列）</p>
<p><strong>一个for循环遍历棋盘的行，一个for循环遍历棋盘的列，一行一列确定下来之后，递归遍历这个位置放9个数字的可能性！</strong></p>
<p>代码如下：（<strong>详细看注释</strong>）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; board.<span class="hljs-built_in">size</span>(); i++) &#123;        <span class="hljs-comment">// 遍历行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); j++) &#123; <span class="hljs-comment">// 遍历列</span><br>            <span class="hljs-keyword">if</span> (board[i][j] != <span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> k = <span class="hljs-string">&#x27;1&#x27;</span>; k &lt;= <span class="hljs-string">&#x27;9&#x27;</span>; k++) &#123;     <span class="hljs-comment">// (i, j) 这个位置放k是否合适</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isValid</span>(i, j, k, board)) &#123;<br>                    board[i][j] = k;                <span class="hljs-comment">// 放置k</span><br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">backtracking</span>(board)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 如果找到合适一组立刻返回</span><br>                    board[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>;              <span class="hljs-comment">// 回溯，撤销k</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                           <span class="hljs-comment">// 9个数都试完了，都不行，那么就返回false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 遍历完没有返回false，说明找到了合适棋盘位置了</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>注意这里return false的地方，这里放return false 是有讲究的</strong>。</p>
<p>因为如果一行一列确定下来了，这里尝试了9个数都不行，说明这个棋盘找不到解决数独问题的解！</p>
<p>那么会直接返回， <strong>这也就是为什么没有终止条件也不会永远填不满棋盘而无限递归下去！</strong></p>
<p>判断棋盘是否合法有如下三个维度：</p>
<ul>
<li>同行是否重复</li>
<li>同列是否重复</li>
<li>9宫格里是否重复</li>
</ul>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">char</span> val, vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123; <span class="hljs-comment">// 判断行里是否重复</span><br>        <span class="hljs-keyword">if</span> (board[row][i] == val) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++) &#123; <span class="hljs-comment">// 判断列里是否重复</span><br>        <span class="hljs-keyword">if</span> (board[j][col] == val) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> startRow = (row / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> startCol = (col / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startRow; i &lt; startRow + <span class="hljs-number">3</span>; i++) &#123; <span class="hljs-comment">// 判断9方格里是否重复</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = startCol; j &lt; startCol + <span class="hljs-number">3</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (board[i][j] == val ) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后整体C++代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; board.<span class="hljs-built_in">size</span>(); i++) &#123;        <span class="hljs-comment">// 遍历行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); j++) &#123; <span class="hljs-comment">// 遍历列</span><br>            <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> k = <span class="hljs-string">&#x27;1&#x27;</span>; k &lt;= <span class="hljs-string">&#x27;9&#x27;</span>; k++) &#123;     <span class="hljs-comment">// (i, j) 这个位置放k是否合适</span><br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isValid</span>(i, j, k, board)) &#123;<br>                        board[i][j] = k;                <span class="hljs-comment">// 放置k</span><br>                        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">backtracking</span>(board)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 如果找到合适一组立刻返回</span><br>                        board[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>;              <span class="hljs-comment">// 回溯，撤销k</span><br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 9个数都试完了，都不行，那么就返回false</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 遍历完没有返回false，说明找到了合适棋盘位置了</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">char</span> val, vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123; <span class="hljs-comment">// 判断行里是否重复</span><br>        <span class="hljs-keyword">if</span> (board[row][i] == val) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++) &#123; <span class="hljs-comment">// 判断列里是否重复</span><br>        <span class="hljs-keyword">if</span> (board[j][col] == val) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> startRow = (row / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> startCol = (col / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startRow; i &lt; startRow + <span class="hljs-number">3</span>; i++) &#123; <span class="hljs-comment">// 判断9方格里是否重复</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = startCol; j &lt; startCol + <span class="hljs-number">3</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (board[i][j] == val ) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-built_in">backtracking</span>(board);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="二叉树刷题总结"><a href="#二叉树刷题总结" class="headerlink" title="二叉树刷题总结"></a>二叉树刷题总结</h1><h2 id="1、二叉树的递归遍历"><a href="#1、二叉树的递归遍历" class="headerlink" title="1、二叉树的递归遍历"></a>1、二叉树的递归遍历</h2><p>以前序遍历为例：</p>
<p>1、确定递归函数的参数和返回值</p>
<p>因为要打印出前序遍历节点的数值，所以参数里需要传入vector来放节点的数值，除了这一点就不需要再处理什么数据了也不需要有返回值，所以递归函数返回类型就是void，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span></span><br></code></pre></td></tr></table></figure>

<p>2、确定终止条件</p>
<p>在递归的过程中，如何算是递归结束了呢，当然是当前遍历的节点是空了，那么本层递归就要结束了，所以如果当前遍历的这个节点是空，就直接return，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br></code></pre></td></tr></table></figure>

<p>3、确定单层递归逻辑</p>
<p>前序遍历是中左右的循序，所以在单层递归的逻辑，是要先取中节点的数值，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);    <span class="hljs-comment">// 中</span><br><span class="hljs-built_in">traversal</span>(cur-&gt;left, vec);  <span class="hljs-comment">// 左</span><br><span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <span class="hljs-comment">// 右</span><br></code></pre></td></tr></table></figure>

<p>总上：前序遍历的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>        vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);    <span class="hljs-comment">// 中</span><br>        <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec);  <span class="hljs-comment">// 左</span><br>        <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <span class="hljs-comment">// 右</span><br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-built_in">traversal</span>(root, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>同理可以写出中序和后序遍历的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec);  <span class="hljs-comment">// 左</span><br>    vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);    <span class="hljs-comment">// 中</span><br>    <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <span class="hljs-comment">// 右</span><br>&#125;<span class="hljs-comment">// 中序</span><br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec);  <span class="hljs-comment">// 左</span><br>    <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <span class="hljs-comment">// 右</span><br>    vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);    <span class="hljs-comment">// 中</span><br>&#125;<span class="hljs-comment">// 后序</span><br></code></pre></td></tr></table></figure>

<h2 id="2、二叉树的统一迭代法"><a href="#2、二叉树的统一迭代法" class="headerlink" title="2、二叉树的统一迭代法"></a>2、二叉树的统一迭代法</h2><p>以中序遍历为例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        stack&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">NULL</span>) &#123;<br>                st.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span><br>                <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);  <span class="hljs-comment">// 添加右节点（空节点不入栈）</span><br><br>                st.<span class="hljs-built_in">push</span>(node);                          <span class="hljs-comment">// 添加中节点</span><br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span><br><br>                <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);    <span class="hljs-comment">// 添加左节点（空节点不入栈）</span><br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span><br>                st.<span class="hljs-built_in">pop</span>();           <span class="hljs-comment">// 将空节点弹出</span><br>                node = st.<span class="hljs-built_in">top</span>();    <span class="hljs-comment">// 重新取出栈中元素</span><br>                st.<span class="hljs-built_in">pop</span>();<br>                result.<span class="hljs-built_in">push_back</span>(node-&gt;val); <span class="hljs-comment">// 加入到结果集</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>前序（中左右）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        stack&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">NULL</span>) &#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);  <span class="hljs-comment">// 右</span><br>                <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);    <span class="hljs-comment">// 左</span><br>                st.<span class="hljs-built_in">push</span>(node);                          <span class="hljs-comment">// 中</span><br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>                node = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                result.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>后续（左右中）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        stack&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">NULL</span>) &#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>                st.<span class="hljs-built_in">push</span>(node);                          <span class="hljs-comment">// 中</span><br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>);<br><br>                <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);  <span class="hljs-comment">// 右</span><br>                <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);    <span class="hljs-comment">// 左</span><br><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>                node = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                result.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>3、二叉树的层序遍历</p>
<p>size用来控制每一层元素的个数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>            <span class="hljs-comment">// 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的，</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                vec.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>                <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>            result.<span class="hljs-built_in">push_back</span>(vec);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>算法刷题总结</div>
      <div>http://example.com/2024/05/31/算法刷题总结/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>ZDS</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年5月31日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/05/27/%E5%9F%BA%E4%BA%8E%E8%B7%B3%E8%A1%A8%E7%9A%84KV%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E9%A1%B9%E7%9B%AE/" title="基于跳表的KV存储引擎项目">
                        <span class="hidden-mobile">基于跳表的KV存储引擎项目</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
